<!doctype html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=Edge"> 
  <meta name="application-name" content="JIRA" data-name="jira" data-version="7.6.3">
  <meta name="ajs-viewissue-use-history-api" content="false"> 
  <meta name="ajs-jira-base-url" content="https://issues.apache.org/jira"> 
  <meta name="ajs-serverRenderedViewIssue" content="true"> 
  <meta name="ajs-dev-mode" content="false"> 
  <meta name="ajs-context-path" content="/jira"> 
  <meta name="ajs-version-number" content="7.6.3"> 
  <meta name="ajs-build-number" content="76005"> 
  <meta name="ajs-is-beta" content="false"> 
  <meta name="ajs-is-rc" content="false"> 
  <meta name="ajs-is-snapshot" content="false"> 
  <meta name="ajs-is-milestone" content="false"> 
  <meta name="ajs-remote-user" content=""> 
  <meta name="ajs-remote-user-fullname" content=""> 
  <meta name="ajs-user-locale" content="en_UK"> 
  <meta name="ajs-user-locale-group-separator" content=","> 
  <meta name="ajs-app-title" content="ASF JIRA"> 
  <meta name="ajs-keyboard-shortcuts-enabled" content="true"> 
  <meta name="ajs-keyboard-accesskey-modifier" content="Ctrl+Alt"> 
  <meta name="ajs-enabled-dark-features" content="[&quot;com.atlassian.jira.agile.darkfeature.editable.detailsview&quot;,&quot;nps.survey.inline.dialog&quot;,&quot;com.atlassian.jira.agile.darkfeature.edit.closed.sprint.enabled&quot;,&quot;jira.plugin.devstatus.phasetwo&quot;,&quot;jira.frother.reporter.field&quot;,&quot;atlassian.rest.xsrf.legacy.enabled&quot;,&quot;jira.issue.status.lozenge&quot;,&quot;com.atlassian.jira.config.BIG_PIPE&quot;,&quot;com.atlassian.jira.projects.issuenavigator&quot;,&quot;com.atlassian.jira.config.PDL&quot;,&quot;jira.plugin.devstatus.phasetwo.enabled&quot;,&quot;atlassian.aui.raphael.disabled&quot;,&quot;app-switcher.new&quot;,&quot;frother.assignee.field&quot;,&quot;com.atlassian.jira.projects.ProjectCentricNavigation.Switch&quot;,&quot;sd.internal.base.off.thread.on.completion.events.enabled&quot;,&quot;jira.onboarding.cyoa&quot;,&quot;com.atlassian.jira.agile.darkfeature.kanplan.enabled&quot;,&quot;sd.slavalue.record.updated.date.enabled&quot;,&quot;com.atlassian.jira.config.ProjectConfig.MENU&quot;,&quot;com.atlassian.jira.projects.sidebar.DEFER_RESOURCES&quot;,&quot;com.atlassian.jira.agile.darkfeature.kanplan.epics.and.versions.enabled&quot;,&quot;com.atlassian.jira.agile.darkfeature.sprint.goal.enabled&quot;,&quot;jira.zdu.admin-updates-ui&quot;,&quot;jira.zdu.jmx-monitoring&quot;,&quot;sd.sla.improved.rendering.enabled&quot;,&quot;sd.canned.responses.enabled&quot;,&quot;sd.new.settings.sidebar.location.disabled&quot;,&quot;jira.zdu.cluster-upgrade-state&quot;,&quot;com.atlassian.jira.agile.darkfeature.splitissue&quot;,&quot;com.atlassian.jira.config.CoreFeatures.LICENSE_ROLES_ENABLED&quot;,&quot;com.atlassian.feedback.feedback-button-move-to-header-enable&quot;,&quot;jira.export.csv.enabled&quot;]"> 
  <meta name="ajs-in-admin-mode" content="false"> 
  <meta name="ajs-is-sysadmin" content="false"> 
  <meta name="ajs-is-admin" content="false"> 
  <meta name="ajs-outgoing-mail-enabled" content="true"> 
  <meta name="ajs-date-relativize" content="true"> 
  <meta name="ajs-date-time" content="HH:mm"> 
  <meta name="ajs-date-day" content="EEEE HH:mm"> 
  <meta name="ajs-date-dmy" content="dd/MMM/yy"> 
  <meta name="ajs-date-complete" content="dd/MMM/yy HH:mm"> 
  <script type="text/javascript">var AJS=AJS||{};AJS.debug=true;</script> 
  <meta id="atlassian-token" name="atlassian-token" content="A5KQ-2QAV-T4JA-FDED|2bef63b2ef067fd41bcf72491c5be22b30fa5405|lout"> 
  <link rel="shortcut icon" href="/jira/s/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/_/favicon.ico"> 
  <!--[if IE]><![endif]--> 
  <script type="text/javascript">
    (function() {
        var contextPath = '/jira';
        var eventBuffer = [];

        function printDeprecatedMsg() {
            if (console && console.warn) {
                console.warn('DEPRECATED JS - contextPath global variable has been deprecated since 7.4.0. Use `wrm/context-path` module instead.');
            }
        }

        function sendEvent(analytics, postfix) {
            analytics.send({
                name: 'js.globals.contextPath.' + postfix
            });
        }

        function sendDeprecatedEvent(postfix) {
            try {
                var analytics = require('jira/analytics');
                if (eventBuffer.length) {
                    eventBuffer.forEach(function(value) {
                        sendEvent(analytics, value);
                    });
                    eventBuffer = [];
                }

                if (postfix) {
                    sendEvent(analytics, postfix);
                }
            } catch(ex) {
                eventBuffer.push(postfix);
                setTimeout(sendDeprecatedEvent, 1000);
            }
        }

        Object.defineProperty(window, 'contextPath', {
            get: function() {
                printDeprecatedMsg();
                sendDeprecatedEvent('get');
                return contextPath;
            },
            set: function(value) {
                printDeprecatedMsg();
                sendDeprecatedEvent('set');
                contextPath = value;
            }
        });
    })();

</script> 
  <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\"/jira\"";
WRM._unparsedData["jira.webresources:feature-flags.feature-flag-data"]="{\"enabled-feature-keys\":[\"com.atlassian.jira.agile.darkfeature.editable.detailsview\",\"nps.survey.inline.dialog\",\"com.atlassian.jira.agile.darkfeature.edit.closed.sprint.enabled\",\"jira.plugin.devstatus.phasetwo\",\"jira.frother.reporter.field\",\"atlassian.rest.xsrf.legacy.enabled\",\"jira.issue.status.lozenge\",\"com.atlassian.jira.config.BIG_PIPE\",\"com.atlassian.jira.projects.issuenavigator\",\"com.atlassian.jira.config.PDL\",\"jira.plugin.devstatus.phasetwo.enabled\",\"atlassian.aui.raphael.disabled\",\"app-switcher.new\",\"frother.assignee.field\",\"com.atlassian.jira.projects.ProjectCentricNavigation.Switch\",\"sd.internal.base.off.thread.on.completion.events.enabled\",\"jira.onboarding.cyoa\",\"com.atlassian.jira.agile.darkfeature.kanplan.enabled\",\"sd.slavalue.record.updated.date.enabled\",\"com.atlassian.jira.config.ProjectConfig.MENU\",\"com.atlassian.jira.projects.sidebar.DEFER_RESOURCES\",\"com.atlassian.jira.agile.darkfeature.kanplan.epics.and.versions.enabled\",\"com.atlassian.jira.agile.darkfeature.sprint.goal.enabled\",\"jira.zdu.admin-updates-ui\",\"jira.zdu.jmx-monitoring\",\"sd.sla.improved.rendering.enabled\",\"sd.canned.responses.enabled\",\"sd.new.settings.sidebar.location.disabled\",\"jira.zdu.cluster-upgrade-state\",\"com.atlassian.jira.agile.darkfeature.splitissue\",\"com.atlassian.jira.config.CoreFeatures.LICENSE_ROLES_ENABLED\",\"com.atlassian.feedback.feedback-button-move-to-header-enable\",\"jira.export.csv.enabled\"],\"feature-flag-states\":{\"sd.customer.profile.multi.languages\":true,\"sd.customer.portal.transitions\":true,\"sd.customer.portal.transitions.config\":true,\"sd.custom.email.stripping.rules\":false,\"sd.sla.lucene.issue.id.callback.performance\":true,\"sd.new.settings.sidebar.location\":true,\"sd.workload.report.paginator\":true,\"sd.experimental.portal.search.algorithm.default.1\":false,\"sd.customer.portal.help.center.agent.announcement\":true,\"sd.sla.improved.rendering\":false,\"sd.experimental.portal.search.algorithm.default.2\":false,\"sd.customer.feedback.validate.reporter.on.token\":true,\"sd.custom.email.notifications.utf8.csat.star\":true,\"sd.who.create.customers.by.email.setting\":true,\"com.atlassian.jira.issuetable.move.links.hidden\":true,\"jira.renderer.consider.variable.format\":true,\"sd.stats.event.tracking\":true,\"sd.password.helper.dialog\":true,\"sd.canned.responses\":false,\"sd.portal.help.center.customer.signup.secondary.email\":true,\"sd.custom.email.notifications.manage.language\":true,\"sd.use.search.by.permissions\":true,\"sd.slavalue.record.updated.date\":false,\"sd.report.custom.date.range\":false,\"sd.kb.article.helpfulness.report\":false,\"com.atlassian.jira.agile.darkfeature.sprint.goal\":false,\"sd.custom.email.notifications.styling\":true,\"sd.workinghours.new.page.bulldog.1\":false,\"sd.customer.portal.two.step.login\":false,\"sd.automation.psmq.async.executor\":true,\"sd.customer.org.list.page.lazy.search\":true,\"sd.approval.requested.when.handler\":true,\"sd.request.type.field.rest.api.filtering.bugfix\":true,\"sd.automation.then.action.auto.answer.approval\":true,\"com.atlassian.jira.agile.darkfeature.kanplan.epics.and.versions\":false,\"sla.will.only.be.paused.if.they.are.already.started\":true,\"sd.kb.comment.share.stats.collection\":true,\"com.atlassian.jira.upgrade.startup.fix.index\":true,\"sd.customer.orgs.group.participants\":true,\"sd.portal.help.center.customer.signup\":true,\"sd.sla.agent.jql.security.restricted\":true,\"sd.test.feature.flag.x\":true,\"sd.test.feature.flag.y\":false,\"sd.cluster.safe.mail.channel.shutdown\":true,\"sd.email.channel.folders\":false,\"sd.email.analytics.open\":false,\"sd.kb.project.creation.create.link.space\":true,\"sd.workinghours.new.page\":false,\"sd.confluence.anonymous.permission.fix\":true,\"com.atlassian.jira.issuetable.draggable\":true,\"sd.customer.portal.project.agent.announcement\":true,\"sd.automation.audit.log\":true,\"jira.jql.suggestrecentfields\":false,\"sd.canned.responses.check.index.startup\":false,\"sd.new.project.templates\":true,\"sd.custom.email.notifications.custom.rules.simple.ui\":false,\"sd.custom.email.notifications.cut.over\":true,\"sd.dismiss.all.misconfiguration.warnings.setting\":true,\"com.atlassian.jira.agile.darkfeature.optimistic.transitions\":true,\"sd.sla.configurations.export\":true,\"sd.canned.responses.variable.substitution\":true,\"com.atlassian.jira.agile.darkfeature.kanplan\":false,\"sd.internal.base.off.thread.on.completion.events\":false,\"sd.customer.portal.prioties.per.project.fix\":true,\"jira.instrumentation.laas\":false,\"sd.kb.self.service.report\":false,\"sla.improved.request.handling\":true,\"sd.no.schedule.async.upgrade.tasks\":true,\"sd.kb.primary.nav\":true,\"com.atlassian.jira.agile.darkfeature.edit.closed.sprint\":false,\"sd.kb.issueview.panel.phase2\":true,\"sd.email.outsider.comments\":true,\"jira.create.linked.issue\":true,\"sd.kb.issueview.panel\":true,\"jira.sal.host.connect.accessor.existing.transaction.will.create.transactions\":true,\"sd.approvals.light.weight\":false,\"sd.automation.then.webhook\":true,\"sd.respect.inline.edit.issue.off\":true,\"jira.jql.smartautoselectfirst\":false,\"sd.global.portal.search.atlassian.only.tracking\":false,\"sd.automation.if.condition.comment.primary.action\":true,\"jira.priorities.per.project\":true,\"sd.inline.noformat.renderer\":true,\"sd.customer.request.type.create.edit.screens\":true}}";
WRM._unparsedData["jira.webresources:default-comment-security-level.DefaultCommentSecurityLevelHelpLink"]="{\"extraClasses\":\"default-comment-level-help\",\"title\":\"Commenting on an Issue\",\"url\":\"https://docs.atlassian.com/jira/jcore-docs-076/Editing+and+collaborating+on+issues#Editingandcollaboratingonissues-restrictacomment\",\"isLocal\":false}";
WRM._unparsedData["jira.webresources:dateFormatProvider.allFormats"]="{\"dateFormats\":{\"meridiem\":[\"AM\",\"PM\"],\"eras\":[\"BC\",\"AD\"],\"months\":[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"monthsShort\":[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"weekdaysShort\":[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],\"weekdays\":[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"]},\"lookAndFeelFormats\":{\"relativize\":\"true\",\"time\":\"HH:mm\",\"day\":\"EEEE HH:mm\",\"dmy\":\"dd/MMM/yy\",\"complete\":\"dd/MMM/yy HH:mm\"}}";
WRM._unparsedData["com.atlassian.jira.jira-issue-nav-components:issueviewer.features"]="{\"rteEnabled\":true}";
WRM._unparsedData["com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.thumbnail-mime-types"]="\"image/png,image/vnd.wap.wbmp,image/x-png,image/jpeg,image/bmp,image/gif\"";
WRM._unparsedData["com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.upload-limit"]="\"62914560\"";
WRM._unparsedData["com.atlassian.plugins.helptips.jira-help-tips:help-tip-manager.JiraHelpTipData"]="{\"anonymous\":true}";
WRM._unparsedData["com.atlassian.jira.jira-view-issue-plugin:controller-subtasks.controller.subtasks.parameters"]="{\"url\":\"/rest/api/2/issue/{issueId}/subtask/move\"}";
WRM._unparsedData["com.atlassian.analytics.analytics-client:policy-update-init.policy-update-data-provider"]="false";
WRM._unparsedData["com.atlassian.analytics.analytics-client:programmatic-analytics-init.programmatic-analytics-data-provider"]="false";
WRM._unparsedData["com.atlassian.servicedesk.servicedesk-canned-responses-plugin:canned-responses-data-provider.data"]="{\"substitutionVariables\":{\"issue.summary\":\"Issue summary\",\"issue.description\":\"Issue description\",\"issue.key\":\"Issue key\",\"issue.reporter.name\":\"Issue reporter\",\"issue.resolution\":\"Issue resolution\",\"request.url\":\"Request URL\",\"request.status\":\"Request status\"}}";
WRM._unparsedData["jira.webresources:avatar-picker.data"]="{}";
WRM._unparsedData["com.atlassian.feedback.jira-feedback-plugin:button-resources-init.data"]="{\"jira.feedback.plugin.issue.collector.core\":\"https://jira.atlassian.com/s/576e9ab86257d4f65f6ea5b6dd50de44-T/en_UK3ljiw5/71006/b6b48b2829824b869586ac216d119363/2.0.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs.js?locale=en-UK&collectorId=abbf546d\",\"jira.feedback.plugin.issue.collector.default\":\"https://jira.atlassian.com/s/576e9ab86257d4f65f6ea5b6dd50de44-T/en_UK3ljiw5/71006/b6b48b2829824b869586ac216d119363/2.0.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs.js?locale=en-UK&collectorId=abbf546d\",\"jira.feedback.plugin.issue.collector.service.desk\":\"https://jira.atlassian.com/s/576e9ab86257d4f65f6ea5b6dd50de44-T/en_UK3ljiw5/71006/b6b48b2829824b869586ac216d119363/2.0.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-UK&collectorId=a698db21\",\"jira.feedback.plugin.issue.collector.software\":\"https://jira.atlassian.com/s/576e9ab86257d4f65f6ea5b6dd50de44-T/en_UK3ljiw5/71006/b6b48b2829824b869586ac216d119363/2.0.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs.js?locale=en-UK&collectorId=abbf546d\",\"isHeaderFeedbackButtonEnabled\":true}";
WRM._unparsedData["com.atlassian.jira.jira-header-plugin:dismissedFlags.flags"]="{\"dismissed\":[]}";
WRM._unparsedData["com.atlassian.jira.jira-header-plugin:newsletter-signup-tip-init.newsletterSignup"]="{\"signupDescription\":\"Get updates, inspiration and best practices from the team behind JIRA.\",\"formUrl\":\"https://www.atlassian.com/apis/exact-target/{0}/subscribe?mailingListId=1401671\",\"signupTitle\":\"Sign up!\",\"signupId\":\"newsletter-signup-tip\",\"showNewsletterTip\":false}";
WRM._unparsedData["com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources.ptAnalyticsData"]="{\"instanceCreatedDate\":\"2011-01-31\"}";
WRM._unparsedData["com.atlassian.servicedesk.core-ui:util-help-links.help-links"]="{\"help\":{\"email.settings\":\"https://docs.atlassian.com/jira/jsd-docs-039/Receiving+requests+by+email\",\"managing.queues\":\"https://docs.atlassian.com/jira/jsd-docs-039/Setting+up+queues+for+your+team\",\"email.setup\":\"https://docs.atlassian.com/jira/jsd-docs-039/Receiving+requests+by+email\",\"request.settings.help.bubble\":\"https://docs.atlassian.com/jira/jsd-docs-039/Managing+access+to+your+service+desk\",\"email.settings.suitablerequest\":\"https://docs.atlassian.com/jira/jsd-docs-039/Receiving+requests+by+email#Receivingrequestsbyemail-suitablerequest\",\"sla.import.help\":\"https://docs.atlassian.com/jira/jsd-docs-039/Importing+SLAs\",\"documentation.home\":\"https://docs.atlassian.com/jira/jsd-docs-039/JIRA+Service+Desk+Documentation\",\"default\":\"https://docs.atlassian.com/jira/jsd-docs-039/\",\"create.space.help\":\"https://docs.atlassian.com/jira/jsd-docs-039/Serving+customers+with+a+knowledge+base#serving-customers-with-a-knowledge-base-createpermission\",\"email.settings.troubleshooting\":\"https://docs.atlassian.com/jira/jsd-docs-039/Troubleshooting+issues+with+the+email+channel\",\"admin.notifications.config\":\"https://docs.atlassian.com/jira/jsd-docs-039/Managing+service+desk+notifications\",\"troubleshoot.requesttype\":\"https://docs.atlassian.com/jira/jsd-docs-039/Troubleshooting+issues+with+request+types\",\"approvals.configuration\":\"https://docs.atlassian.com/jira/jsd-docs-039/Configuring+JIRA+Service+Desk+approvals\",\"setting.up.reports\":\"https://docs.atlassian.com/jira/jsd-docs-039/Setting+up+service+desk+reports\",\"public.signup\":\"https://docs.atlassian.com/jira/jsd-docs-039/Configuring+public+signup\",\"knowledge.base\":\"https://docs.atlassian.com/jira/jsd-docs-039/Serving+customers+with+a+knowledge+base\",\"resolve.permission.scheme.errors\":\"https://docs.atlassian.com/jira/jsd-docs-039/Resolving+permission+scheme+errors\",\"getting.started\":\"https://docs.atlassian.com/jira/jsd-docs-039/Getting+started+with+JIRA+Service+Desk\",\"getting.started.agent\":\"https://docs.atlassian.com/jira/jsd-docs-039/Getting+started+for+service+desk+agents\",\"invite.customers\":\"https://docs.atlassian.com/jira/jsd-docs-039/Managing+access+to+your+service+desk\"},\"kb\":{\"default\":\"https://confluence.atlassian.com/display/SDKB/\",\"troubleshooting.user.management.issues\":\"https://confluence.atlassian.com/display/SDKB/Troubleshooting+issues+with+service+desk+user+management\",\"legacytransition\":\"https://confluence.atlassian.com/display/SDKB/Replacing+legacy+automatic+transitions+with+automation+rules\",\"umtroubleshoot\":\"https://confluence.atlassian.com/display/SDKB/Troubleshooting+issues+with+service+desk+user+management\"}}";
WRM._unparsedData["com.atlassian.servicedesk.core-ui:util-base-url.base-url"]="\"https://issues.apache.org/jira\"";
WRM._unparsedData["com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources.help-data"]="{\"showHelp\":true,\"editorDocumentationUrl\":[\"https://docs.atlassian.com/jira/jcore-docs-076/Visual+editing\"],\"editorDocumentationTitle\":[\"Show me documentation for the visual editor\"]}";
WRM._unparsedData["com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources.thumbnails-allowed"]="false";
WRM._unparsedData["jira.webresources:user-message-flags.adminLockout"]="{}";
WRM._unparsedData["jira.request.correlation-id"]="\"170558f480d01\"";
WRM._unparsedData["project-id"]="12310110";
WRM._unparsedData["project-key"]="\"LUCENE\"";
WRM._unparsedData["project-name"]="\"Lucene - Core\"";
WRM._unparsedData["project-type"]="\"software\"";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:generic-filters"]="[{\"id\":\"allissues\",\"jql\":\"project = \\\"{0}\\\" ORDER BY {1}\",\"defaultOrderby\":\"created DESC\",\"label\":\"All issues\",\"requiresUser\":false,\"supportsInlineIssueCreate\":true,\"fields\":[]},{\"id\":\"allopenissues\",\"jql\":\"project = \\\"{0}\\\" AND resolution = Unresolved ORDER BY {1}\",\"defaultOrderby\":\"priority DESC, updated DESC\",\"label\":\"Open issues\",\"requiresUser\":false,\"supportsInlineIssueCreate\":true,\"fields\":[\"resolution\"]},{\"id\":\"doneissues\",\"jql\":\"project = \\\"{0}\\\" AND statusCategory = Done ORDER BY {1}\",\"defaultOrderby\":\"updated DESC\",\"label\":\"Done issues\",\"requiresUser\":false,\"supportsInlineIssueCreate\":false,\"fields\":[\"status\"]},{\"id\":\"recentlyviewed\",\"jql\":\"project = \\\"{0}\\\" AND issuekey in issueHistory() ORDER BY {1}\",\"defaultOrderby\":\"lastViewed DESC\",\"label\":\"Viewed recently\",\"requiresUser\":false,\"supportsInlineIssueCreate\":true,\"fields\":[\"issuekey\"]},{\"id\":\"addedrecently\",\"jql\":\"project = \\\"{0}\\\" AND created \u003e= -1w ORDER BY {1}\",\"defaultOrderby\":\"created DESC\",\"label\":\"Created recently\",\"requiresUser\":false,\"supportsInlineIssueCreate\":true,\"fields\":[\"created\"]},{\"id\":\"resolvedrecently\",\"jql\":\"project = \\\"{0}\\\" AND resolutiondate \u003e= -1w ORDER BY {1}\",\"defaultOrderby\":\"updated DESC\",\"label\":\"Resolved recently\",\"requiresUser\":false,\"supportsInlineIssueCreate\":false,\"fields\":[\"resolutiondate\"]},{\"id\":\"updatedrecently\",\"jql\":\"project = \\\"{0}\\\" AND updated \u003e= -1w ORDER BY {1}\",\"defaultOrderby\":\"updated DESC\",\"label\":\"Updated recently\",\"requiresUser\":false,\"supportsInlineIssueCreate\":true,\"fields\":[\"updated\"]}]";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:default-filter-priority"]="[\"allopenissues\",\"allissues\"]";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:can-manage-filters"]="false";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:project-filters"]="[]";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:can-create-issues"]="false";
WRM._unparsedData["projectId"]="12310110";
WRM._unparsedData["projectKey"]="\"LUCENE\"";
WRM._unparsedData["projectType"]="\"software\"";
WRM._unparsedData["com.atlassian.jira.jira-projects-issue-navigator:server-rendered"]="true";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script> 
  <link type="text/css" rel="stylesheet" href="/jira/s/a8a4711bc3f2eb261d8c8fd9fbcbba8b-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1fca1750044f2777c977e8d8cc023344/_/download/contextbatch/css/_super/batch.css" data-wrm-key="_super" data-wrm-batch-type="context" media="all"> 
  <link type="text/css" rel="stylesheet" href="/jira/s/1a6b21131945f6f49ff48336b49ca3fe-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/37a6e594cbbfd462a8a54d5aa11475c1/_/download/contextbatch/css/project.issue.navigator,jira.view.issue,jira.global,atl.general,jira.general,-_super/batch.css?agile_global_admin_condition=true&amp;hc-enabled=true&amp;is-server-instance=true&amp;jag=true&amp;jira.create.linked.issue=true&amp;nps-acknowledged=true&amp;richediton=true&amp;sd_operational=true" data-wrm-key="project.issue.navigator,jira.view.issue,jira.global,atl.general,jira.general,-_super" data-wrm-batch-type="context" media="all"> 
  <link type="text/css" rel="stylesheet" href="/jira/s/611672383f6cab00ab202241ba6f9d68-T/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/7.6.3/_/download/batch/com.atlassian.feedback.jira-feedback-plugin:button-resources-init/com.atlassian.feedback.jira-feedback-plugin:button-resources-init.css" data-wrm-key="com.atlassian.feedback.jira-feedback-plugin:button-resources-init" data-wrm-batch-type="resource" media="all"> 
  <script type="text/javascript" src="/jira/s/d8484c9183f546511a8e336a8779bcd9-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1fca1750044f2777c977e8d8cc023344/_/download/contextbatch/js/_super/batch.js?locale=en-UK" data-wrm-key="_super" data-wrm-batch-type="context" data-initially-rendered></script> 
  <script type="text/javascript" src="/jira/s/d3b35d835f8f46fc3b53bb4db7f85158-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/37a6e594cbbfd462a8a54d5aa11475c1/_/download/contextbatch/js/project.issue.navigator,jira.view.issue,jira.global,atl.general,jira.general,-_super/batch.js?agile_global_admin_condition=true&amp;hc-enabled=true&amp;is-server-instance=true&amp;jag=true&amp;jira.create.linked.issue=true&amp;locale=en-UK&amp;nps-acknowledged=true&amp;richediton=true&amp;sd_operational=true" data-wrm-key="project.issue.navigator,jira.view.issue,jira.global,atl.general,jira.general,-_super" data-wrm-batch-type="context" data-initially-rendered></script> 
  <script type="text/javascript" src="/jira/s/71d42e74136d842a3ef4d5d136484843-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/871d45c9f322a22cb3aa9b7948a69803/_/download/contextbatch/js/atl.global,-_super/batch.js?locale=en-UK" data-wrm-key="atl.global,-_super" data-wrm-batch-type="context" data-initially-rendered></script> 
  <script type="text/javascript" src="/jira/s/d41d8cd98f00b204e9800998ecf8427e-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1.0/_/download/batch/jira.webresources:calendar-en/jira.webresources:calendar-en.js" data-wrm-key="jira.webresources:calendar-en" data-wrm-batch-type="resource" data-initially-rendered></script> 
  <script type="text/javascript" src="/jira/s/d41d8cd98f00b204e9800998ecf8427e-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1.0/_/download/batch/jira.webresources:calendar-localisation-moment/jira.webresources:calendar-localisation-moment.js" data-wrm-key="jira.webresources:calendar-localisation-moment" data-wrm-batch-type="resource" data-initially-rendered></script> 
  <script type="text/javascript" src="/jira/s/d41d8cd98f00b204e9800998ecf8427e-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/7.6.3/_/download/batch/com.atlassian.feedback.jira-feedback-plugin:button-resources/com.atlassian.feedback.jira-feedback-plugin:button-resources.js" data-wrm-key="com.atlassian.feedback.jira-feedback-plugin:button-resources" data-wrm-batch-type="resource" data-initially-rendered></script> 
  <link type="text/css" rel="stylesheet" href="/jira/s/95a4826c265852f4904f1e0e7300df68-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/e0de73613a1027de08f3da6a45e1d1a2/_/download/contextbatch/css/jira.global.look-and-feel,-_super/batch.css" data-wrm-key="jira.global.look-and-feel,-_super" data-wrm-batch-type="context" media="all"> 
  <script type="text/javascript" src="/jira/rest/api/1.0/shortcuts/76005/944bb39eced1b35cfc7194aa02eb5a5a/shortcuts.js?context=issuenavigation&amp;context=issueaction"></script> 
  <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["com.atlassian.jira.jira-issue-nav-components:inline-edit-enabled"]="true";
WRM._unparsedData["should-display-chaperone"]="false";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script> 
  <link type="text/css" rel="stylesheet" href="/jira/s/15712b600e9aecf72ffd9fd3704a0c78-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/6b22a15c7b83f87a47b1757076f43542/_/download/contextbatch/css/com.atlassian.jira.projects.sidebar.init,-_super,-project.issue.navigator,-jira.view.issue/batch.css?jira.create.linked.issue=true&amp;richediton=true&amp;sd_operational=true" data-wrm-key="com.atlassian.jira.projects.sidebar.init,-_super,-project.issue.navigator,-jira.view.issue" data-wrm-batch-type="context" media="all"> 
  <script type="text/javascript" src="/jira/s/5a8f0f8b8aa8f96a4f0f7e9e248d62f3-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/6b22a15c7b83f87a47b1757076f43542/_/download/contextbatch/js/com.atlassian.jira.projects.sidebar.init,-_super,-project.issue.navigator,-jira.view.issue/batch.js?jira.create.linked.issue=true&amp;locale=en-UK&amp;richediton=true&amp;sd_operational=true" data-wrm-key="com.atlassian.jira.projects.sidebar.init,-_super,-project.issue.navigator,-jira.view.issue" data-wrm-batch-type="context" data-initially-rendered></script> 
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
  <meta name="ajs-can-search-users" content="false"> 
  <meta name="ajs-can-edit-watchers" content="false"> 
  <meta name="ajs-default-avatar-url" content="https://issues.apache.org/jira/secure/useravatar?size=xsmall&amp;avatarId=10453"> 
  <meta name="ajs-issue-project-type" content="software"> 
  <meta name="ajs-issue-key" content="LUCENE-847"> 
  <meta name="ajs-server-view-issue-is-editable" content="false"> 
  <title>[LUCENE-847] Factor merge policy out of IndexWriter - ASF JIRA</title> 
  <link rel="search" type="application/opensearchdescription+xml" href="/jira/osd.jsp" title="[LUCENE-847] Factor merge policy out of IndexWriter - ASF JIRA"> 
 </head> 
 <body id="jira" class="aui-layout aui-theme-default " data-version="7.6.3"> 
  <div id="page"> 
   <header id="header" role="banner"> 
    <script>
require(["jquery", "jira/license-banner"], function ($, licenseBanner) {
    $(function () {
        licenseBanner.showLicenseBanner("");
        licenseBanner.showLicenseFlag("");
    });
});
</script> 
    <nav class="aui-header aui-dropdown2-trigger-group" role="navigation">
     <div class="aui-header-inner">
      <div class="aui-header-before">
       <a class=" aui-dropdown2-trigger app-switcher-trigger" aria-controls="app-switcher" aria-haspopup="true" role="button" tabindex="0" data-aui-trigger href="#app-switcher"><span class="aui-icon aui-icon-small aui-iconfont-appswitcher">Linked Applications</span></a>
       <div id="app-switcher" class="aui-dropdown2 aui-style-default" role="menu" aria-hidden="true" data-is-switcher="true" data-environment="{&quot;isUserAdmin&quot;:false,&quot;isAppSuggestionAvailable&quot;:false,&quot;isSiteAdminUser&quot;:false}">
        <div role="application">
         <div class="app-switcher-loading">
          Loading…
         </div>
        </div>
       </div>
      </div>
      <div class="aui-header-primary">
       <h1 id="logo" class="aui-header-logo aui-header-logo-custom"><a href="https://issues.apache.org/jira/secure/MyJiraHome.jspa"><img src="/jira/s/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/_/jira-logo-scaled.png" alt="ASF JIRA"></a></h1>
       <ul class="aui-nav">
        <li><a href="/jira/secure/Dashboard.jspa" class=" aui-nav-link aui-dropdown2-trigger aui-dropdown2-ajax" id="home_link" aria-haspopup="true" aria-controls="home_link-content" title="View and manage your dashboards" accesskey="d">Dashboards</a>
         <div class="aui-dropdown2 aui-style-default" id="home_link-content" data-aui-dropdown2-ajax-key="home_link"></div></li>
        <li><a href="/jira/browse/LUCENE" class=" aui-nav-link aui-dropdown2-trigger aui-dropdown2-ajax" id="browse_link" aria-haspopup="true" aria-controls="browse_link-content" title="View recent projects and browse a list of projects" accesskey="p">Projects</a>
         <div class="aui-dropdown2 aui-style-default" id="browse_link-content" data-aui-dropdown2-ajax-key="browse_link"></div></li>
        <li><a href="/jira/issues/" class=" aui-nav-link aui-dropdown2-trigger aui-dropdown2-ajax" id="find_link" aria-haspopup="true" aria-controls="find_link-content" title="Search for issues and view recent issues" accesskey="i">Issues</a>
         <div class="aui-dropdown2 aui-style-default" id="find_link-content" data-aui-dropdown2-ajax-key="find_link"></div></li> 
       </ul>
      </div>
      <div class="aui-header-secondary">
       <ul class="aui-nav">
        <li id="quicksearch-menu"> 
         <form action="/jira/secure/QuickSearch.jspa" method="get" id="quicksearch" class="aui-quicksearch dont-default-focus ajs-dirty-warning-exempt"> 
          <input id="quickSearchInput" class="search" type="text" title="Search" placeholder="Search" name="searchString" accessKey="q"> 
          <input type="submit" class="hidden" value="Search"> 
         </form> </li> 
        <li><a class="jira-feedback-plugin" role="button" aria-haspopup="true" id="jira-header-feedback-link" href="#"><span class="aui-icon aui-icon-small jira-feedback-plugin-icon">Give feedback to Atlassian</span></a></li> 
        <li id="system-help-menu"> <a class="aui-nav-link aui-dropdown2-trigger" id="help_menu" aria-haspopup="true" aria-owns="system-help-menu-content" href="https://docs.atlassian.com/jira/jcore-docs-076/" target="$textUtils.htmlEncode($rootHelpMenuItem.params.target)" title="Help"><span class="aui-icon aui-icon-small aui-iconfont-help">Help</span></a> 
         <div id="system-help-menu-content" class="aui-dropdown2 aui-style-default"> 
          <div class="aui-dropdown2-section"> 
           <ul id="jira-help" class="aui-list-truncate"> 
            <li> <a id="view_core_help" class="aui-nav-link " title="Go to the online documentation for JIRA Core" href="https://docs.atlassian.com/jira/jcore-docs-076/" target="_blank">JIRA Core help</a> </li> 
            <li> <a id="keyshortscuthelp" class="aui-nav-link " title="Get more information about JIRA's Keyboard Shortcuts" href="/jira/secure/ViewKeyboardShortcuts!default.jspa" target="_blank">Keyboard Shortcuts</a> </li> 
            <li> <a id="view_about" class="aui-nav-link " title="Get more information about JIRA" href="/jira/secure/AboutPage.jspa">About JIRA</a> </li> 
            <li> <a id="view_credits" class="aui-nav-link " title="See who did what" href="/jira/secure/JiraCreditsPage!default.jspa" target="_blank">JIRA Credits</a> </li> 
           </ul> 
          </div> 
         </div> </li> 
        <li id="user-options"> <a class="aui-nav-link login-link" href="/jira/login.jsp?os_destination=%2Fbrowse%2FLUCENE-847">Log In</a> 
         <div id="user-options-content" class="aui-dropdown2 aui-style-default"> 
          <div class="aui-dropdown2-section"> 
          </div> 
         </div> </li> 
       </ul>
      </div>
     </div>
     <!-- .aui-header-inner-->
    </nav>
    <!-- .aui-header --> 
   </header> 
   <section id="content" role="main"> 
    <big-pipe data-id="sidebar-id" unresolved></big-pipe>
    <div class="aui-sidebar  sidebar-placeholder">
     <div class="aui-sidebar-wrapper">
      <div class="aui-sidebar-body"></div>
      <div class="aui-sidebar-footer">
       <a class="aui-button aui-button-subtle aui-sidebar-toggle aui-sidebar-footer-tipsy" data-tooltip="Expand sidebar ( [ )" href="#"><span class="aui-icon aui-icon-small"></span></a>
      </div>
     </div>
    </div>
    <script id="projects-sidebar-init">
    require(['jira/projects/sidebar/expansion-manager'], function(expansionManager) {
        var scriptTag = document.getElementById('projects-sidebar-init');
        var sidebar = AJS.sidebar('.aui-sidebar');
        expansionManager(sidebar);
        scriptTag.parentElement.removeChild(scriptTag);
    });
    </script>
    <div class="aui-page-panel">
     <div class="aui-page-panel-inner">
      <div class="issue-navigator">
       <div class="content">
        <div class="issue-view">
         <div class="navigation-tools">
          <div class="pager-container"></div>
         </div>
         <div class="issue-container">
          <div id="issue-content" class="issue-edit-form">
           <header id="stalker" class="issue-header js-stalker">
            <div class="issue-header-content">
             <header class="aui-page-header">
              <div class="aui-page-header-inner">
               <div class="aui-page-header-image">
                <span id="12310110" class="aui-avatar aui-avatar-large aui-avatar-project"><span class="aui-avatar-inner"><img id="project-avatar" alt="Uploaded image for project: 'Lucene - Core'" src="https://issues.apache.org/jira/secure/projectavatar?pid=12310110&amp;avatarId=10061"></span></span>
               </div>
               <!-- .aui-page-header-image -->
               <div class="aui-page-header-main">
                <ol class="aui-nav aui-nav-breadcrumbs">
                 <li><a id="project-name-val" href="/jira/browse/LUCENE">Lucene - Core</a></li>
                 <li><a class="issue-link" data-issue-key="LUCENE-847" href="/jira/browse/LUCENE-847" id="key-val" rel="12365696">LUCENE-847</a></li>
                </ol>
                <h1 id="summary-val">Factor merge policy out of IndexWriter</h1>
               </div>
               <!-- .aui-page-header-main -->
               <div class="aui-page-header-actions">
                <div id="issue-header-pager"></div>
               </div>
               <!-- .aui-page-header-actions -->
              </div>
              <!-- .aui-page-header-inner -->
             </header>
             <!-- .aui-page-header -->
             <div class="command-bar">
              <div class="ops-cont">
               <div class="ops-menus aui-toolbar">
                <div class="toolbar-split toolbar-split-left">
                 <ul id="opsbar-ops-login-lnk_container" class="toolbar-group pluggable-ops">
                  <li class="toolbar-item"><a id="ops-login-lnk" title="Log In" class="toolbar-trigger" href="/jira/login.jsp?os_destination=%2Fbrowse%2FLUCENE-847"><span class="trigger-label">Log In</span></a></li>
                 </ul>
                 <ul id="opsbar-opsbar-operations" class="toolbar-group pluggable-ops"></ul>
                 <ul id="opsbar-opsbar-transitions" class="toolbar-group pluggable-ops"></ul>
                 <ul id="opsbar-opsbar-admin" class="toolbar-group pluggable-ops"></ul>
                </div>
                <div class="toolbar-split toolbar-split-right">
                 <ul id="opsbar-jira.issue.tools" class="toolbar-group pluggable-ops">
                  <li class="toolbar-item">
                   <div>
                    <a href="#" id="viewissue-export" aria-owns="viewissue-export_drop" aria-haspopup="true" title="Export this issue in another format" class="toolbar-trigger aui-button aui-style-default aui-dropdown2-trigger"><span class="icon icon-default aui-icon aui-icon-small aui-iconfont-export"></span> <span class="dropdown-text">Export</span></a>
                    <div id="viewissue-export_drop" class="aui-style-default aui-dropdown2">
                     <ul>
                      <li class="aui-list-item"><a href="/jira/si/jira.issueviews:issue-xml/LUCENE-847/LUCENE-847.xml" id="jira.issueviews:issue-xml"><span class="trigger-label">XML</span></a></li>
                      <li class="aui-list-item"><a href="/jira/si/jira.issueviews:issue-word/LUCENE-847/LUCENE-847.doc" id="jira.issueviews:issue-word"><span class="trigger-label">Word</span></a></li>
                      <li class="aui-list-item"><a href="/jira/si/jira.issueviews:issue-html/LUCENE-847/LUCENE-847.html" id="jira.issueviews:issue-html"><span class="trigger-label">Printable</span></a></li>
                      <li class="aui-list-item"><a href="/jira/si/com.atlassian.jira.plugins.jira-importers-plugin:issue-json/LUCENE-847/LUCENE-847.json" id="com.atlassian.jira.plugins.jira-importers-plugin:issue-json"><span class="trigger-label">JSON</span></a></li>
                     </ul>
                    </div>
                   </div></li>
                 </ul>
                </div>
               </div>
              </div>
             </div>
            </div>
           </header>
           <div class="issue-body-content">
            <div class="aui-group issue-body">
             <div class="aui-item issue-main-column">
              <div id="details-module" class="module toggle-wrap">
               <div id="details-module_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Details</h2>
               </div>
               <div class="mod-content"> 
                <ul id="issuedetails" class="property-list two-cols"> 
                 <li class="item"> 
                  <div class="wrap"> 
                   <strong class="name">Type:</strong> 
                   <span id="type-val" class="value"> <img alt="" height="16" src="/jira/secure/viewavatar?size=xsmall&amp;avatarId=21140&amp;avatarType=issuetype" title="Improvement - An improvement or enhancement to an existing feature or task." width="16"> Improvement </span> 
                  </div> </li> 
                 <li class="item item-right"> 
                  <div class="wrap"> 
                   <strong class="name">Status:</strong> 
                   <span id="status-val" class="value"> <span class=" jira-issue-status-lozenge aui-lozenge jira-issue-status-lozenge-green jira-issue-status-lozenge-done jira-issue-status-lozenge-max-width-medium" data-tooltip="<span class=&quot;jira-issue-status-tooltip-title&quot;>Closed</span><br><span class=&quot;jira-issue-status-tooltip-desc&quot;>The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.</span>">Closed</span> </span> 
                  </div> </li> 
                 <li class="item new"> 
                  <div class="wrap"> 
                   <strong class="name">Priority:</strong> 
                   <span id="priority-val" class="value"> <img alt="" height="16" src="/jira/images/icons/priorities/major.svg" title="Major - Major loss of function." width="16"> Major </span> 
                  </div> </li> 
                 <li class="item item-right"> 
                  <div class="wrap"> 
                   <strong class="name">Resolution:</strong> 
                   <span id="resolution-val" class="value resolved"> Fixed </span> 
                  </div> </li> 
                 <li class="item"> 
                  <div class="wrap"> 
                   <strong class="name">Affects Version/s:</strong> 
                   <span id="versions-val" class="value"> None </span> 
                  </div> </li> 
                 <li class="item item-right"> 
                  <div class="wrap"> 
                   <strong class="name">Fix Version/s:</strong> 
                   <span id="fixfor-val" class="value"> <span class="shorten" id="fixVersions-field"> <a href="/jira/issues/?jql=project+%3D+LUCENE+AND+fixVersion+%3D+2.3" title="2.3 ">2.3</a> </span> </span> 
                  </div> </li> 
                 <li class="item"> 
                  <div class="wrap"> 
                   <strong class="name">Component/s:</strong> 
                   <span id="components-val" class="value"> <span class="shorten" id="components-field"> <a href="/jira/issues/?jql=project+%3D+LUCENE+AND+component+%3D+%22core%2Findex%22" title="core/index issues with indexing code">core/index</a> </span> </span> 
                  </div> </li> 
                 <li class="item full-width"> 
                  <div class="wrap" id="wrap-labels"> 
                   <strong class="name">Labels:</strong> 
                   <div class="labels-wrap value"> 
                    <span class="labels" id="labels-12365696-value">None</span> 
                   </div> 
                  </div> </li> 
                </ul> 
                <div id="customfieldmodule"> 
                 <div class="aui-tabs horizontal-tabs" id="customfield-tabs"> 
                  <div id="customfield-panel-1" class="tabs-pane active-pane"> 
                   <ul class="property-list"> 
                    <li id="rowForcustomfield_12310120" class="item"> 
                     <div class="wrap"> 
                      <strong title="Lucene Fields" class="name">Lucene Fields:</strong> 
                      <div id="customfield_12310120-val" class="value type-multicheckboxes" data-fieldtype="multicheckboxes" data-fieldtypecompletekey="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes"> 
                       <div class="shorten" id="customfield_12310120-field"> 
                        <span>New</span> 
                       </div> 
                      </div> 
                     </div> </li> 
                   </ul> 
                  </div> 
                 </div>
                </div> 
               </div>
              </div>
              <div id="descriptionmodule" class="module toggle-wrap">
               <div id="descriptionmodule_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Description</h2>
               </div>
               <div class="mod-content">
                <div id="description-val" class="field-ignore-highlight"> 
                 <div class="user-content-block"> 
                  <p>If we factor the merge policy out of IndexWriter, we can make it pluggable, making it possible for apps to choose a custom merge policy and for easier experimenting with merge policy variants.</p> 
                 </div> 
                </div> 
               </div>
              </div>
              <div id="dnd-metadata" class="module toggle-wrap">
               <div id="dnd-metadata_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Attachments</h2>
               </div>
               <div class="mod-content">
                <div id="dnd-metadata-webpanel" data-can-attach="false" data-project-type="software" data-upload-limit="62914560" data-thumbnails-allowed="false"></div>
               </div>
              </div>
              <div id="attachmentmodule" class="module toggle-wrap">
               <div id="attachmentmodule_heading" class="mod-header">
                <ul class="ops">
                 <li class="drop">
                  <div class="aui-dd-parent">
                   <a href="#" class="icon drop-menu js-default-dropdown" title="Options"><span>Options</span></a>
                   <div class="aui-dropdown-content aui-list">
                    <ul id="attachment-sorting-options" class="aui-list-section aui-first">
                     <li class="aui-list-item"><a id="attachment-sort-key-name" href="/jira/browse/LUCENE-847?attachmentSortBy=fileName#attachmentmodule" class="aui-list-checked aui-checked aui-list-item-link" title="viewissue.subtasks.tab.show.all.name"><span>Sort By Name</span></a></li>
                     <li class="aui-list-item"><a id="attachment-sort-key-date" href="/jira/browse/LUCENE-847?attachmentSortBy=dateTime#attachmentmodule" class="aui-list-checked aui-list-item-link" title="Sort By Date"><span>Sort By Date</span></a></li>
                    </ul>
                    <ul id="attachment-sorting-order-options" class="aui-list-section aui-last">
                     <li class="aui-list-item"><a id="attachment-sort-direction-asc" href="/jira/browse/LUCENE-847?attachmentOrder=asc#attachmentmodule" class="aui-list-checked aui-checked aui-list-item-link" title="Ascending"><span>Ascending</span></a></li>
                     <li class="aui-list-item"><a id="attachment-sort-direction-desc" href="/jira/browse/LUCENE-847?attachmentOrder=desc#attachmentmodule" class="aui-list-checked aui-list-item-link" title="Descending"><span>Descending</span></a></li>
                    </ul>
                   </div>
                  </div></li>
                </ul>
                <h2 class="toggle-title">Attachments</h2>
               </div>
               <div class="mod-content">
                <ol id="file_attachments" class="item-attachments" data-sort-key="fileName" data-sort-order="asc">
                 <li class="attachment-content js-file-attachment" data-attachment-id="12354478" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12354478/concurrentMerge.patch" draggable="true" data-downloadurl="text/plain:concurrentMerge.patch:https://issues.apache.org/jira/secure/attachment/12354478/concurrentMerge.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12354478/concurrentMerge.patch" title="Latest  29/Mar/07 03:21 - Ning Li" draggable="true" data-downloadurl="text/plain:concurrentMerge.patch:https://issues.apache.org/jira/secure/attachment/12354478/concurrentMerge.patch">concurrentMerge.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-03-29T03:21:07.379Z">29/Mar/07 03:21</time>
                   </dd>
                   <dd class="attachment-size">
                    104 kB
                   </dd>
                   <dd class="attachment-author">
                    Ning Li
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12363880" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12363880/LUCENE-847.patch.txt" draggable="true" data-downloadurl="text/plain:LUCENE-847.patch.txt:https://issues.apache.org/jira/secure/attachment/12363880/LUCENE-847.patch.txt"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12363880/LUCENE-847.patch.txt" title="Latest  15/Aug/07 19:32 - Steven Parkes" draggable="true" data-downloadurl="text/plain:LUCENE-847.patch.txt:https://issues.apache.org/jira/secure/attachment/12363880/LUCENE-847.patch.txt">LUCENE-847.patch.txt</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-08-15T19:32:29.024Z">15/Aug/07 19:32</time>
                   </dd>
                   <dd class="attachment-size">
                    150 kB
                   </dd>
                   <dd class="attachment-author">
                    Steven Parkes
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment earlier-version" data-attachment-id="12363276" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12363276/LUCENE-847.patch.txt" draggable="true" data-downloadurl="text/plain:LUCENE-847.patch.txt:https://issues.apache.org/jira/secure/attachment/12363276/LUCENE-847.patch.txt"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12363276/LUCENE-847.patch.txt" title=" 06/Aug/07 20:11 - Steven Parkes" draggable="true" data-downloadurl="text/plain:LUCENE-847.patch.txt:https://issues.apache.org/jira/secure/attachment/12363276/LUCENE-847.patch.txt">LUCENE-847.patch.txt</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-08-06T20:11:27.946Z">06/Aug/07 20:11</time>
                   </dd>
                   <dd class="attachment-size">
                    111 kB
                   </dd>
                   <dd class="attachment-author">
                    Steven Parkes
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12364527" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12364527/LUCENE-847.take3.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take3.patch:https://issues.apache.org/jira/secure/attachment/12364527/LUCENE-847.take3.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12364527/LUCENE-847.take3.patch" title="Latest  24/Aug/07 16:38 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take3.patch:https://issues.apache.org/jira/secure/attachment/12364527/LUCENE-847.take3.patch">LUCENE-847.take3.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-08-24T16:38:20.896Z">24/Aug/07 16:38</time>
                   </dd>
                   <dd class="attachment-size">
                    75 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12364638" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12364638/LUCENE-847.take4.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take4.patch:https://issues.apache.org/jira/secure/attachment/12364638/LUCENE-847.take4.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12364638/LUCENE-847.take4.patch" title="Latest  27/Aug/07 21:05 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take4.patch:https://issues.apache.org/jira/secure/attachment/12364638/LUCENE-847.take4.patch">LUCENE-847.take4.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-08-27T21:05:35.495Z">27/Aug/07 21:05</time>
                   </dd>
                   <dd class="attachment-size">
                    89 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12365364" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12365364/LUCENE-847.take5.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take5.patch:https://issues.apache.org/jira/secure/attachment/12365364/LUCENE-847.take5.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12365364/LUCENE-847.take5.patch" title="Latest  07/Sep/07 17:17 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take5.patch:https://issues.apache.org/jira/secure/attachment/12365364/LUCENE-847.take5.patch">LUCENE-847.take5.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-09-07T17:17:01.153Z">07/Sep/07 17:17</time>
                   </dd>
                   <dd class="attachment-size">
                    145 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12365513" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12365513/LUCENE-847.take6.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take6.patch:https://issues.apache.org/jira/secure/attachment/12365513/LUCENE-847.take6.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12365513/LUCENE-847.take6.patch" title="Latest  10/Sep/07 23:20 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take6.patch:https://issues.apache.org/jira/secure/attachment/12365513/LUCENE-847.take6.patch">LUCENE-847.take6.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-09-10T23:20:03.747Z">10/Sep/07 23:20</time>
                   </dd>
                   <dd class="attachment-size">
                    164 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12365650" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12365650/LUCENE-847.take7.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take7.patch:https://issues.apache.org/jira/secure/attachment/12365650/LUCENE-847.take7.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12365650/LUCENE-847.take7.patch" title="Latest  12/Sep/07 17:42 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take7.patch:https://issues.apache.org/jira/secure/attachment/12365650/LUCENE-847.take7.patch">LUCENE-847.take7.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-09-12T17:42:33.304Z">12/Sep/07 17:42</time>
                   </dd>
                   <dd class="attachment-size">
                    172 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12365879" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12365879/LUCENE-847.take8.patch" draggable="true" data-downloadurl="text/plain:LUCENE-847.take8.patch:https://issues.apache.org/jira/secure/attachment/12365879/LUCENE-847.take8.patch"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12365879/LUCENE-847.take8.patch" title="Latest  14/Sep/07 16:19 - Michael McCandless" draggable="true" data-downloadurl="text/plain:LUCENE-847.take8.patch:https://issues.apache.org/jira/secure/attachment/12365879/LUCENE-847.take8.patch">LUCENE-847.take8.patch</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-09-14T16:19:53.770Z">14/Sep/07 16:19</time>
                   </dd>
                   <dd class="attachment-size">
                    173 kB
                   </dd>
                   <dd class="attachment-author">
                    Michael McCandless
                   </dd>
                  </dl></li>
                 <li class="attachment-content js-file-attachment" data-attachment-id="12354112" data-issue-id="12365696" data-attachment-type="file">
                  <div class="attachment-thumb">
                   <a href="/jira/secure/attachment/12354112/LUCENE-847.txt" draggable="true" data-downloadurl="text/plain:LUCENE-847.txt:https://issues.apache.org/jira/secure/attachment/12354112/LUCENE-847.txt"><span class="aui-icon aui-icon-small attachment-icon aui-iconfont-file-txt" title="Text File"></span></a>
                  </div>
                  <dl>
                   <dt class="attachment-title">
                    <a href="/jira/secure/attachment/12354112/LUCENE-847.txt" title="Latest  23/Mar/07 19:24 - Steven Parkes" draggable="true" data-downloadurl="text/plain:LUCENE-847.txt:https://issues.apache.org/jira/secure/attachment/12354112/LUCENE-847.txt">LUCENE-847.txt</a>
                   </dt>
                   <dd class="attachment-delete">
                    <span class="icon"></span>
                   </dd>
                   <dd class="attachment-date">
                    <time class="livestamp" datetime="2007-03-23T19:24:21.859Z">23/Mar/07 19:24</time>
                   </dd>
                   <dd class="attachment-size">
                    117 kB
                   </dd>
                   <dd class="attachment-author">
                    Steven Parkes
                   </dd>
                  </dl></li>
                </ol>
               </div>
              </div>
              <div id="linkingmodule" class="module toggle-wrap">
               <div id="linkingmodule_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Issue Links</h2>
               </div>
               <div class="mod-content"> 
                <div class="links-container" data-default-link-icon="/jira/images/icons/generic_link_16.png"> 
                 <dl class="links-list "> 
                  <dt title="blocks">
                   blocks
                  </dt> 
                  <dd id="internal-12365610_10032"> 
                   <div class="link-content"> 
                    <p> <img src="/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype" width="16" height="16" title="Bug - A problem which impairs or prevents the functions of the product." alt="Bug - A problem which impairs or prevents the functions of the product."> <span title="LUCENE-845: If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge"> <a href="/jira/browse/LUCENE-845" data-issue-key="LUCENE-845" class="issue-link link-title resolution">LUCENE-845</a> <span class="link-summary">If you "flush by RAM usage" then IndexWriter may over-merge</span> </span> </p> 
                    <ul class="link-snapshot"> 
                     <li class="priority"> <img src="/jira/images/icons/priorities/minor.svg" width="16" height="16" title="Minor - Minor loss of function, or other problem where easy workaround is present." alt="Minor - Minor loss of function, or other problem where easy workaround is present."> </li> 
                     <li class="status"> <span class=" jira-issue-status-lozenge aui-lozenge jira-issue-status-lozenge-green jira-issue-status-lozenge-done aui-lozenge-subtle jira-issue-status-lozenge-max-width-short" data-tooltip="<span class=&quot;jira-issue-status-tooltip-title&quot;>Closed</span><br><span class=&quot;jira-issue-status-tooltip-desc&quot;>The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.</span>">Closed</span> </li> 
                    </ul> 
                   </div> 
                  </dd> 
                 </dl> 
                 <dl class="links-list "> 
                  <dt title="is depended upon by">
                   is depended upon by
                  </dt> 
                  <dd id="internal-12368221_10001"> 
                   <div class="link-content"> 
                    <p> <img src="/jira/secure/viewavatar?size=xsmall&amp;avatarId=21141&amp;avatarType=issuetype" width="16" height="16" title="New Feature - A new feature of the product, which has yet to be developed." alt="New Feature - A new feature of the product, which has yet to be developed."> <span title="LUCENE-870: add concurrent merge policy"> <a href="/jira/browse/LUCENE-870" data-issue-key="LUCENE-870" class="issue-link link-title resolution">LUCENE-870</a> <span class="link-summary">add concurrent merge policy</span> </span> </p> 
                    <ul class="link-snapshot"> 
                     <li class="priority"> <img src="/jira/images/icons/priorities/major.svg" width="16" height="16" title="Major - Major loss of function." alt="Major - Major loss of function."> </li> 
                     <li class="status"> <span class=" jira-issue-status-lozenge aui-lozenge jira-issue-status-lozenge-green jira-issue-status-lozenge-done aui-lozenge-subtle jira-issue-status-lozenge-max-width-short" data-tooltip="<span class=&quot;jira-issue-status-tooltip-title&quot;>Closed</span><br><span class=&quot;jira-issue-status-tooltip-desc&quot;>The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.</span>">Closed</span> </li> 
                    </ul> 
                   </div> 
                  </dd> 
                 </dl> 
                </div> 
               </div>
              </div>
              <div id="activitymodule" class="module toggle-wrap">
               <div id="activitymodule_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Activity</h2>
               </div>
               <div class="mod-content"> 
                <big-pipe data-id="activity-panel-pipe-id" style="height: 70px"> 
                 <div></div> 
                </big-pipe> 
               </div>
              </div>
             </div>
             <div id="viewissuesidebar" class="aui-item issue-side-column">
              <div id="peoplemodule" class="module toggle-wrap">
               <div id="peoplemodule_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">People</h2>
               </div>
               <div class="mod-content"> 
                <ul class="item-details" id="peopledetails"> 
                 <li class="people-details"> 
                  <dl> 
                   <dt>
                    Assignee:
                   </dt> 
                   <dd> 
                    <span id="assignee-val" class="view-issue-field"> <span class="user-hover" id="issue_summary_assignee_steven_parkes" rel="steven_parkes" data-user="{&quot;avatarUrl&quot;:&quot;https://issues.apache.org/jira/secure/useravatar?size=xsmall&amp;avatarId=10452&quot;,&quot;displayName&quot;:&quot;Steven Parkes&quot;,&quot;emailAddress&quot;:&quot;steven_parkes@esseff.org&quot;,&quot;username&quot;:&quot;steven_parkes&quot;}"> <span class="aui-avatar aui-avatar-small"><span class="aui-avatar-inner"><img src="https://issues.apache.org/jira/secure/useravatar?size=small&amp;avatarId=10452" alt="steven_parkes"></span></span> Steven Parkes </span> </span> 
                   </dd> 
                  </dl> 
                  <dl> 
                   <dt>
                    Reporter:
                   </dt> 
                   <dd> 
                    <span id="reporter-val" class="view-issue-field"> <span class="user-hover" id="issue_summary_reporter_steven_parkes" rel="steven_parkes" data-user="{&quot;avatarUrl&quot;:&quot;https://issues.apache.org/jira/secure/useravatar?size=xsmall&amp;avatarId=10452&quot;,&quot;displayName&quot;:&quot;Steven Parkes&quot;,&quot;emailAddress&quot;:&quot;steven_parkes@esseff.org&quot;,&quot;username&quot;:&quot;steven_parkes&quot;}"> <span class="aui-avatar aui-avatar-small"><span class="aui-avatar-inner"><img src="https://issues.apache.org/jira/secure/useravatar?size=small&amp;avatarId=10452" alt="steven_parkes"></span></span> Steven Parkes </span> </span> 
                   </dd> 
                  </dl> </li> 
                </ul> 
                <ul class="item-details"> 
                 <li> 
                  <dl> 
                   <dt>
                    Votes:
                   </dt> 
                   <dd> 
                    <span id="vote-data" class="aui-badge vote-state-off">0</span> 
                    <span id="vote-label" title="You have to be logged in to vote for an issue.">Vote for this issue</span> 
                   </dd> 
                  </dl> 
                  <dl> 
                   <dt>
                    Watchers:
                   </dt> 
                   <dd> 
                    <span id="watcher-data" class="aui-badge watch-state-off">3</span> 
                    <span id="watch-label" title="You have to be logged in to watch an issue.">Start watching this issue</span> 
                   </dd> 
                  </dl> </li> 
                </ul> 
               </div>
              </div>
              <div id="datesmodule" class="module toggle-wrap">
               <div id="datesmodule_heading" class="mod-header">
                <ul class="ops"></ul>
                <h2 class="toggle-title">Dates</h2>
               </div>
               <div class="mod-content"> 
                <ul class="item-details"> 
                 <li> 
                  <dl class="dates"> 
                   <dt>
                    Created:
                   </dt> 
                   <dd class="date user-tz" title="23/Mar/07 19:15"> 
                    <span data-name="Created" id="created-val" data-fieldtype="datetime"> <time class="livestamp" datetime="2007-03-23T19:15:20+0000">23/Mar/07 19:15</time> </span> 
                   </dd> 
                  </dl> 
                  <dl class="dates"> 
                   <dt>
                    Updated:
                   </dt> 
                   <dd class="date user-tz" title="02/May/13 02:29"> 
                    <span data-name="Updated" id="updated-val" data-fieldtype="datetime"> <time class="livestamp" datetime="2013-05-02T02:29:06+0000">02/May/13 02:29</time> </span> 
                   </dd> 
                  </dl> 
                  <dl class="dates"> 
                   <dt>
                    Resolved:
                   </dt> 
                   <dd class="date user-tz" title="18/Sep/07 09:40"> 
                    <span data-name="Resolved" id="resolutiondate-val" data-fieldtype="datetime"> <time class="livestamp" datetime="2007-09-18T09:40:39+0000">18/Sep/07 09:40</time> </span> 
                   </dd> 
                  </dl> </li> 
                </ul> 
               </div>
              </div>
             </div>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
     </div>
     <!-- .aui-page-panel-inner -->
    </div>
    <!-- .aui-page-panel -->
    <div class="issue-navigator-init"></div> 
   </section> 
   <footer id="footer" role="contentinfo"> 
    <section class="footer-body"> 
     <ul class="atlassian-footer"> 
      <li> Atlassian JIRA <a class="seo-link" rel="nofollow" href="https://www.atlassian.com/software/jira">Project Management Software</a> <span id="footer-build-information">(v7.6.3#76005-<span title="8a4e38d34af948780dbf52044e7aafb13a7cae58" data-commit-id="8a4e38d34af948780dbf52044e7aafb13a7cae58}">sha1:8a4e38d</span>)</span> </li> 
      <li> <a id="about-link" rel="nofollow" href="/jira/secure/AboutPage.jspa/secure/AboutPage.jspa">About JIRA</a> </li> 
      <li> <a id="footer-report-problem-link" rel="nofollow" href="/jira/secure/CreateIssue!default.jspa">Report a problem</a> </li> 
     </ul> 
     <ul class="atlassian-footer"> 
      <li class="licensemessage"> Powered by a free Atlassian <a rel="nofollow" href="http://www.atlassian.com/software/jira">JIRA</a> open source license for n/a, Apache Software Foundation. Try JIRA - <a rel="nofollow" href="http://www.atlassian.com/software/jira">bug tracking software</a> for <i>your</i> team. </li> 
     </ul> 
     <div id="footer-logo">
      <a rel="nofollow" href="http://www.atlassian.com/">Atlassian</a>
     </div> 
    </section> 
    <fieldset class="hidden parameters"> 
     <input type="hidden" title="loggedInUser" value=""> 
     <input type="hidden" title="ajaxTimeout" value="The call to the JIRA server did not complete within the timeout period.  We are unsure of the result of this operation."> 
     <input type="hidden" title="JiraVersion" value="7.6.3"> 
     <input type="hidden" title="ajaxUnauthorised" value="You are not authorised to perform this operation. Please log in."> 
     <input type="hidden" title="baseURL" value="https://issues.apache.org/jira"> 
     <input type="hidden" title="ajaxCommsError" value="The JIRA server could not be contacted. This may be a temporary glitch or the server may be down. "> 
     <input type="hidden" title="ajaxServerError" value="The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation."> 
     <input type="hidden" title="ajaxErrorCloseDialog" value="Close this dialog and press refresh in your browser"> 
     <input type="hidden" title="ajaxErrorDialogHeading" value="Communications Breakdown"> 
     <input type="hidden" title="dirtyMessage" value="You have entered new data on this page. If you navigate away from this page without first saving your data, the changes will be lost."> 
     <input type="hidden" title="dirtyDialogMessage" value="You have entered new data in this dialog. If you navigate away from this dialog without first saving your data, the changes will be lost. Click cancel to return to the dialog."> 
     <input type="hidden" title="keyType" value="Type"> 
     <input type="hidden" title="keyThen" value="then"> 
     <input type="hidden" title="dblClickToExpand" value="Double click to expand"> 
     <input type="hidden" title="actions" value="Actions"> 
     <input type="hidden" title="removeItem" value="Remove"> 
     <input type="hidden" title="workflow" value="Workflow"> 
     <input type="hidden" title="labelNew" value="New Label"> 
     <input type="hidden" title="issueActionsHint" value="Begin typing for available operations or press down to see all"> 
     <input type="hidden" title="closelink" value="Close"> 
     <input type="hidden" title="dotOperations" value="Operations"> 
     <input type="hidden" title="dotLoading" value="Loading..."> 
     <input type="hidden" title="frotherSuggestions" value="Suggestions"> 
     <input type="hidden" title="frotherNomatches" value="No Matches"> 
     <input type="hidden" title="multiselectVersionsError" value="{0} is not a valid version."> 
     <input type="hidden" title="multiselectComponentsError" value="{0} is not a valid component."> 
     <input type="hidden" title="multiselectGenericError" value="The value {0} is invalid."> 
    </fieldset> 
   </footer> 
  </div> 
  <script type="text/javascript" src="/jira/s/d41d8cd98f00b204e9800998ecf8427e-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1.0/_/download/batch/jira.webresources:bigpipe-js/jira.webresources:bigpipe-js.js" data-wrm-key="jira.webresources:bigpipe-js" data-wrm-batch-type="resource" data-initially-rendered></script> 
  <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["activity-panel-pipe-id"]="\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    \u003cdiv class=\\\"tabwrap tabs2\\\"\u003e\\n\\n        \u003cul id=\\\"issue-tabs\\\" class=\\\"tabs horizontal\\\"\u003e\\n                                \\n            \u003cli  data-id=\\\"all-tabpanel\\\" data-key=\\\"com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel\\\" data-label=\\\"All\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel\\\"\u003e\\n                            \u003ca class=\\\"ajax-activity-content\\\" id=\\\"all-tabpanel\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel\\\"\u003e\u003cstrong\u003eAll\u003c\\/strong\u003e\u003c\\/a\u003e\\n                        \u003c\\/li\u003e\\n                                \\n            \u003cli  class=\\\"active\\\" id=\\\"comment-tabpanel\\\"  data-id=\\\"comment-tabpanel\\\" data-key=\\\"com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel\\\" data-label=\\\"Comments\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel\\\"\u003e\\n                            \u003cstrong tabindex=\\\"0\\\"\u003eComments\u003c\\/strong\u003e\\n                        \u003c\\/li\u003e\\n                                \\n            \u003cli  data-id=\\\"worklog-tabpanel\\\" data-key=\\\"com.atlassian.jira.plugin.system.issuetabpanels:worklog-tabpanel\\\" data-label=\\\"Work Log\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:worklog-tabpanel\\\"\u003e\\n                            \u003ca class=\\\"ajax-activity-content\\\" id=\\\"worklog-tabpanel\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:worklog-tabpanel\\\"\u003e\u003cstrong\u003eWork Log\u003c\\/strong\u003e\u003c\\/a\u003e\\n                        \u003c\\/li\u003e\\n                                \\n            \u003cli  data-id=\\\"changehistory-tabpanel\\\" data-key=\\\"com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel\\\" data-label=\\\"History\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel\\\"\u003e\\n                            \u003ca class=\\\"ajax-activity-content\\\" id=\\\"changehistory-tabpanel\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel\\\"\u003e\u003cstrong\u003eHistory\u003c\\/strong\u003e\u003c\\/a\u003e\\n                        \u003c\\/li\u003e\\n                                \\n            \u003cli  data-id=\\\"activity-stream-issue-tab\\\" data-key=\\\"com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab\\\" data-label=\\\"Activity\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab\\\"\u003e\\n                            \u003ca class=\\\"ajax-activity-content\\\" id=\\\"activity-stream-issue-tab\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab\\\"\u003e\u003cstrong\u003eActivity\u003c\\/strong\u003e\u003c\\/a\u003e\\n                        \u003c\\/li\u003e\\n                                \\n            \u003cli  data-id=\\\"transitions-summary-tabpanel\\\" data-key=\\\"com.googlecode.jira-suite-utilities:transitions-summary-tabpanel\\\" data-label=\\\"Transitions\\\" data-href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.googlecode.jira-suite-utilities:transitions-summary-tabpanel\\\"\u003e\\n                            \u003ca class=\\\"ajax-activity-content\\\" id=\\\"transitions-summary-tabpanel\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?page=com.googlecode.jira-suite-utilities:transitions-summary-tabpanel\\\"\u003e\u003cstrong\u003eTransitions\u003c\\/strong\u003e\u003c\\/a\u003e\\n                        \u003c\\/li\u003e\\n                \u003c\\/ul\u003e\\n\\n                    \u003cdiv class=\\\"sortwrap\\\"\u003e\\n                                    \u003ca class=\\\"issue-activity-sort-link ajax-activity-content\\\" rel=\\\"nofollow\\\" data-tab-sort data-order=\\\"desc\\\" href=\\\"\\/jira\\/browse\\/LUCENE-847?actionOrder=desc\\\" title=\\\"Ascending order - Click to sort in descending order\\\"\u003e\\n                        \u003cspan class=\\\"aui-icon aui-icon-small aui-iconfont-up\\\"\u003eAscending order - Click to sort in descending order\u003c\\/span\u003e\\n                    \u003c\\/a\u003e\\n                            \u003c\\/div\u003e\\n            \u003c\\/div\u003e\\n    \u003cdiv class=\\\"issuePanelWrapper\\\"\u003e\\n        \u003cdiv class=\\\"issuePanelProgress\\\"\u003e\u003c\\/div\u003e\\n        \u003cdiv class=\\\"issuePanelContainer\\\" id=\\\"issue_actions_container\\\"\u003e\\n                                    \\n\\n\\n\u003cdiv id=\\\"comment-12483719\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483719&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483719\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12483719_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483719_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 19:24\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T19:24:21+0000\'\u003e23\\/Mar\\/07 19:24\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHere\'s a first cut at a factored merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt\'s not polished. Sparsely commented and there are probably a few changes that should be backed out.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt factors a merge policy interface out of IndexWriter and creates an implementation of the existing merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eActually, it\'s a tweak on the existing merge policy. Currently the merge policy is implemented in ways that assume certain things about the existing list of segments. The factored version doesn\'t make these assumptions. It simplifies the interface but I\'m not yet sure if there are bad side effects. Among other things I want to run performance tests.\u003c\\/p\u003e\\n\\n\u003cp\u003eThere is part of a pass at a concurrent version of the current merge policy. It\'s not complete. I\'ve been pushing it to see if I understand the issues around concurrent merges. Interesting topics are 1) how to control the merges 2) how\\/when to cascade merges if they are happening in a parallel and 3) how to handle synchronization of IndexWriter#segmentInfos. That last one in particular is a bit touchy.\u003c\\/p\u003e\\n\\n\u003cp\u003eI did a quick implementation of KS\'s fib merge policy but it\'s incomplete in that IndexWriter won\'t merge non-contiguous segment lists, but I think I can fix that fairly easily with no major side effects. The factored merge policy makes this plug in pretty clean ...\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12483719_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483719_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 19:24\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T19:24:21+0000\'\u003e23\\/Mar\\/07 19:24\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Here\'s a first cut at a factored merge policy. \\n\\n It\'s not polished. Sparsely commented and there are probably a few changes that should be backed out. \\n\\n It factors a merge policy interface out of IndexWriter and creates an implementation of the existing merge policy. \\n\\n Actually, it\'s a tweak on the existing merge policy. Currently the merge policy is implemented in ways that assume certain things about the existing list of segments. The factored version doesn\'t make these assumptions. It simplifies the interface but I\'m not yet sure if there are bad side effects. Among other things I want to run performance tests. \\n\\n There is part of a pass at a concurrent version of the current merge policy. It\'s not complete. I\'ve been pushing it to see if I understand the issues around concurrent merges. Interesting topics are 1) how to control the merges 2) how\\/when to cascade merges if they are happening in a parallel and 3) how to handle synchronization of IndexWriter#segmentInfos. That last one in particular is a bit touchy. \\n\\n I did a quick implementation of KS\'s fib merge policy but it\'s incomplete in that IndexWriter won\'t merge non-contiguous segment lists, but I think I can fix that fairly easily with no major side effects. The factored merge policy makes this plug in pretty clean ...              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12483737\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483737&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483737\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"cutting\\\" id=\\\"commentauthor_12483737_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=cutting\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"cutting\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Doug Cutting\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483737_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 20:25\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T20:25:51+0000\'\u003e23\\/Mar\\/07 20:25\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHow public should such an API be?  Should the interface be public?  Should the implementations?  The most conservative approach would be to make it all package private, to give more leeway for evolving the update API.  But that also decreases the utility.  Thoughts?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"cutting\\\" id=\\\"commentauthor_12483737_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=cutting\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"cutting\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Doug Cutting\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483737_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 20:25\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T20:25:51+0000\'\u003e23\\/Mar\\/07 20:25\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    How public should such an API be?  Should the interface be public?  Should the implementations?  The most conservative approach would be to make it all package private, to give more leeway for evolving the update API.  But that also decreases the utility.  Thoughts?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12483742\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483742&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483742\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12483742_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483742_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 20:45\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T20:45:01+0000\'\u003e23\\/Mar\\/07 20:45\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eVisibility is one of those things I haven\'t cleaned up yet.\u003c\\/p\u003e\\n\\n\u003cp\u003eClient code is gonna want to create and set merge policies. And it\'ll want to set \\\"external\\\" merge policy parameters. That\'s all probably not controversial.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs for other stuff, I tend to leave things open, but I know that\'s debatable and don\'t have a strong opinion in this case.\u003c\\/p\u003e\\n\\n\u003cp\u003eIn fact, there a few things here that are fairly subtle\\/important. The relationship\\/protocol between the writer and policy is pretty strong. This can be seen in the strawman concurrent merge code where the merge policy holds state and relies on being called from a synchronized writer method.   If that goes forward anything like it is, it would argue for tightening that api up some. Chris suggested a way to make the writer&lt;&gt;polcy relationship \\\"atomic\\\". I didn\'t add the code (yet) but I\'m not against it.\u003c\\/p\u003e\\n\\n\\n\\n\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12483742_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483742_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'23\\/Mar\\/07 20:45\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-23T20:45:01+0000\'\u003e23\\/Mar\\/07 20:45\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Visibility is one of those things I haven\'t cleaned up yet. \\n\\n Client code is gonna want to create and set merge policies. And it\'ll want to set \\\"external\\\" merge policy parameters. That\'s all probably not controversial. \\n\\n As for other stuff, I tend to leave things open, but I know that\'s debatable and don\'t have a strong opinion in this case. \\n\\n In fact, there a few things here that are fairly subtle\\/important. The relationship\\/protocol between the writer and policy is pretty strong. This can be seen in the strawman concurrent merge code where the merge policy holds state and relies on being called from a synchronized writer method.   If that goes forward anything like it is, it would argue for tightening that api up some. Chris suggested a way to make the writer&lt;&gt;polcy relationship \\\"atomic\\\". I didn\'t add the code (yet) but I\'m not against it. \\n\\n\\n\\n\\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12483929\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483929&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483929\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483929_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483929_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:46\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:46:09+0000\'\u003e25\\/Mar\\/07 12:46\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eSteven, I looked through the patch quickly.  It looks great!  First\u003cbr\\/\u003e\\nsome general comments and then I\'ll add more specifics as\u003cbr\\/\u003e\\nseparate comments.\u003c\\/p\u003e\\n\\n\u003cp\u003eCan you open separate issues for the other new and interesting merge\u003cbr\\/\u003e\\npolicies here?  I think the refactoring of merge policy plus creation\u003cbr\\/\u003e\\nof the default policy that is identical to today\'s merge policy, which\u003cbr\\/\u003e\\nshould be a fairly quick and low-risk operation, would then remain\u003cbr\\/\u003e\\nunder this issue?\u003c\\/p\u003e\\n\\n\u003cp\u003eThen, iterating \\/ vetting \\/ debugging the new interesting merge\u003cbr\\/\u003e\\npolicies can take longer under their own separate issues and time\u003cbr\\/\u003e\\nframe.\u003c\\/p\u003e\\n\\n\u003cp\u003eOn staging I think we could first do this issue (decouple MergePolicy\u003cbr\\/\u003e\\nfrom writer), then \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e because it blocks \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e (which\u003cbr\\/\u003e\\nwould then be fixing LogarithmicMergePolicy to use segment sizes\u003cbr\\/\u003e\\ninstead of docs counts as basis for determing levels) then \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e\u003cbr\\/\u003e\\n(performance improvements for how writer uses RAM)?\u003c\\/p\u003e\\n\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483929_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483929_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:46\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:46:09+0000\'\u003e25\\/Mar\\/07 12:46\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Steven, I looked through the patch quickly.  It looks great!  First \\nsome general comments and then I\'ll add more specifics as \\nseparate comments. \\n\\n Can you open separate issues for the other new and interesting merge \\npolicies here?  I think the refactoring of merge policy plus creation \\nof the default policy that is identical to today\'s merge policy, which \\nshould be a fairly quick and low-risk operation, would then remain \\nunder this issue? \\n\\n Then, iterating \\/ vetting \\/ debugging the new interesting merge \\npolicies can take longer under their own separate issues and time \\nframe. \\n\\n On staging I think we could first do this issue (decouple MergePolicy \\nfrom writer), then   LUCENE-845   because it blocks   LUCENE-843   (which \\nwould then be fixing LogarithmicMergePolicy to use segment sizes \\ninstead of docs counts as basis for determing levels) then   LUCENE-843   \\n(performance improvements for how writer uses RAM)? \\n\\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12483930\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483930&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483930\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483930_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483930_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:46\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:46:33+0000\'\u003e25\\/Mar\\/07 12:46\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eMy first comment, which I fear will be the most controversial feedback\u003cbr\\/\u003e\\nhere \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e, is a whitespace style question: I\'m not really a fan of\u003cbr\\/\u003e\\n\\\"cancerous whitespace\\\" where every ( [ etc has its own whitespace\u003cbr\\/\u003e\\naround it.\u003c\\/p\u003e\\n\\n\u003cp\u003eI generally prefer minimal whitespace within reason (ie as long as it\u003cbr\\/\u003e\\ndoes not heavily hurt readability).  The thing is I don\'t know that\u003cbr\\/\u003e\\nLucene has settled on this \\/ if anyone else shares my opinion?  It\u003cbr\\/\u003e\\ndoes seem that \\\"two space indentation\\\" is the standard, which I agree\u003cbr\\/\u003e\\nwith, but I don\'t know if whitespace style has otherwise been agreed\u003cbr\\/\u003e\\non?  Many people will say it\'s unimportant to agree on whitespace but\u003cbr\\/\u003e\\nI feel it\'s actually quite important.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483930_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483930_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:46\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:46:33+0000\'\u003e25\\/Mar\\/07 12:46\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    My first comment, which I fear will be the most controversial feedback \\nhere  , is a whitespace style question: I\'m not really a fan of \\n\\\"cancerous whitespace\\\" where every ( [ etc has its own whitespace \\naround it. \\n\\n I generally prefer minimal whitespace within reason (ie as long as it \\ndoes not heavily hurt readability).  The thing is I don\'t know that \\nLucene has settled on this \\/ if anyone else shares my opinion?  It \\ndoes seem that \\\"two space indentation\\\" is the standard, which I agree \\nwith, but I don\'t know if whitespace style has otherwise been agreed \\non?  Many people will say it\'s unimportant to agree on whitespace but \\nI feel it\'s actually quite important.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12483931\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12483931&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12483931\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483931_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483931_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:47:27+0000\'\u003e25\\/Mar\\/07 12:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOK some specific comments, only on the refactoring (ie I haven\'t\u003cbr\\/\u003e\\nreally looked at the new merge policies yet):\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eI think maxBufferedDocs should not be exposed in any *MergePolicy\u003cbr\\/\u003e\\n    classes or interfaces?  I\'m planning on deprecating this param\u003cbr\\/\u003e\\n    with \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e when we switch by default to \\\"buffering by RAM\u003cbr\\/\u003e\\n    usage\\\" and it really relates to \\\"how\\/when should writer flush its\u003cbr\\/\u003e\\n    RAM buffer\\\".\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eI also think \\\"minMergeDocs\\\" (which today is one and the same as\u003cbr\\/\u003e\\n    maxBufferedDocs in IndexWriter but conceptually could be a\u003cbr\\/\u003e\\n    different configuration) also should not appear in the MergePolicy\u003cbr\\/\u003e\\n    interface.  I think it should only appear in\u003cbr\\/\u003e\\n    LogarithmicMergePolicy?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    If we remove these from the MergePolicy interface then maybe we\u003cbr\\/\u003e\\n    don\'t need MergePolicyBase?  (Just to makes things simpler).\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eI think we should not create a LegacyMergePolicy interface.  But I\u003cbr\\/\u003e\\n    realize you need this so the deprecated methods in IndexWriter\u003cbr\\/\u003e\\n    (setMergeFactor, setMaxBufferedDocs, setMaxMergeDocs, etc.) can be\u003cbr\\/\u003e\\n    implemented.  How about instead these methods will only work if\u003cbr\\/\u003e\\n    the current merge policy is the LogarithmicMergePolicy?  You can\u003cbr\\/\u003e\\n    check if the current mergePolicy is an instanceof\u003cbr\\/\u003e\\n    LogarithmicMergePolicy and then throw eg an IllegalStateException\u003cbr\\/\u003e\\n    if it\'s not?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    Ie, going forward, with new and interesting merge policies,\u003cbr\\/\u003e\\n    developers should interact with their merge policy to configure\u003cbr\\/\u003e\\n    it.\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eI was a little spooked by this change to TestAddIndexesNoOptimize:\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eassertEquals(2, writer.getSegmentCount());\u003cbr\\/\u003e\\n      +    assertEquals(3, writer.getSegmentCount());\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    I think with just the refactoring, there should not need to be any\u003cbr\\/\u003e\\n    changes to unit tests right?\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eIt\'s interesting that you\'ve pulled \\\"useCompoundFile\\\" into the\u003cbr\\/\u003e\\n    LegacyMergePolicy.  I\'m torn on whether it belongs in MergePolicy\u003cbr\\/\u003e\\n    at all, since this is really a file format issue?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    For example, newly written segments (no longer a \\\"merge\\\" with\u003cbr\\/\u003e\\n    \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e) must also know whether to write in compound file\u003cbr\\/\u003e\\n    format.  If we make interesting file format changes in the future\u003cbr\\/\u003e\\n    that are configurable by the developer we wouldn\'t want to change\u003cbr\\/\u003e\\n    all MergePolicy classes to propogate that.  It feels like using\u003cbr\\/\u003e\\n    compound file or not should remain only in IndexWriter?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12483931_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12483931_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'25\\/Mar\\/07 12:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-25T12:47:27+0000\'\u003e25\\/Mar\\/07 12:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    OK some specific comments, only on the refactoring (ie I haven\'t \\nreally looked at the new merge policies yet): \\n\\n \\n\\t I think maxBufferedDocs should not be exposed in any *MergePolicy \\n    classes or interfaces?  I\'m planning on deprecating this param \\n    with   LUCENE-843   when we switch by default to \\\"buffering by RAM \\n    usage\\\" and it really relates to \\\"how\\/when should writer flush its \\n    RAM buffer\\\". \\n \\n\\n\\n \\n\\t I also think \\\"minMergeDocs\\\" (which today is one and the same as \\n    maxBufferedDocs in IndexWriter but conceptually could be a \\n    different configuration) also should not appear in the MergePolicy \\n    interface.  I think it should only appear in \\n    LogarithmicMergePolicy? \\n \\n\\n\\n     If we remove these from the MergePolicy interface then maybe we \\n    don\'t need MergePolicyBase?  (Just to makes things simpler). \\n\\n \\n\\t I think we should not create a LegacyMergePolicy interface.  But I \\n    realize you need this so the deprecated methods in IndexWriter \\n    (setMergeFactor, setMaxBufferedDocs, setMaxMergeDocs, etc.) can be \\n    implemented.  How about instead these methods will only work if \\n    the current merge policy is the LogarithmicMergePolicy?  You can \\n    check if the current mergePolicy is an instanceof \\n    LogarithmicMergePolicy and then throw eg an IllegalStateException \\n    if it\'s not? \\n \\n\\n\\n     Ie, going forward, with new and interesting merge policies, \\n    developers should interact with their merge policy to configure \\n    it. \\n\\n \\n\\t I was a little spooked by this change to TestAddIndexesNoOptimize: \\n \\n\\n\\n \\n\\t assertEquals(2, writer.getSegmentCount()); \\n      +    assertEquals(3, writer.getSegmentCount()); \\n \\n\\n\\n     I think with just the refactoring, there should not need to be any \\n    changes to unit tests right? \\n\\n \\n\\t It\'s interesting that you\'ve pulled \\\"useCompoundFile\\\" into the \\n    LegacyMergePolicy.  I\'m torn on whether it belongs in MergePolicy \\n    at all, since this is really a file format issue? \\n \\n\\n\\n     For example, newly written segments (no longer a \\\"merge\\\" with \\n      LUCENE-843  ) must also know whether to write in compound file \\n    format.  If we make interesting file format changes in the future \\n    that are configurable by the developer we wouldn\'t want to change \\n    all MergePolicy classes to propogate that.  It feels like using \\n    compound file or not should remain only in IndexWriter?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12485054\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12485054&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12485054\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12485054_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12485054_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'29\\/Mar\\/07 03:21\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-29T03:21:07+0000\'\u003e29\\/Mar\\/07 03:21\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHere is a patch for concurrent merge as discussed in:\u003cbr\\/\u003e\\n\u003ca href=\\\"http:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651\\\" class=\\\"external-link\\\" rel=\\\"nofollow\\\"\u003ehttp:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651\u003c\\/a\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003eI put it under this issue because it helps design and verify a factored merge policy which would provide good support for concurrent merge.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs described before, a merge thread is started when a writer is created and stopped when the writer is closed. The merge process consists of three steps: first, create a merge task\\/spec; then, carry out the actual merge; finally, \\\"commit\\\" the merged segment (replace segments it merged in segmentInfos), but only after appropriate deletes are applied. The first and last steps are fast and synchronous. The second step is where concurrency is achieved. Does it make sense to capture them as separate steps in the factored merge policy?\u003c\\/p\u003e\\n\\n\u003cp\u003eAs discussed in \u003ca href=\\\"http:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651:\\\" class=\\\"external-link\\\" rel=\\\"nofollow\\\"\u003ehttp:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651:\u003c\\/a\u003e documents can be buffered while segments are merged, but no more than maxBufferedDocs can be buffered at any time. So this version provides limited concurrency. The main goal is to achieve short ingestion hiccups, especially when the ingestion rate is low. After the factored merge policy, we could provide different versions of concurrent merge policies which provide different levels of concurrency. \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003eAll unit tests pass. If IndexWriter is replaced with IndexWriterConcurrentMerge, all unit tests pass except the following:\u003c\\/p\u003e\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eTestAddIndexesNoOptimize and TestIndexWriter*\u003cbr\\/\u003e\\n    This is because they check segment sizes expecting all merges are done. These tests pass if these checks are performed after the concurrent merges finish. The modified tests (with waits for concurrent merges to finish) are in TestIndexWriterConcurrentMerge*.\u003c\\/li\u003e\\n\\t\u003cli\u003etestExactFieldNames in TestBackwardCompatibility and testDeleteLeftoverFiles in TestIndexFileDeleter\u003cbr\\/\u003e\\n    In both cases, file name segments_a is expected, but the actual is segments_7. This is because with concurrent merge, if compound file is used, only the compound version is \\\"committed\\\" (added to segmentInfos), not the non-compound version, thus the lower segments generation number.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eCheers,\u003cbr\\/\u003e\\nNing\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12485054_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12485054_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'29\\/Mar\\/07 03:21\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-03-29T03:21:07+0000\'\u003e29\\/Mar\\/07 03:21\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Here is a patch for concurrent merge as discussed in: \\n http:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651  \\n\\n I put it under this issue because it helps design and verify a factored merge policy which would provide good support for concurrent merge. \\n\\n As described before, a merge thread is started when a writer is created and stopped when the writer is closed. The merge process consists of three steps: first, create a merge task\\/spec; then, carry out the actual merge; finally, \\\"commit\\\" the merged segment (replace segments it merged in segmentInfos), but only after appropriate deletes are applied. The first and last steps are fast and synchronous. The second step is where concurrency is achieved. Does it make sense to capture them as separate steps in the factored merge policy? \\n\\n As discussed in  http:\\/\\/www.gossamer-threads.com\\/lists\\/lucene\\/java-dev\\/45651?search_string=concurrent%20merge;#45651:  documents can be buffered while segments are merged, but no more than maxBufferedDocs can be buffered at any time. So this version provides limited concurrency. The main goal is to achieve short ingestion hiccups, especially when the ingestion rate is low. After the factored merge policy, we could provide different versions of concurrent merge policies which provide different levels of concurrency.   \\n\\n All unit tests pass. If IndexWriter is replaced with IndexWriterConcurrentMerge, all unit tests pass except the following: \\n \\n\\t TestAddIndexesNoOptimize and TestIndexWriter* \\n    This is because they check segment sizes expecting all merges are done. These tests pass if these checks are performed after the concurrent merges finish. The modified tests (with waits for concurrent merges to finish) are in TestIndexWriterConcurrentMerge*. \\n\\t testExactFieldNames in TestBackwardCompatibility and testDeleteLeftoverFiles in TestIndexFileDeleter \\n    In both cases, file name segments_a is expected, but the actual is segments_7. This is because with concurrent merge, if compound file is used, only the compound version is \\\"committed\\\" (added to segmentInfos), not the non-compound version, thus the lower segments generation number. \\n \\n\\n\\n Cheers, \\nNing              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12490192\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12490192&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12490192\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12490192_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12490192_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'19\\/Apr\\/07 22:41\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-04-19T22:41:58+0000\'\u003e19\\/Apr\\/07 22:41\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHere are some numbers comparing the load performance for the factored vs. non-factored merge policies.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe setup uses enwiki, loads 200K documents, and uses 4 different combinations of maxBufferedDocs and mergeFactor (just the default from the standard benchmark, not because I necessarily thought it was a good idea.)\u003c\\/p\u003e\\n\\n\u003cp\u003eThe factored merge policy seems to be on the order of 1% slower loading than the non-factored version ... and I\'m not sure why, so I\'m going to check into this. The factored version does more examination of segment list than the non-factored version, so there\'s compute overhead, but I would expect that to be swamped by I\\/O Maybe that\'s not a good assumption? Or it might be doing different merges for reasons I haven\'t considered, which I\'m going to check.\u003c\\/p\u003e\\n\\n\u003cp\u003eRelating this to some of the merge discussions, I\'m going to look at monitoring both the number of merges taking place and the size of those merges. I think that\'s helpful in understand different candidate merge policies, in addition to absolute difference in runtime.\u003c\\/p\u003e\\n\\n\u003cp\u003eI also think histogramming  the per-doc cost would also be interesting, since mitigating the long delay at cascading merges is at least one goal of a concurrent merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eAnd all this doesn\'t even consider testing the recent stuff on merging multiple indexes. That\'s an area where the factored merge policy differs (because of the simpler interface.)\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m curious if anyone is surprised by these numbers, the 60 docs\\/sec, in particular. This machine is a dual dual-core xeon, writing to a single local disk.  My dual opty achieved ~85-100 docs\\/sec on a three disk SATA3 RAID5 array.\u003c\\/p\u003e\\n\\n\u003cp\u003eNon-factored (current) merge policy\u003c\\/p\u003e\\n\\n\u003cp\u003e     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e ------------&gt; Report sum by Prefix (MAddDocs) and Round (8 about 8 out of 33)\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e Operation       round mrg buf   runCnt   recsPerRun        rec\\/s  elapsedSec    avgUsedMem    avgTotalMem\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     0  10  10        1       200000         41.6    4,804.11    11,758,928     12,591,104\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   1 100  10 -  -   1 -  -  200000 -  -  - 50.0 -  4,000.25 -  34,831,992 -   52,563,968\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     2  10 100        1       200000         49.9    4,004.95    42,158,232     60,444,672\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   3 100 100 -  -   1 -  -  200000 -  -  - 57.9 -  3,455.97 -  45,646,680 -   61,083,648\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     4  10  10        1       200000         44.9    4,458.66    36,928,616     61,083,648\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   5 100  10 -  -   1 -  -  200000 -  -  - 50.4 -  3,965.98 -  47,855,064 -   61,083,648\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     6  10 100        1       200000         49.7    4,023.51    52,506,448     64,217,088\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   7 100 100 -  -   1 -  -  200000 -  -  - 57.9 -  3,451.39 -  64,466,128 -   73,220,096\u003c\\/p\u003e\\n\\n\u003cp\u003eFactored (new) merge policy\u003c\\/p\u003e\\n\\n\u003cp\u003e     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e ------------&gt; Report sum by Prefix (MAddDocs) and Round (8 about 8 out of 33)\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e Operation       round mrg buf   runCnt   recsPerRun        rec\\/s  elapsedSec    avgUsedMem    avgTotalMem\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     0  10  10        1       200000         41.4    4,828.25    10,477,976     12,386,304\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   1 100  10 -  -   1 -  -  200000 -  -  - 50.4 -  3,968.27 -  38,333,544 -   46,170,112\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     2  10 100        1       200000         50.3    3,973.52    33,539,824     63,860,736\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   3 100 100 -  -   1 -  -  200000 -  -  - 58.6 -  3,413.87 -  44,580,528 -   87,781,376\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     4  10  10        1       200000         45.3    4,411.50    57,850,104     87,781,376\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   5 100  10 -  -   1 -  -  200000 -  -  - 51.0 -  3,921.48 -  62,793,432 -   87,781,376\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000     6  10 100        1       200000         50.4    3,969.87    49,625,496     93,966,336\u003cbr\\/\u003e\\n     \u003cspan class=\\\"error\\\"\u003e&#91;java&#93;\u003c\\/span\u003e MAddDocs_200000 -   7 100 100 -  -   1 -  -  200000 -  -  - 58.7 -  3,409.51 -  68,100,288 -  129,572,864\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12490192_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12490192_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'19\\/Apr\\/07 22:41\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-04-19T22:41:58+0000\'\u003e19\\/Apr\\/07 22:41\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Here are some numbers comparing the load performance for the factored vs. non-factored merge policies. \\n\\n The setup uses enwiki, loads 200K documents, and uses 4 different combinations of maxBufferedDocs and mergeFactor (just the default from the standard benchmark, not because I necessarily thought it was a good idea.) \\n\\n The factored merge policy seems to be on the order of 1% slower loading than the non-factored version ... and I\'m not sure why, so I\'m going to check into this. The factored version does more examination of segment list than the non-factored version, so there\'s compute overhead, but I would expect that to be swamped by I\\/O Maybe that\'s not a good assumption? Or it might be doing different merges for reasons I haven\'t considered, which I\'m going to check. \\n\\n Relating this to some of the merge discussions, I\'m going to look at monitoring both the number of merges taking place and the size of those merges. I think that\'s helpful in understand different candidate merge policies, in addition to absolute difference in runtime. \\n\\n I also think histogramming  the per-doc cost would also be interesting, since mitigating the long delay at cascading merges is at least one goal of a concurrent merge policy. \\n\\n And all this doesn\'t even consider testing the recent stuff on merging multiple indexes. That\'s an area where the factored merge policy differs (because of the simpler interface.) \\n\\n I\'m curious if anyone is surprised by these numbers, the 60 docs\\/sec, in particular. This machine is a dual dual-core xeon, writing to a single local disk.  My dual opty achieved ~85-100 docs\\/sec on a three disk SATA3 RAID5 array. \\n\\n Non-factored (current) merge policy \\n\\n       &#91;java&#93;  ------------&gt; Report sum by Prefix (MAddDocs) and Round (8 about 8 out of 33) \\n      &#91;java&#93;  Operation       round mrg buf   runCnt   recsPerRun        rec\\/s  elapsedSec    avgUsedMem    avgTotalMem \\n      &#91;java&#93;  MAddDocs_200000     0  10  10        1       200000         41.6    4,804.11    11,758,928     12,591,104 \\n      &#91;java&#93;  MAddDocs_200000 -   1 100  10 -  -   1 -  -  200000 -  -  - 50.0 -  4,000.25 -  34,831,992 -   52,563,968 \\n      &#91;java&#93;  MAddDocs_200000     2  10 100        1       200000         49.9    4,004.95    42,158,232     60,444,672 \\n      &#91;java&#93;  MAddDocs_200000 -   3 100 100 -  -   1 -  -  200000 -  -  - 57.9 -  3,455.97 -  45,646,680 -   61,083,648 \\n      &#91;java&#93;  MAddDocs_200000     4  10  10        1       200000         44.9    4,458.66    36,928,616     61,083,648 \\n      &#91;java&#93;  MAddDocs_200000 -   5 100  10 -  -   1 -  -  200000 -  -  - 50.4 -  3,965.98 -  47,855,064 -   61,083,648 \\n      &#91;java&#93;  MAddDocs_200000     6  10 100        1       200000         49.7    4,023.51    52,506,448     64,217,088 \\n      &#91;java&#93;  MAddDocs_200000 -   7 100 100 -  -   1 -  -  200000 -  -  - 57.9 -  3,451.39 -  64,466,128 -   73,220,096 \\n\\n Factored (new) merge policy \\n\\n       &#91;java&#93;  ------------&gt; Report sum by Prefix (MAddDocs) and Round (8 about 8 out of 33) \\n      &#91;java&#93;  Operation       round mrg buf   runCnt   recsPerRun        rec\\/s  elapsedSec    avgUsedMem    avgTotalMem \\n      &#91;java&#93;  MAddDocs_200000     0  10  10        1       200000         41.4    4,828.25    10,477,976     12,386,304 \\n      &#91;java&#93;  MAddDocs_200000 -   1 100  10 -  -   1 -  -  200000 -  -  - 50.4 -  3,968.27 -  38,333,544 -   46,170,112 \\n      &#91;java&#93;  MAddDocs_200000     2  10 100        1       200000         50.3    3,973.52    33,539,824     63,860,736 \\n      &#91;java&#93;  MAddDocs_200000 -   3 100 100 -  -   1 -  -  200000 -  -  - 58.6 -  3,413.87 -  44,580,528 -   87,781,376 \\n      &#91;java&#93;  MAddDocs_200000     4  10  10        1       200000         45.3    4,411.50    57,850,104     87,781,376 \\n      &#91;java&#93;  MAddDocs_200000 -   5 100  10 -  -   1 -  -  200000 -  -  - 51.0 -  3,921.48 -  62,793,432 -   87,781,376 \\n      &#91;java&#93;  MAddDocs_200000     6  10 100        1       200000         50.4    3,969.87    49,625,496     93,966,336 \\n      &#91;java&#93;  MAddDocs_200000 -   7 100 100 -  -   1 -  -  200000 -  -  - 58.7 -  3,409.51 -  68,100,288 -  129,572,864              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518006\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518006&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518006\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518006_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518006_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'06\\/Aug\\/07 20:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-06T20:11:28+0000\'\u003e06\\/Aug\\/07 20:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHere\'s an update to the patch. I wouldn\'t say it\'s ready to be committed, but I think it\'s significantly closer than it was.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe concurrent and other misc. stuff have been pulled out (that part still needs work, figuring out how to get the concurrency right.)\u003c\\/p\u003e\\n\\n\u003cp\u003eThe new patch works against trunk, which means it handles docswriter and is more compatible with merging by # of docs or merging by ram (or size, to be more accurate?)\u003c\\/p\u003e\\n\\n\u003cp\u003eMy take on the migration path here was that we could well be going towards merging by size but need to keep merging by # docs for parallel index cases. The current patch still only does merging by # docs.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think I commented on a couple of other things dev, but to reiterate:\u003c\\/p\u003e\\n\\n\u003cp\u003eThere\'s a small change in the test results because the new merge policy simplifies the treatatement of addIndexes operations. The change is understood and shouldn\'t be a problem.\u003c\\/p\u003e\\n\\n\u003cp\u003euseCompoundFile is delegated to the merge policy so a smart merge policy could make decisions looking at the state of all segments rather than all-or-nothing. There are a couple of fixme\'s in IndexWriter related to this and the segments being created by the docswriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m going to look at that, plus the concurrent stuff: Ning\'s stuff plus by old approach (which has to change, given the new docswriter stuff).\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518006_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518006_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'06\\/Aug\\/07 20:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-06T20:11:28+0000\'\u003e06\\/Aug\\/07 20:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Here\'s an update to the patch. I wouldn\'t say it\'s ready to be committed, but I think it\'s significantly closer than it was. \\n\\n The concurrent and other misc. stuff have been pulled out (that part still needs work, figuring out how to get the concurrency right.) \\n\\n The new patch works against trunk, which means it handles docswriter and is more compatible with merging by # of docs or merging by ram (or size, to be more accurate?) \\n\\n My take on the migration path here was that we could well be going towards merging by size but need to keep merging by # docs for parallel index cases. The current patch still only does merging by # docs. \\n\\n I think I commented on a couple of other things dev, but to reiterate: \\n\\n There\'s a small change in the test results because the new merge policy simplifies the treatatement of addIndexes operations. The change is understood and shouldn\'t be a problem. \\n\\n useCompoundFile is delegated to the merge policy so a smart merge policy could make decisions looking at the state of all segments rather than all-or-nothing. There are a couple of fixme\'s in IndexWriter related to this and the segments being created by the docswriter. \\n\\n I\'m going to look at that, plus the concurrent stuff: Ning\'s stuff plus by old approach (which has to change, given the new docswriter stuff).              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518013\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518013&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518013\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518013_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518013_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'06\\/Aug\\/07 20:25\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-06T20:25:56+0000\'\u003e06\\/Aug\\/07 20:25\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eFor the time being, the patch also contains some of the code from \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-971\\\" title=\\\"Create enwiki indexable data as line-per-article rather than file-per-article\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-971\\\"\u003e\u003cdel\u003eLUCENE-971\u003c\\/del\u003e\u003c\\/a\u003e since that\'s how I test it.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518013_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518013_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'06\\/Aug\\/07 20:25\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-06T20:25:56+0000\'\u003e06\\/Aug\\/07 20:25\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    For the time being, the patch also contains some of the code from   LUCENE-971   since that\'s how I test it.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518162\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518162&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518162\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518162_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518162_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 14:40\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T14:40:06+0000\'\u003e07\\/Aug\\/07 14:40\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eThis looks great Steve!\u003c\\/p\u003e\\n\\n\u003cp\u003eMore specific feeedback soon, but ... in thinking about concurrency\u003cbr\\/\u003e\\n(and from reading your comments about it in LogDocMergePolicy), I\u003cbr\\/\u003e\\nthink we ideally would like concurrency to be fully independent of the\u003cbr\\/\u003e\\nmerge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eIe, just like you can take any shell command and choose to run it in\u003cbr\\/\u003e\\nthe background by sticking an \\\"&amp;\\\" on the end, I should be able to take\u003cbr\\/\u003e\\nmy favorite MergePolicy instance X and \\\"wrap\\\" it inside a \\\"concurrent\u003cbr\\/\u003e\\nmerge policy wrapper\\\".  Eg, instantiate ConcurrentMergePolicy(X), and\u003cbr\\/\u003e\\nthen ConcurrentMergePolicy would take the merges requested by X and do\u003cbr\\/\u003e\\nthem in the background.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think with one change to your MergePolicy API &amp; control flow, we\u003cbr\\/\u003e\\ncould make this work very well: instead of requiring the MergePolicy\u003cbr\\/\u003e\\nto call IndexWriter.merge, and do the cascading, it should just return\u003cbr\\/\u003e\\nthe one MergeSpecification that should be done right now.  This would\u003cbr\\/\u003e\\nmean the \\\"MergePolicy.merge\\\" method would return null if no merge is\u003cbr\\/\u003e\\nnecessary right now, and would return a MergeSpecification if a merge\u003cbr\\/\u003e\\nis required.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis way, it is IndexWriter that would execute the merge.  When the\u003cbr\\/\u003e\\nmerge is done, IndexWriter would then call the MergePolicy again to\u003cbr\\/\u003e\\ngive it a chance to \\\"cascade\\\".  This simplifies the locking because\u003cbr\\/\u003e\\nIndexWriter can synchronize on SegmentInfos when it calls\u003cbr\\/\u003e\\n\\\"MergePolicy.merge\\\" and so MergePolicy no longer has to deal with this\u003cbr\\/\u003e\\ncomplexity (that SegmentInfos change during merge).\u003c\\/p\u003e\\n\\n\u003cp\u003eThen, with this change, we could make a ConcurrentMergePolicy that\u003cbr\\/\u003e\\ncould (I think) easily \\\"wrap\\\" itself around another MergePolicy X,\u003cbr\\/\u003e\\nintercepting the calls to \\\"merge\\\".  When the inner MergePolicy wants\u003cbr\\/\u003e\\nto do a merge, the ConcurrentMergePolicy would in turn kick off that\u003cbr\\/\u003e\\nmerge in the BG but then return null to the IndexWriter allowing\u003cbr\\/\u003e\\nIndexWriter to return to its caller, etc.\u003c\\/p\u003e\\n\\n\u003cp\u003eThen, this also simplifies MergePolicy implementations because you no\u003cbr\\/\u003e\\nlonger have to deal w\\/ thread safety issues around driving your own\u003cbr\\/\u003e\\nmerges, cascading merges, dealing with sneaky SegmentInfos changing\u003cbr\\/\u003e\\nwhile doing the merge, etc....\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518162_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518162_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 14:40\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T14:40:06+0000\'\u003e07\\/Aug\\/07 14:40\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    This looks great Steve! \\n\\n More specific feeedback soon, but ... in thinking about concurrency \\n(and from reading your comments about it in LogDocMergePolicy), I \\nthink we ideally would like concurrency to be fully independent of the \\nmerge policy. \\n\\n Ie, just like you can take any shell command and choose to run it in \\nthe background by sticking an \\\"&amp;\\\" on the end, I should be able to take \\nmy favorite MergePolicy instance X and \\\"wrap\\\" it inside a \\\"concurrent \\nmerge policy wrapper\\\".  Eg, instantiate ConcurrentMergePolicy(X), and \\nthen ConcurrentMergePolicy would take the merges requested by X and do \\nthem in the background. \\n\\n I think with one change to your MergePolicy API &amp; control flow, we \\ncould make this work very well: instead of requiring the MergePolicy \\nto call IndexWriter.merge, and do the cascading, it should just return \\nthe one MergeSpecification that should be done right now.  This would \\nmean the \\\"MergePolicy.merge\\\" method would return null if no merge is \\nnecessary right now, and would return a MergeSpecification if a merge \\nis required. \\n\\n This way, it is IndexWriter that would execute the merge.  When the \\nmerge is done, IndexWriter would then call the MergePolicy again to \\ngive it a chance to \\\"cascade\\\".  This simplifies the locking because \\nIndexWriter can synchronize on SegmentInfos when it calls \\n\\\"MergePolicy.merge\\\" and so MergePolicy no longer has to deal with this \\ncomplexity (that SegmentInfos change during merge). \\n\\n Then, with this change, we could make a ConcurrentMergePolicy that \\ncould (I think) easily \\\"wrap\\\" itself around another MergePolicy X, \\nintercepting the calls to \\\"merge\\\".  When the inner MergePolicy wants \\nto do a merge, the ConcurrentMergePolicy would in turn kick off that \\nmerge in the BG but then return null to the IndexWriter allowing \\nIndexWriter to return to its caller, etc. \\n\\n Then, this also simplifies MergePolicy implementations because you no \\nlonger have to deal w\\/ thread safety issues around driving your own \\nmerges, cascading merges, dealing with sneaky SegmentInfos changing \\nwhile doing the merge, etc....              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518165\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518165&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518165\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518165_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518165_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 14:58\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T14:58:35+0000\'\u003e07\\/Aug\\/07 14:58\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tI\u003cbr\\/\u003e\\n\\tthink we ideally would like concurrency to be fully independent of the\u003cbr\\/\u003e\\n\\tmerge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eI thought of that, too, while taking a fresh look at things again. It\'s my current approach, though I\'m not yet sure there won\'t be stumbling blocks. More soon, hopefully.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think with one change to your MergePolicy API &amp; control flow, we\u003cbr\\/\u003e\\n\\tcould make this work very well: instead of requiring the MergePolicy\u003cbr\\/\u003e\\n\\tto call IndexWriter.merge, and do the cascading, it should just return\u003cbr\\/\u003e\\n\\tthe one MergeSpecification that should be done right now.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmm ... interesting idea. I thought about it briefly, though I didn\'t pursue it (see below). It would end up changing the possible space of merge policies subtly. You \\twouldn\'t be able to have any state in the algorithm. Arguably this is a good thing. There is also a bit more overhead, since starting the computation of potential merges from scratch each time could imply a little more computation, but I suspect this is not significant.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWhen the inner MergePolicy wants\u003cbr\\/\u003e\\n\\tto do a merge, the ConcurrentMergePolicy would in turn kick off that\u003cbr\\/\u003e\\n\\tmerge in the BG but then return null to the IndexWriter allowing\u003cbr\\/\u003e\\n\\tIndexWriter to return to its caller, etc.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m a little unsure here. Are you saying the ConcurrentMergePolicy does the merges itself, rather than using the writer? That\'s going to mean a synchronization dance between the CMP and the writer. There\'s no question but that there has to be some synch dance, but my current thinking was to try to keep as cleanly within one class, IW, as I could.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518165_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518165_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 14:58\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T14:58:35+0000\'\u003e07\\/Aug\\/07 14:58\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tI \\n\\tthink we ideally would like concurrency to be fully independent of the \\n\\tmerge policy. \\n\\n I thought of that, too, while taking a fresh look at things again. It\'s my current approach, though I\'m not yet sure there won\'t be stumbling blocks. More soon, hopefully. \\n\\n \\tI think with one change to your MergePolicy API &amp; control flow, we \\n\\tcould make this work very well: instead of requiring the MergePolicy \\n\\tto call IndexWriter.merge, and do the cascading, it should just return \\n\\tthe one MergeSpecification that should be done right now. \\n\\n Hmm ... interesting idea. I thought about it briefly, though I didn\'t pursue it (see below). It would end up changing the possible space of merge policies subtly. You \\twouldn\'t be able to have any state in the algorithm. Arguably this is a good thing. There is also a bit more overhead, since starting the computation of potential merges from scratch each time could imply a little more computation, but I suspect this is not significant. \\n\\n \\tWhen the inner MergePolicy wants \\n\\tto do a merge, the ConcurrentMergePolicy would in turn kick off that \\n\\tmerge in the BG but then return null to the IndexWriter allowing \\n\\tIndexWriter to return to its caller, etc. \\n\\n I\'m a little unsure here. Are you saying the ConcurrentMergePolicy does the merges itself, rather than using the writer? That\'s going to mean a synchronization dance between the CMP and the writer. There\'s no question but that there has to be some synch dance, but my current thinking was to try to keep as cleanly within one class, IW, as I could.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518184\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518184&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518184\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518184_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518184_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 16:34\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T16:34:44+0000\'\u003e07\\/Aug\\/07 16:34\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003eSome more feedback:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIs the separate IndexMerger interface really necessary?  Can\'t we\u003cbr\\/\u003e\\n    just use IndexWriter directly?  It\'s somewhat awkward\\/forced now,\u003cbr\\/\u003e\\n    because the interface has getters for ramBufferSizeMB and\u003cbr\\/\u003e\\n    maxBufferedDocs that are really a \\\"writer\\\" (flushing) thing not a\u003cbr\\/\u003e\\n    \\\"merging\\\" thing.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think,\u003cbr\\/\u003e\\n    instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write\u003cbr\\/\u003e\\n    through\\\" to the LogDocMergePolicy if that is the merge policy in\u003cbr\\/\u003e\\n    use (and LogDocMergePolicy should store its own private\u003cbr\\/\u003e\\n    \\\"minMergeDocs\\\").\u003c\\/p\u003e\\n\\n\u003cp\u003e    I think the three getters may not even be needed (based on\u003cbr\\/\u003e\\n    comments below), in which case it seems like we shouldn\'t be\u003cbr\\/\u003e\\n    creating a new interface.\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIn LogDocMergePolicy, it seems like the checking that\'s done for\u003cbr\\/\u003e\\n    whether a SegmentInfo is in a different directory, as well as the\u003cbr\\/\u003e\\n    subsequent copy to move it over to the IndexWriter\'s directory,\u003cbr\\/\u003e\\n    should not live in the MergePolicy?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    Otherwise, every MergePolicy is going to have to duplicate this\u003cbr\\/\u003e\\n    code.  Not to mention, we may someday create a more efficient way\u003cbr\\/\u003e\\n    to copy than running a single-segment merge (which is a very\u003cbr\\/\u003e\\n    inefficient, but, we only do it in addIndexes* I think).  I\'d like\u003cbr\\/\u003e\\n    to capture this in one place (IndexWriter).\u003c\\/p\u003e\\n\\n\u003cp\u003e    EG, the writer could have its own \\\"copyExternalSegments\\\" method\u003cbr\\/\u003e\\n    which is called in addIndexes* and also optimize(), after the\u003cbr\\/\u003e\\n    merge policy has done its merge, which does the check for wrong\u003cbr\\/\u003e\\n    directory and subsequent copy.\u003c\\/p\u003e\\n\\n\u003cp\u003e    I think this would mean IndexMerger.getDirectory() is not really\u003cbr\\/\u003e\\n    needed.\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eThe \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it\u003cbr\\/\u003e\\n    belongs back in IndexWriter: I think we don\'t want every\u003cbr\\/\u003e\\n    MergePolicy having to replicate that tricky while condition.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e    Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\"\u003cbr\\/\u003e\\n    which, if true, means that the MergePolicy must now pick a merge\u003cbr\\/\u003e\\n    even if it didn\'t think it was time to.  This would let us move\u003cbr\\/\u003e\\n    that tricky while condition logic back into IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e    Also, I think at some point we may want to have an optimize()\u003cbr\\/\u003e\\n    method that takes an int parameter stating the max # segments in\u003cbr\\/\u003e\\n    the resulting index.  This would allow you to optimize down to &lt;=\u003cbr\\/\u003e\\n    N segments w\\/o paying full cost of a complete \\\"only one segment\\\"\u003cbr\\/\u003e\\n    optimize.  If we had a \\\"forced\\\" boolean then we could build such\u003cbr\\/\u003e\\n    an optimize method in the future, whereas as it stands now it\u003cbr\\/\u003e\\n    would not be so easy to retrofit previously created MergePolicy\u003cbr\\/\u003e\\n    classes to do this.\u003c\\/p\u003e\\n\\n\u003cp\u003eAnd some more minor feedback:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eI love the simplification of addIndexesNoOptimize \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  Though (same\u003cbr\\/\u003e\\n    comment as above) I think we should move that final \\\"copy if\u003cbr\\/\u003e\\n    different directory\\\" step back in IndexWriter.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eThere are some minor things that should not be committed eg the\u003cbr\\/\u003e\\n    added \\\"infoStream = null\\\" in IndexFileDeleter.  I typically try to\u003cbr\\/\u003e\\n    put a comment \\\"\\/\\/ nocommit\\\" above such changes as I make them to\u003cbr\\/\u003e\\n    remind myself and keep them from slipping in.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIn the deprecated IndexWriter methods you\'re doing a hard cast to\u003cbr\\/\u003e\\n    LogDocMergePolicy which gives a bad result if you\'re using a\u003cbr\\/\u003e\\n    different merge policy; maybe catch the class cast exception (or,\u003cbr\\/\u003e\\n    better, check upfront if it\'s an instanceof) and raise a more\u003cbr\\/\u003e\\n    reasonable exception if not?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIndexWriter around line 1908 has for loop that has commented out\u003cbr\\/\u003e\\n    \\\"System.err.println\\\"; we should just comment out\\/remove for loop\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eThese commented out synchronized spook me a bit:\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003e      \\/* synchronized(segmentInfos) *\\/ {\u003c\\/p\u003e\\n\\n\u003cp\u003e    Are they needed in these contexts?  Is this only once we have\u003cbr\\/\u003e\\n    concurrent merging?  (This ties back to the first feedback to\u003cbr\\/\u003e\\n    simplify MergePolicy API so that this kind of locking is only\u003cbr\\/\u003e\\n    needed inside IndexWriter).\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eCan we support non-contiguous merges?  If I understand it\u003cbr\\/\u003e\\n    correctly, the MergeSpecification can express such a merge, it\'s\u003cbr\\/\u003e\\n    just that the current IndexMerger (IndexWriter) cannot execute it,\u003cbr\\/\u003e\\n    right?  So we are at least not precluding fixing this in the\u003cbr\\/\u003e\\n    future.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIt confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can\u003cbr\\/\u003e\\n    we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"?  Ie,\u003cbr\\/\u003e\\n    this method determines whether a merge is necessary and, if so, it\u003cbr\\/\u003e\\n    then asks IndexMerger to in fact execute the merge (or, returns\u003cbr\\/\u003e\\n    the spec)?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eInstead of IndexWriter.releaseMergePolicy() can we have\u003cbr\\/\u003e\\n    IndexWriter only close the merge policy if it was the one that had\u003cbr\\/\u003e\\n    created it?  (Similar to how IndexWriter closes the dir if it has\u003cbr\\/\u003e\\n    opened it from a String or File, but does not close it if it was\u003cbr\\/\u003e\\n    passed in).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518184_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518184_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 16:34\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T16:34:44+0000\'\u003e07\\/Aug\\/07 16:34\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n Some more feedback: \\n\\n \\n\\t Is the separate IndexMerger interface really necessary?  Can\'t we \\n    just use IndexWriter directly?  It\'s somewhat awkward\\/forced now, \\n    because the interface has getters for ramBufferSizeMB and \\n    maxBufferedDocs that are really a \\\"writer\\\" (flushing) thing not a \\n    \\\"merging\\\" thing. \\n \\n\\n\\n     While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think, \\n    instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write \\n    through\\\" to the LogDocMergePolicy if that is the merge policy in \\n    use (and LogDocMergePolicy should store its own private \\n    \\\"minMergeDocs\\\"). \\n\\n     I think the three getters may not even be needed (based on \\n    comments below), in which case it seems like we shouldn\'t be \\n    creating a new interface. \\n\\n \\n\\t In LogDocMergePolicy, it seems like the checking that\'s done for \\n    whether a SegmentInfo is in a different directory, as well as the \\n    subsequent copy to move it over to the IndexWriter\'s directory, \\n    should not live in the MergePolicy? \\n \\n\\n\\n     Otherwise, every MergePolicy is going to have to duplicate this \\n    code.  Not to mention, we may someday create a more efficient way \\n    to copy than running a single-segment merge (which is a very \\n    inefficient, but, we only do it in addIndexes* I think).  I\'d like \\n    to capture this in one place (IndexWriter). \\n\\n     EG, the writer could have its own \\\"copyExternalSegments\\\" method \\n    which is called in addIndexes* and also optimize(), after the \\n    merge policy has done its merge, which does the check for wrong \\n    directory and subsequent copy. \\n\\n     I think this would mean IndexMerger.getDirectory() is not really \\n    needed. \\n\\n \\n\\t The \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it \\n    belongs back in IndexWriter: I think we don\'t want every \\n    MergePolicy having to replicate that tricky while condition. \\n \\n\\n\\n     Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\" \\n    which, if true, means that the MergePolicy must now pick a merge \\n    even if it didn\'t think it was time to.  This would let us move \\n    that tricky while condition logic back into IndexWriter. \\n\\n     Also, I think at some point we may want to have an optimize() \\n    method that takes an int parameter stating the max # segments in \\n    the resulting index.  This would allow you to optimize down to &lt;= \\n    N segments w\\/o paying full cost of a complete \\\"only one segment\\\" \\n    optimize.  If we had a \\\"forced\\\" boolean then we could build such \\n    an optimize method in the future, whereas as it stands now it \\n    would not be so easy to retrofit previously created MergePolicy \\n    classes to do this. \\n\\n And some more minor feedback: \\n\\n \\n\\t I love the simplification of addIndexesNoOptimize    Though (same \\n    comment as above) I think we should move that final \\\"copy if \\n    different directory\\\" step back in IndexWriter. \\n \\n\\n\\n \\n\\t There are some minor things that should not be committed eg the \\n    added \\\"infoStream = null\\\" in IndexFileDeleter.  I typically try to \\n    put a comment \\\"\\/\\/ nocommit\\\" above such changes as I make them to \\n    remind myself and keep them from slipping in. \\n \\n\\n\\n \\n\\t In the deprecated IndexWriter methods you\'re doing a hard cast to \\n    LogDocMergePolicy which gives a bad result if you\'re using a \\n    different merge policy; maybe catch the class cast exception (or, \\n    better, check upfront if it\'s an instanceof) and raise a more \\n    reasonable exception if not? \\n \\n\\n\\n \\n\\t IndexWriter around line 1908 has for loop that has commented out \\n    \\\"System.err.println\\\"; we should just comment out\\/remove for loop \\n \\n\\n\\n \\n\\t These commented out synchronized spook me a bit: \\n \\n\\n\\n       \\/* synchronized(segmentInfos) *\\/ { \\n\\n     Are they needed in these contexts?  Is this only once we have \\n    concurrent merging?  (This ties back to the first feedback to \\n    simplify MergePolicy API so that this kind of locking is only \\n    needed inside IndexWriter). \\n\\n \\n\\t Can we support non-contiguous merges?  If I understand it \\n    correctly, the MergeSpecification can express such a merge, it\'s \\n    just that the current IndexMerger (IndexWriter) cannot execute it, \\n    right?  So we are at least not precluding fixing this in the \\n    future. \\n \\n\\n\\n \\n\\t It confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can \\n    we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"?  Ie, \\n    this method determines whether a merge is necessary and, if so, it \\n    then asks IndexMerger to in fact execute the merge (or, returns \\n    the spec)? \\n \\n\\n\\n \\n\\t Instead of IndexWriter.releaseMergePolicy() can we have \\n    IndexWriter only close the merge policy if it was the one that had \\n    created it?  (Similar to how IndexWriter closes the dir if it has \\n    opened it from a String or File, but does not close it if it was \\n    passed in). \\n \\n\\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518186\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518186&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518186\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518186_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518186_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 16:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T16:47:06+0000\'\u003e07\\/Aug\\/07 16:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; &gt; I think we ideally would like concurrency to be fully independent of\u003cbr\\/\u003e\\n&gt; &gt; the merge policy.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I thought of that, too, while taking a fresh look at things\u003cbr\\/\u003e\\n&gt; again. It\'s my current approach, though I\'m not yet sure there won\'t\u003cbr\\/\u003e\\n&gt; be stumbling blocks. More soon, hopefully.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell I think the current MergePolicy API (where the \\\"merge\\\" method\u003cbr\\/\u003e\\ncalls IndexWriter.merge itself, must cascade itself, etc.) makes it\u003cbr\\/\u003e\\nhard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you could\u003cbr\\/\u003e\\nuse to make any MergePolicy concurrent \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/help_16.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e.  How would you do it?\u003c\\/p\u003e\\n\\n\u003cp\u003eEG I\'m working on a new MergePolicy for \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, which would be\u003cbr\\/\u003e\\nnice to run concurrently, but I\'d really rather not have to figure out\u003cbr\\/\u003e\\nhow to build my own concurrency\\/locking\\/etc in it.  Ideally\u003cbr\\/\u003e\\n\\\"concurrency\\\" is captured as a single wrapper class that we all can\u003cbr\\/\u003e\\nre-use on top of any MergePolicy.  I think we can do that with the\u003cbr\\/\u003e\\nproposed simplification.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think with one change to your MergePolicy API &amp; control flow, we\u003cbr\\/\u003e\\n&gt; &gt; could make this work very well: instead of requiring the MergePolicy\u003cbr\\/\u003e\\n&gt; &gt; to call IndexWriter.merge, and do the cascading, it should just\u003cbr\\/\u003e\\n&gt; &gt; return the one MergeSpecification that should be done right now.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Hmm ... interesting idea. I thought about it briefly, though I\u003cbr\\/\u003e\\n&gt; didn\'t pursue it (see below). It would end up changing the possible\u003cbr\\/\u003e\\n&gt; space of merge policies subtly. You wouldn\'t be able to have any\u003cbr\\/\u003e\\n&gt; state in the algorithm. Arguably this is a good thing. There is also\u003cbr\\/\u003e\\n&gt; a bit more overhead, since starting the computation of potential\u003cbr\\/\u003e\\n&gt; merges from scratch each time could imply a little more computation,\u003cbr\\/\u003e\\n&gt; but I suspect this is not significant.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think you can still have state (as instance variables in your\u003cbr\\/\u003e\\nclass)?  How would this simplification restrict the space of merge\u003cbr\\/\u003e\\npolicies?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; When the inner MergePolicy wants to do a merge, the\u003cbr\\/\u003e\\n&gt; &gt; ConcurrentMergePolicy would in turn kick off that merge in the BG but\u003cbr\\/\u003e\\n&gt; &gt; then return null to the IndexWriter allowing IndexWriter to return to\u003cbr\\/\u003e\\n&gt; &gt; its caller, etc.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I\'m a little unsure here. Are you saying the ConcurrentMergePolicy\u003cbr\\/\u003e\\n&gt; does the merges itself, rather than using the writer? That\'s going\u003cbr\\/\u003e\\n&gt; to mean a synchronization dance between the CMP and the\u003cbr\\/\u003e\\n&gt; writer. There\'s no question but that there has to be some synch\u003cbr\\/\u003e\\n&gt; dance, but my current thinking was to try to keep as cleanly within\u003cbr\\/\u003e\\n&gt; one class, IW, as I could.\u003c\\/p\u003e\\n\\n\u003cp\u003eOh, no: ConcurrentMergePolicy would still call IndexWriter.merge(spec),\u003cbr\\/\u003e\\njust with a separate thread.  And so all synchronization required is\u003cbr\\/\u003e\\nstill inside IndexWriter (I think?).\u003c\\/p\u003e\\n\\n\u003cp\u003eIn fact, if we stick with the current MergePolicy API, aren\'t you\u003cbr\\/\u003e\\ngoing to have to put some locking into eg the LogDocMergePolicy when\u003cbr\\/\u003e\\nconcurrent merges might be happening?  With the new approach,\u003cbr\\/\u003e\\nIndexWriter could invoke MergePolicy.merge under a\u003cbr\\/\u003e\\n\\\"synchronized(segmentInfos)\\\", and then each MergePolicy doesn\'t have\u003cbr\\/\u003e\\nto deal with locking at all.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518186_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518186_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 16:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T16:47:06+0000\'\u003e07\\/Aug\\/07 16:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; &gt; I think we ideally would like concurrency to be fully independent of \\n&gt; &gt; the merge policy. \\n&gt; \\n&gt; I thought of that, too, while taking a fresh look at things \\n&gt; again. It\'s my current approach, though I\'m not yet sure there won\'t \\n&gt; be stumbling blocks. More soon, hopefully. \\n\\n Well I think the current MergePolicy API (where the \\\"merge\\\" method \\ncalls IndexWriter.merge itself, must cascade itself, etc.) makes it \\nhard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you could \\nuse to make any MergePolicy concurrent  .  How would you do it? \\n\\n EG I\'m working on a new MergePolicy for   LUCENE-845  , which would be \\nnice to run concurrently, but I\'d really rather not have to figure out \\nhow to build my own concurrency\\/locking\\/etc in it.  Ideally \\n\\\"concurrency\\\" is captured as a single wrapper class that we all can \\nre-use on top of any MergePolicy.  I think we can do that with the \\nproposed simplification. \\n\\n &gt; &gt; I think with one change to your MergePolicy API &amp; control flow, we \\n&gt; &gt; could make this work very well: instead of requiring the MergePolicy \\n&gt; &gt; to call IndexWriter.merge, and do the cascading, it should just \\n&gt; &gt; return the one MergeSpecification that should be done right now. \\n\\n &gt; Hmm ... interesting idea. I thought about it briefly, though I \\n&gt; didn\'t pursue it (see below). It would end up changing the possible \\n&gt; space of merge policies subtly. You wouldn\'t be able to have any \\n&gt; state in the algorithm. Arguably this is a good thing. There is also \\n&gt; a bit more overhead, since starting the computation of potential \\n&gt; merges from scratch each time could imply a little more computation, \\n&gt; but I suspect this is not significant. \\n\\n I think you can still have state (as instance variables in your \\nclass)?  How would this simplification restrict the space of merge \\npolicies? \\n\\n &gt; &gt; When the inner MergePolicy wants to do a merge, the \\n&gt; &gt; ConcurrentMergePolicy would in turn kick off that merge in the BG but \\n&gt; &gt; then return null to the IndexWriter allowing IndexWriter to return to \\n&gt; &gt; its caller, etc. \\n&gt; \\n&gt; I\'m a little unsure here. Are you saying the ConcurrentMergePolicy \\n&gt; does the merges itself, rather than using the writer? That\'s going \\n&gt; to mean a synchronization dance between the CMP and the \\n&gt; writer. There\'s no question but that there has to be some synch \\n&gt; dance, but my current thinking was to try to keep as cleanly within \\n&gt; one class, IW, as I could. \\n\\n Oh, no: ConcurrentMergePolicy would still call IndexWriter.merge(spec), \\njust with a separate thread.  And so all synchronization required is \\nstill inside IndexWriter (I think?). \\n\\n In fact, if we stick with the current MergePolicy API, aren\'t you \\ngoing to have to put some locking into eg the LogDocMergePolicy when \\nconcurrent merges might be happening?  With the new approach, \\nIndexWriter could invoke MergePolicy.merge under a \\n\\\"synchronized(segmentInfos)\\\", and then each MergePolicy doesn\'t have \\nto deal with locking at all.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518210\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518210&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518210\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518210_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518210_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 17:54\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T17:54:53+0000\'\u003e07\\/Aug\\/07 17:54\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e    Is the separate IndexMerger interface really necessary?\u003c\\/p\u003e\\n\\n\u003cp\u003eI wrestled with this, so in the past, it wouldn\'t have taken much to convince me otherwise. The reason for the extra interface is I was hoping to discourage or create a little extra friction for merge policies in terms of looking too much into the internals of IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs an example, it\'s not a good idea for merge policies to be able to access IndexWriter#segmentInfos directly. (That\'s a case I would like to solve by making segmentInfos private, but I haven\'t looked at that completely yet and even beyond that case, I\'d still like merge policies to have a very clean interface with IWs.)\u003c\\/p\u003e\\n\\n\u003cp\u003eIt feels kinda weird for me to be arguing for constraints since I work mostly in dynamic languages that have none of this stuff. But it reflects my goal that merge policies simply be algorithms, not real workers.\u003c\\/p\u003e\\n\\n\u003cp\u003eMoreover, I think it may be useful for implementing concurrency (see below).\u003c\\/p\u003e\\n\\n\u003cp\u003e    While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think,\u003cbr\\/\u003e\\n    instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write\u003cbr\\/\u003e\\n    through\\\" to the LogDocMergePolicy if that is the merge policy in\u003cbr\\/\u003e\\n    use (and LogDocMergePolicy should store its own private\u003cbr\\/\u003e\\n    \\\"minMergeDocs\\\").\u003c\\/p\u003e\\n\\n\u003cp\u003eThe thing here is that the merge policy has nothing to do with max buffered docs, right? The code for buffering docs for the first segment is wholly in the IndexWriter. LogDocMergePolicy happens to need it (in its current incarnation) in order to handle the way the log levels are computed. This could, of course, be changed. There\'s nothing that says a merge policy has to look at these values, just that they\'re available should the merge policy want to look.\u003c\\/p\u003e\\n\\n\u003cp\u003eI guess my idea was that the index writer was responsible for handling the initial segment (with DocsWriter, if it wants) and also to provide an indication to the merge policies how it was handling them.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt\'s possible to have the merge policy influence the first segment size but that opens up a lot of issues. Does every merge policy then have to know how to trade between buffering by doc count and buffering by ram? I was hoping to avoid that.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m not all that happy with this the way it is, but supporting both by-doc and by-ram is messy but seems necessary. This was my take on making it least messy?\u003c\\/p\u003e\\n\\n\u003cp\u003e    In LogDocMergePolicy, it seems like the checking that\'s done for\u003cbr\\/\u003e\\n    whether a SegmentInfo is in a different directory, as well as the\u003cbr\\/\u003e\\n    subsequent copy to move it over to the IndexWriter\'s directory,\u003cbr\\/\u003e\\n    should not live in the MergePolicy?\u003c\\/p\u003e\\n\\n\u003cp\u003eI see two parts to this.\u003c\\/p\u003e\\n\\n\u003cp\u003eFirst, I hesitate to make it not possible for merge policy to see the directory information, i.e., remove IndexMerger#getDirectory(). Copying a segment is one way to get it into the current directory, but merging with other segments does to. A merge policy could decide to go ahead and merge a bunch of segments that are in other directories rather than just copy them individually. Taking away getDirectory() removes that option.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs to how to handle the case where single segments are copied, I guess my main reason for leaving that in the merge policy would be for simplicity. Seems nicer to have all segment amalgamation management in one place, rather than some in one class and some in another. Could be factored into an optional base merge policy for derived classes to use as they might like.\u003c\\/p\u003e\\n\\n\u003cp\u003e    The \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it\u003cbr\\/\u003e\\n    belongs back in IndexWriter: I think we don\'t want every\u003cbr\\/\u003e\\n    MergePolicy having to replicate that tricky while condition.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe reason for not doing this was I can imagine different merge policies having a different model of what optimize means. I can imagine some policies that would not optimize everything down to a single segment but instead obeyed a max segment size. But we could factor the default conditional into an optional base class, as above.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt is an ugly conditional that there might be better way to formulate, so that policies don\'t have to look at the grody details like hasSeparateNorms. But I\'d still like the merge policies to be able to decide what optimize means at a high level.\u003c\\/p\u003e\\n\\n\u003cp\u003e    Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\"\u003cbr\\/\u003e\\n    which, if true, means that the MergePolicy must now pick a merge\u003cbr\\/\u003e\\n    even if it didn\'t think it was time to.  This would let us move\u003cbr\\/\u003e\\n    that tricky while condition logic back into IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eI didn\'t follow this. forced == optimize? If not, what does pick a merge mean? Not sure what LogDoc should do for merge(force=true) if it thinks everything is fine?\u003c\\/p\u003e\\n\\n\u003cp\u003e    Also, I think at some point we may want to have an optimize()\u003cbr\\/\u003e\\n    method that takes an int parameter stating the max # segments in\u003cbr\\/\u003e\\n    the resulting index.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think this is great functionality for a merge policy, but what about just making that part of the individual merge policy interface, rather than linked to IndexWriter? That was one goal of making a factored merge policy: that you could do these tweaks without changing IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e    This would allow you to optimize down to &lt;=\u003cbr\\/\u003e\\n    N segments w\\/o paying full cost of a complete \\\"only one segment\\\"\u003cbr\\/\u003e\\n    optimize.  If we had a \\\"forced\\\" boolean then we could build such\u003cbr\\/\u003e\\n    an optimize method in the future, whereas as it stands now it\u003cbr\\/\u003e\\n    would not be so easy to retrofit previously created MergePolicy\u003cbr\\/\u003e\\n    classes to do this.\u003c\\/p\u003e\\n\\n\u003cp\u003eI haven\'t looked at how difficult it would be to make LogDoc sufficiently derivable to allow a derived class to add this tweak. If I could, would it be enough?\u003c\\/p\u003e\\n\\n\u003cp\u003e    There are some minor things that should not be committed eg the\u003cbr\\/\u003e\\n    added \\\"infoStream = null\\\" in IndexFileDeleter.  I typically try to\u003cbr\\/\u003e\\n    put a comment \\\"\\/\\/ nocommit\\\" above such changes as I make them to\u003cbr\\/\u003e\\n    remind myself and keep them from slipping in.\u003c\\/p\u003e\\n\\n\u003cp\u003eYou\'re right and thanks for the idea. Obvious now.\u003c\\/p\u003e\\n\\n\u003cp\u003e    In the deprecated IndexWriter methods you\'re doing a hard cast to\u003cbr\\/\u003e\\n    LogDocMergePolicy which gives a bad result if you\'re using a\u003cbr\\/\u003e\\n    different merge policy; maybe catch the class cast exception (or,\u003cbr\\/\u003e\\n    better, check upfront if it\'s an instanceof) and raise a more\u003cbr\\/\u003e\\n    reasonable exception if not?\u003c\\/p\u003e\\n\\n\u003cp\u003eAgreed.\u003c\\/p\u003e\\n\\n\u003cp\u003e    IndexWriter around line 1908 has for loop that has commented out\u003cbr\\/\u003e\\n    \\\"System.err.println\\\"; we should just comment out\\/remove for loop\u003c\\/p\u003e\\n\\n\u003cp\u003eThe whole loop will be gone before commit but I didn\'t want to delete it yet since I might need to turn it back on for more debugging.  It should, of course, have a \\\"\\/\\/ nocommit\\\" comment.\u003c\\/p\u003e\\n\\n\u003cp\u003e    These commented out synchronized spook me a bit:\u003c\\/p\u003e\\n\\n\u003cp\u003e      \\/* synchronized(segmentInfos) *\\/ {\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is from my old code. I left it in there as a hint as I work on the concurrent stuff again. It\'s only a weak hint, though, because things have changed a lot since that code was even partially functional. Ignore it. It won\'t go into the serial patch and anything for \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-870\\\" title=\\\"add concurrent merge policy\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-870\\\"\u003e\u003cdel\u003eLUCENE-870\u003c\\/del\u003e\u003c\\/a\u003e will have to have its own justification.\u003c\\/p\u003e\\n\\n\u003cp\u003e    Can we support non-contiguous merges?  If I understand it\u003cbr\\/\u003e\\n    correctly, the MergeSpecification can express such a merge, it\'s\u003cbr\\/\u003e\\n    just that the current IndexMerger (IndexWriter) cannot execute it,\u003cbr\\/\u003e\\n    right?  So we are at least not precluding fixing this in the\u003cbr\\/\u003e\\n    future.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs far as I\'ve seen so far, there are no barriers to non-contiguous merges. Maybe something will crop up that is, but in what I\'ve done, I haven\'t seen any.\u003c\\/p\u003e\\n\\n\u003cp\u003e    It confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can\u003cbr\\/\u003e\\n    we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003eI suppose. I\'m not a big fan of the \\\"maybeFoo\\\" style of naming. I think of \\\"merge\\\" like \\\"optimize\\\": make it so \\/ idempotent. But I\'m certainly willing to write whatever people find clearest. \u003c\\/p\u003e\\n\\n\u003cp\u003e    Instead of IndexWriter.releaseMergePolicy() can we have\u003cbr\\/\u003e\\n    IndexWriter only close the merge policy if it was the one that had\u003cbr\\/\u003e\\n    created it?  (Similar to how IndexWriter closes the dir if it has\u003cbr\\/\u003e\\n    opened it from a String or File, but does not close it if it was\u003cbr\\/\u003e\\n    passed in).\u003c\\/p\u003e\\n\\n\u003cp\u003eThis precludes\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tiw.setMergePolicy(new MyMergePolicy(...));\u003cbr\\/\u003e\\n      ...\u003cbr\\/\u003e\\n\\tiw.close();\u003c\\/p\u003e\\n\\n\u003cp\u003eYou\'re always going to have to\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tMergePolicy mp = new MyMergePolicy(...);\u003cbr\\/\u003e\\n\\tiw.setMergePolicy(mp);\u003cbr\\/\u003e\\n      ...\u003cbr\\/\u003e\\n      iw.close();\u003cbr\\/\u003e\\n      mp.close();\u003c\\/p\u003e\\n\\n\u003cp\u003eThe implementation\'s much cleaner using the semantics you describe, but I was thinking it\'d be better to optimize for the usability of the common client code case?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWell I think the current MergePolicy API (where the \\\"merge\\\" method\u003cbr\\/\u003e\\n\\tcalls IndexWriter.merge itself, must cascade itself, etc.) makes it\u003cbr\\/\u003e\\n\\thard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you could\u003cbr\\/\u003e\\n\\tuse to make any MergePolicy concurrent \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/help_16.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e.  How would you do it?\u003c\\/p\u003e\\n\\n\u003cp\u003eI really haven\'t had time to go heads down on this (the old concurrent merge policy was a derived class rather than a wrapper class). But I was thinking that perhaps ConurrentMergePolicy would actually wrap IndexWriter as well as the serial merge policy, i.e., implement IndexMerger (my biggest argument for IM at this point). But I haven\'t looked deeply at whether this will work but I think it has at least a chance.\u003c\\/p\u003e\\n\\n\u003cp\u003eI should know more about this is a day or two.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think you can still have state (as instance variables in your\u003cbr\\/\u003e\\n\\tclass)?  How would this simplification restrict the space of merge\u003cbr\\/\u003e\\n\\tpolicies?\u003c\\/p\u003e\\n\\n\u003cp\u003es\\/state\\/stack state\\/. Yeah, you can always unwind your loops and lift your recursions, put all that stack state into instance variables. But, well, yuck. I\'d like to make it easy to write simple merge policies and take up the heavy lifting elsewhere. Hopefully there will be more merge policies than index writers.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tOh, no: ConcurrentMergePolicy would still call IndexWriter.merge(spec),\u003cbr\\/\u003e\\n\\tjust with a separate thread.  And so all synchronization required is\u003cbr\\/\u003e\\n\\tstill inside IndexWriter (I think?).\u003c\\/p\u003e\\n\\n\u003cp\u003eThat\'s my idea.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe synchronization is still tricky, since parts of segmentInfos are getting changed at various times and there are references and\\/or copies of it other places. And as Ning pointed out to me, we also have to deal with buffered delete terms. I\'d say I got about 80% of the way there on the last go around. I\'m hoping to get all the way this time.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tIn fact, if we stick with the current MergePolicy API, aren\'t you\u003cbr\\/\u003e\\n\\tgoing to have to put some locking into eg the LogDocMergePolicy when\u003cbr\\/\u003e\\n\\tconcurrent merges might be happening?\u003c\\/p\u003e\\n\\n\u003cp\u003eYes and no. If CMP implements IndexMerger, I think we might be okay? In the previous iteration, I used derivation so that ConcurrentLogDocMergePolicy derived from the serial version but had the necessary threading. I agree that a wrapper is better solution if it can be made to work.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518210_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518210_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 17:54\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T17:54:53+0000\'\u003e07\\/Aug\\/07 17:54\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                        Is the separate IndexMerger interface really necessary? \\n\\n I wrestled with this, so in the past, it wouldn\'t have taken much to convince me otherwise. The reason for the extra interface is I was hoping to discourage or create a little extra friction for merge policies in terms of looking too much into the internals of IndexWriter. \\n\\n As an example, it\'s not a good idea for merge policies to be able to access IndexWriter#segmentInfos directly. (That\'s a case I would like to solve by making segmentInfos private, but I haven\'t looked at that completely yet and even beyond that case, I\'d still like merge policies to have a very clean interface with IWs.) \\n\\n It feels kinda weird for me to be arguing for constraints since I work mostly in dynamic languages that have none of this stuff. But it reflects my goal that merge policies simply be algorithms, not real workers. \\n\\n Moreover, I think it may be useful for implementing concurrency (see below). \\n\\n     While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think, \\n    instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write \\n    through\\\" to the LogDocMergePolicy if that is the merge policy in \\n    use (and LogDocMergePolicy should store its own private \\n    \\\"minMergeDocs\\\"). \\n\\n The thing here is that the merge policy has nothing to do with max buffered docs, right? The code for buffering docs for the first segment is wholly in the IndexWriter. LogDocMergePolicy happens to need it (in its current incarnation) in order to handle the way the log levels are computed. This could, of course, be changed. There\'s nothing that says a merge policy has to look at these values, just that they\'re available should the merge policy want to look. \\n\\n I guess my idea was that the index writer was responsible for handling the initial segment (with DocsWriter, if it wants) and also to provide an indication to the merge policies how it was handling them. \\n\\n It\'s possible to have the merge policy influence the first segment size but that opens up a lot of issues. Does every merge policy then have to know how to trade between buffering by doc count and buffering by ram? I was hoping to avoid that. \\n\\n I\'m not all that happy with this the way it is, but supporting both by-doc and by-ram is messy but seems necessary. This was my take on making it least messy? \\n\\n     In LogDocMergePolicy, it seems like the checking that\'s done for \\n    whether a SegmentInfo is in a different directory, as well as the \\n    subsequent copy to move it over to the IndexWriter\'s directory, \\n    should not live in the MergePolicy? \\n\\n I see two parts to this. \\n\\n First, I hesitate to make it not possible for merge policy to see the directory information, i.e., remove IndexMerger#getDirectory(). Copying a segment is one way to get it into the current directory, but merging with other segments does to. A merge policy could decide to go ahead and merge a bunch of segments that are in other directories rather than just copy them individually. Taking away getDirectory() removes that option. \\n\\n As to how to handle the case where single segments are copied, I guess my main reason for leaving that in the merge policy would be for simplicity. Seems nicer to have all segment amalgamation management in one place, rather than some in one class and some in another. Could be factored into an optional base merge policy for derived classes to use as they might like. \\n\\n     The \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it \\n    belongs back in IndexWriter: I think we don\'t want every \\n    MergePolicy having to replicate that tricky while condition. \\n\\n The reason for not doing this was I can imagine different merge policies having a different model of what optimize means. I can imagine some policies that would not optimize everything down to a single segment but instead obeyed a max segment size. But we could factor the default conditional into an optional base class, as above. \\n\\n It is an ugly conditional that there might be better way to formulate, so that policies don\'t have to look at the grody details like hasSeparateNorms. But I\'d still like the merge policies to be able to decide what optimize means at a high level. \\n\\n     Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\" \\n    which, if true, means that the MergePolicy must now pick a merge \\n    even if it didn\'t think it was time to.  This would let us move \\n    that tricky while condition logic back into IndexWriter. \\n\\n I didn\'t follow this. forced == optimize? If not, what does pick a merge mean? Not sure what LogDoc should do for merge(force=true) if it thinks everything is fine? \\n\\n     Also, I think at some point we may want to have an optimize() \\n    method that takes an int parameter stating the max # segments in \\n    the resulting index. \\n\\n I think this is great functionality for a merge policy, but what about just making that part of the individual merge policy interface, rather than linked to IndexWriter? That was one goal of making a factored merge policy: that you could do these tweaks without changing IndexWriter. \\n\\n     This would allow you to optimize down to &lt;= \\n    N segments w\\/o paying full cost of a complete \\\"only one segment\\\" \\n    optimize.  If we had a \\\"forced\\\" boolean then we could build such \\n    an optimize method in the future, whereas as it stands now it \\n    would not be so easy to retrofit previously created MergePolicy \\n    classes to do this. \\n\\n I haven\'t looked at how difficult it would be to make LogDoc sufficiently derivable to allow a derived class to add this tweak. If I could, would it be enough? \\n\\n     There are some minor things that should not be committed eg the \\n    added \\\"infoStream = null\\\" in IndexFileDeleter.  I typically try to \\n    put a comment \\\"\\/\\/ nocommit\\\" above such changes as I make them to \\n    remind myself and keep them from slipping in. \\n\\n You\'re right and thanks for the idea. Obvious now. \\n\\n     In the deprecated IndexWriter methods you\'re doing a hard cast to \\n    LogDocMergePolicy which gives a bad result if you\'re using a \\n    different merge policy; maybe catch the class cast exception (or, \\n    better, check upfront if it\'s an instanceof) and raise a more \\n    reasonable exception if not? \\n\\n Agreed. \\n\\n     IndexWriter around line 1908 has for loop that has commented out \\n    \\\"System.err.println\\\"; we should just comment out\\/remove for loop \\n\\n The whole loop will be gone before commit but I didn\'t want to delete it yet since I might need to turn it back on for more debugging.  It should, of course, have a \\\"\\/\\/ nocommit\\\" comment. \\n\\n     These commented out synchronized spook me a bit: \\n\\n       \\/* synchronized(segmentInfos) *\\/ { \\n\\n This is from my old code. I left it in there as a hint as I work on the concurrent stuff again. It\'s only a weak hint, though, because things have changed a lot since that code was even partially functional. Ignore it. It won\'t go into the serial patch and anything for   LUCENE-870   will have to have its own justification. \\n\\n     Can we support non-contiguous merges?  If I understand it \\n    correctly, the MergeSpecification can express such a merge, it\'s \\n    just that the current IndexMerger (IndexWriter) cannot execute it, \\n    right?  So we are at least not precluding fixing this in the \\n    future. \\n\\n As far as I\'ve seen so far, there are no barriers to non-contiguous merges. Maybe something will crop up that is, but in what I\'ve done, I haven\'t seen any. \\n\\n     It confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can \\n    we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"? \\n\\n I suppose. I\'m not a big fan of the \\\"maybeFoo\\\" style of naming. I think of \\\"merge\\\" like \\\"optimize\\\": make it so \\/ idempotent. But I\'m certainly willing to write whatever people find clearest.  \\n\\n     Instead of IndexWriter.releaseMergePolicy() can we have \\n    IndexWriter only close the merge policy if it was the one that had \\n    created it?  (Similar to how IndexWriter closes the dir if it has \\n    opened it from a String or File, but does not close it if it was \\n    passed in). \\n\\n This precludes \\n\\n \\tiw.setMergePolicy(new MyMergePolicy(...)); \\n      ... \\n\\tiw.close(); \\n\\n You\'re always going to have to \\n\\n \\tMergePolicy mp = new MyMergePolicy(...); \\n\\tiw.setMergePolicy(mp); \\n      ... \\n      iw.close(); \\n      mp.close(); \\n\\n The implementation\'s much cleaner using the semantics you describe, but I was thinking it\'d be better to optimize for the usability of the common client code case? \\n\\n \\tWell I think the current MergePolicy API (where the \\\"merge\\\" method \\n\\tcalls IndexWriter.merge itself, must cascade itself, etc.) makes it \\n\\thard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you could \\n\\tuse to make any MergePolicy concurrent  .  How would you do it? \\n\\n I really haven\'t had time to go heads down on this (the old concurrent merge policy was a derived class rather than a wrapper class). But I was thinking that perhaps ConurrentMergePolicy would actually wrap IndexWriter as well as the serial merge policy, i.e., implement IndexMerger (my biggest argument for IM at this point). But I haven\'t looked deeply at whether this will work but I think it has at least a chance. \\n\\n I should know more about this is a day or two. \\n\\n \\tI think you can still have state (as instance variables in your \\n\\tclass)?  How would this simplification restrict the space of merge \\n\\tpolicies? \\n\\n s\\/state\\/stack state\\/. Yeah, you can always unwind your loops and lift your recursions, put all that stack state into instance variables. But, well, yuck. I\'d like to make it easy to write simple merge policies and take up the heavy lifting elsewhere. Hopefully there will be more merge policies than index writers. \\n\\n \\tOh, no: ConcurrentMergePolicy would still call IndexWriter.merge(spec), \\n\\tjust with a separate thread.  And so all synchronization required is \\n\\tstill inside IndexWriter (I think?). \\n\\n That\'s my idea. \\n\\n The synchronization is still tricky, since parts of segmentInfos are getting changed at various times and there are references and\\/or copies of it other places. And as Ning pointed out to me, we also have to deal with buffered delete terms. I\'d say I got about 80% of the way there on the last go around. I\'m hoping to get all the way this time. \\n\\n \\tIn fact, if we stick with the current MergePolicy API, aren\'t you \\n\\tgoing to have to put some locking into eg the LogDocMergePolicy when \\n\\tconcurrent merges might be happening? \\n\\n Yes and no. If CMP implements IndexMerger, I think we might be okay? In the previous iteration, I used derivation so that ConcurrentLogDocMergePolicy derived from the serial version but had the necessary threading. I agree that a wrapper is better solution if it can be made to work.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518222\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518222&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518222\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518222_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518222_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 18:35\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T18:35:49+0000\'\u003e07\\/Aug\\/07 18:35\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOn a related note, Mike, there a few FIXME\'s in IW related to useCompoundFile: it doesn\'t exist in IW anymore (other than as a deprecated feature). The goal was to allow merge policies to decide when to use compound files, perhaps on a segment-by-segment basis. That all works fine for merge operations.\u003c\\/p\u003e\\n\\n\u003cp\u003eBut there\'s also the case of new segments, what format they should be in. These are segments that are going to be created by IW (via DocsWriter?) My stab at this was to have IW ask the merge policy. Since this isn\'t a merge, per say, the IW passes to the merge policy the current set of segment infos and the new segment info, asking what format the new segment info should use. So MergePolicy has\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tboolean useCompoundFile(SegmentInfos segments, SegmentInfo newSegment);\u003c\\/p\u003e\\n\\n\u003cp\u003eLooking at IW, with the new DocsWriter stuff, it looks like there isn\'t a segmentInfo object for the new segment at the time the predicate is being called. Would it be possible to make one? Something like DocumentsWriter#getDocStoreSegmentInfo() analogous to DocumentsWriter#getDocStoreSegment()? It could be an object just thrown away.\u003c\\/p\u003e\\n\\n\u003cp\u003eIs this a bad idea?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518222_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518222_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 18:35\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T18:35:49+0000\'\u003e07\\/Aug\\/07 18:35\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    On a related note, Mike, there a few FIXME\'s in IW related to useCompoundFile: it doesn\'t exist in IW anymore (other than as a deprecated feature). The goal was to allow merge policies to decide when to use compound files, perhaps on a segment-by-segment basis. That all works fine for merge operations. \\n\\n But there\'s also the case of new segments, what format they should be in. These are segments that are going to be created by IW (via DocsWriter?) My stab at this was to have IW ask the merge policy. Since this isn\'t a merge, per say, the IW passes to the merge policy the current set of segment infos and the new segment info, asking what format the new segment info should use. So MergePolicy has \\n\\n \\tboolean useCompoundFile(SegmentInfos segments, SegmentInfo newSegment); \\n\\n Looking at IW, with the new DocsWriter stuff, it looks like there isn\'t a segmentInfo object for the new segment at the time the predicate is being called. Would it be possible to make one? Something like DocumentsWriter#getDocStoreSegmentInfo() analogous to DocumentsWriter#getDocStoreSegment()? It could be an object just thrown away. \\n\\n Is this a bad idea?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518237\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518237&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518237\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518237_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518237_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 19:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T19:47:51+0000\'\u003e07\\/Aug\\/07 19:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Looking at IW, with the new DocsWriter stuff, it looks like there\u003cbr\\/\u003e\\n&gt; isn\'t a segmentInfo object for the new segment at the time the\u003cbr\\/\u003e\\n&gt; predicate is being called. Would it be possible to make one?\u003cbr\\/\u003e\\n&gt; Something like DocumentsWriter#getDocStoreSegmentInfo() analogous to\u003cbr\\/\u003e\\n&gt; DocumentsWriter#getDocStoreSegment()? It could be an object just\u003cbr\\/\u003e\\n&gt; thrown away.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmm: it looks like you\'re calling\u003cbr\\/\u003e\\n\\\"mergePolicy.useCompoundFile(segmentInfos,null)\\\" twice: once inside\u003cbr\\/\u003e\\nflushDocStores and immediately thereafter when flushDocStores returns\u003cbr\\/\u003e\\ninto the flush() code.  Maybe you should change flushDocStores to\u003cbr\\/\u003e\\nreturn whether or not the flushed files are in compound format\u003cbr\\/\u003e\\ninstead?\u003c\\/p\u003e\\n\\n\u003cp\u003eSince flushDocStores() is flushing only the \\\"doc store\\\" index files\u003cbr\\/\u003e\\n(stored fields &amp; term vectors) it\'s not a real \\\"segment\\\" so it\'s a\u003cbr\\/\u003e\\nsomewhat forced fit to make a SegmentInfo in this case.  I guess we\u003cbr\\/\u003e\\ncould make a \\\"largely empty\\\" SegmentInfo and fill in what we can, but\u003cbr\\/\u003e\\nthat\'s somewhat dangerous (eg methods like files() would have to be\u003cbr\\/\u003e\\nfixed to deal with this).\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe, instead, we could use one of the SegmentInfo instances from a\u003cbr\\/\u003e\\nsegment that refers to this doc store segment?  This would just mean\u003cbr\\/\u003e\\nstepping through all SegmentInfo\'s and finding the first one (say)\u003cbr\\/\u003e\\nwhose docStoreSegment equals the one we are now flushing?  Still it\u003cbr\\/\u003e\\nwould be good to differentiate this case (creating compound file for\u003cbr\\/\u003e\\ndoc store files vs for a real segment) to MergePolicy somehow (maybe\u003cbr\\/\u003e\\nadd a boolean arg \\\"isDocStore\\\" or some such?).\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518237_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518237_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 19:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T19:47:51+0000\'\u003e07\\/Aug\\/07 19:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Looking at IW, with the new DocsWriter stuff, it looks like there \\n&gt; isn\'t a segmentInfo object for the new segment at the time the \\n&gt; predicate is being called. Would it be possible to make one? \\n&gt; Something like DocumentsWriter#getDocStoreSegmentInfo() analogous to \\n&gt; DocumentsWriter#getDocStoreSegment()? It could be an object just \\n&gt; thrown away. \\n\\n Hmmm: it looks like you\'re calling \\n\\\"mergePolicy.useCompoundFile(segmentInfos,null)\\\" twice: once inside \\nflushDocStores and immediately thereafter when flushDocStores returns \\ninto the flush() code.  Maybe you should change flushDocStores to \\nreturn whether or not the flushed files are in compound format \\ninstead? \\n\\n Since flushDocStores() is flushing only the \\\"doc store\\\" index files \\n(stored fields &amp; term vectors) it\'s not a real \\\"segment\\\" so it\'s a \\nsomewhat forced fit to make a SegmentInfo in this case.  I guess we \\ncould make a \\\"largely empty\\\" SegmentInfo and fill in what we can, but \\nthat\'s somewhat dangerous (eg methods like files() would have to be \\nfixed to deal with this). \\n\\n Maybe, instead, we could use one of the SegmentInfo instances from a \\nsegment that refers to this doc store segment?  This would just mean \\nstepping through all SegmentInfo\'s and finding the first one (say) \\nwhose docStoreSegment equals the one we are now flushing?  Still it \\nwould be good to differentiate this case (creating compound file for \\ndoc store files vs for a real segment) to MergePolicy somehow (maybe \\nadd a boolean arg \\\"isDocStore\\\" or some such?).              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518251\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518251&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518251\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518251_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518251_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 20:50\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T20:50:37+0000\'\u003e07\\/Aug\\/07 20:50\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eAh. I understand better now. I have to admit, I haven\'t kept up to date on some of the deeper file stuff in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt seems to me there\'s quite a bit of difference between segment files and doc store files. Since doc store files can be referred to by multiple segments, they can get quite large. I don\'t have any trouble imaging that a merge policy might want to CFS 10MB segments but not 10GB doc stores?\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m thinking maybe a MergePolicy#useCompoundDocStore( SegmentInfos ) makes sense? The naive case would still just use the static setting we have now, but we could think about a better implementation:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eMaybe never cfs doc store files? Is that an unreasonable default? It just strikes me that there should be far fewer of these so that we don\'t need to and on the other end, if they are big, CFS\'ing them is going to be expensive.\u003c\\/li\u003e\\n\\t\u003cli\u003eDo something smart but easy depending on number and size\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12518251_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518251_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 20:50\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T20:50:37+0000\'\u003e07\\/Aug\\/07 20:50\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Ah. I understand better now. I have to admit, I haven\'t kept up to date on some of the deeper file stuff in   LUCENE-843  . \\n\\n It seems to me there\'s quite a bit of difference between segment files and doc store files. Since doc store files can be referred to by multiple segments, they can get quite large. I don\'t have any trouble imaging that a merge policy might want to CFS 10MB segments but not 10GB doc stores? \\n\\n I\'m thinking maybe a MergePolicy#useCompoundDocStore( SegmentInfos ) makes sense? The naive case would still just use the static setting we have now, but we could think about a better implementation: \\n\\n \\n\\t Maybe never cfs doc store files? Is that an unreasonable default? It just strikes me that there should be far fewer of these so that we don\'t need to and on the other end, if they are big, CFS\'ing them is going to be expensive. \\n\\t Do something smart but easy depending on number and size \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518263\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518263&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518263\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518263_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518263_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 21:37\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T21:37:47+0000\'\u003e07\\/Aug\\/07 21:37\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; I\'m thinking maybe a MergePolicy#useCompoundDocStore( SegmentInfos )\u003cbr\\/\u003e\\n&gt; makes sense? The naive case would still just use the static setting\u003cbr\\/\u003e\\n&gt; we have now, but we could think about a better implementation:\u003c\\/p\u003e\\n\\n\u003cp\u003eI think adding that new method to MergePolicy is great!  And, just\u003cbr\\/\u003e\\nusing the same \\\"useCompoundFile\\\" as normal segmetns is good for\u003cbr\\/\u003e\\nstarters (and, this matches what\'s done today).\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518263_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518263_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Aug\\/07 21:37\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-07T21:37:47+0000\'\u003e07\\/Aug\\/07 21:37\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; I\'m thinking maybe a MergePolicy#useCompoundDocStore( SegmentInfos ) \\n&gt; makes sense? The naive case would still just use the static setting \\n&gt; we have now, but we could think about a better implementation: \\n\\n I think adding that new method to MergePolicy is great!  And, just \\nusing the same \\\"useCompoundFile\\\" as normal segmetns is good for \\nstarters (and, this matches what\'s done today).              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518435\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518435&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518435\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518435_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518435_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 12:48\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T12:48:18+0000\'\u003e08\\/Aug\\/07 12:48\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eNew feedback:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eAre you going to fix all unit tests that call the now-deprecated\u003cbr\\/\u003e\\n    APIs?  (You should still leave a few tests using the deprecated\u003cbr\\/\u003e\\n    APIs to make sure they in fact continue to work, but most tests\u003cbr\\/\u003e\\n    should not use the deprecated APIs).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eResponses to previous feedback:\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; As an example, it\'s not a good idea for merge policies to be able to\u003cbr\\/\u003e\\n&gt; access IndexWriter#segmentInfos directly. (That\'s a case I would\u003cbr\\/\u003e\\n&gt; like to solve by making segmentInfos private, but I haven\'t looked\u003cbr\\/\u003e\\n&gt; at that completely yet and even beyond that case, I\'d still like\u003cbr\\/\u003e\\n&gt; merge policies to have a very clean interface with IWs.)\u003c\\/p\u003e\\n\\n\u003cp\u003eAgreed, but the solution to that is to make segmentInfos private, not\u003cbr\\/\u003e\\nto make a whole new interface.  Ie, this is an IndexWriter problem, so\u003cbr\\/\u003e\\nwe should fix it in IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think,\u003cbr\\/\u003e\\n&gt; &gt; instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write\u003cbr\\/\u003e\\n&gt; &gt; through\\\" to the LogDocMergePolicy if that is the merge policy in\u003cbr\\/\u003e\\n&gt; &gt; use (and LogDocMergePolicy should store its own private\u003cbr\\/\u003e\\n&gt; &gt; \\\"minMergeDocs\\\").\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The thing here is that the merge policy has nothing to do with max\u003cbr\\/\u003e\\n&gt; buffered docs, right? The code for buffering docs for the first\u003cbr\\/\u003e\\n&gt; segment is wholly in the IndexWriter. LogDocMergePolicy happens to\u003cbr\\/\u003e\\n&gt; need it (in its current incarnation) in order to handle the way the\u003cbr\\/\u003e\\n&gt; log levels are computed. This could, of course, be changed. There\'s\u003cbr\\/\u003e\\n&gt; nothing that says a merge policy has to look at these values, just\u003cbr\\/\u003e\\n&gt; that they\'re available should the merge policy want to look.\u003c\\/p\u003e\\n\\n\u003cp\u003eExactly: these settings decide when a segment is flushed, so, why put\u003cbr\\/\u003e\\nthem into IndexMerger interface?  They shouldn\'t have anything to with\u003cbr\\/\u003e\\nmerging; I think they should be removed.\u003c\\/p\u003e\\n\\n\u003cp\u003eFor \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e I\'m working on a replacement for LogDocMergePolicy that\u003cbr\\/\u003e\\ndoes not use maxBufferedDocs.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I guess my idea was that the index writer was responsible for\u003cbr\\/\u003e\\n&gt; handling the initial segment (with DocsWriter, if it wants) and also\u003cbr\\/\u003e\\n&gt; to provide an indication to the merge policies how it was handling\u003cbr\\/\u003e\\n&gt; them.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; It\'s possible to have the merge policy influence the first segment\u003cbr\\/\u003e\\n&gt; size but that opens up a lot of issues. Does every merge policy then\u003cbr\\/\u003e\\n&gt; have to know how to trade between buffering by doc count and\u003cbr\\/\u003e\\n&gt; buffering by ram? I was hoping to avoid that.\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, I don\'t think merge policy should dictate flushing either;\u003cbr\\/\u003e\\nespecially because app logic above IndexWriter can already easily call\u003cbr\\/\u003e\\nflush() if necessary.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; In LogDocMergePolicy, it seems like the checking that\'s done for\u003cbr\\/\u003e\\n&gt; &gt; whether a SegmentInfo is in a different directory, as well as the\u003cbr\\/\u003e\\n&gt; &gt; subsequent copy to move it over to the IndexWriter\'s directory,\u003cbr\\/\u003e\\n&gt; &gt; should not live in the MergePolicy?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I see two parts to this.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; First, I hesitate to make it not possible for merge policy to see\u003cbr\\/\u003e\\n&gt; the directory information, i.e., remove\u003cbr\\/\u003e\\n&gt; IndexMerger#getDirectory(). Copying a segment is one way to get it\u003cbr\\/\u003e\\n&gt; into the current directory, but merging with other segments does\u003cbr\\/\u003e\\n&gt; to. A merge policy could decide to go ahead and merge a bunch of\u003cbr\\/\u003e\\n&gt; segments that are in other directories rather than just copy them\u003cbr\\/\u003e\\n&gt; individually. Taking away getDirectory() removes that option.\u003c\\/p\u003e\\n\\n\u003cp\u003eAgreed, a \\\"sophisticated\\\" merge policy would go and merge segments in\u003cbr\\/\u003e\\nother directories.  But, it should not have to.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m not proposing making it \\\"not possible\\\"; I\'m proposing the merge\u003cbr\\/\u003e\\npolicy is given IndexWriter at which point it can getDirectory() from\u003cbr\\/\u003e\\nit.  (Ie the extra interface solely for this purpose is overkill).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; As to how to handle the case where single segments are copied, I\u003cbr\\/\u003e\\n&gt; guess my main reason for leaving that in the merge policy would be\u003cbr\\/\u003e\\n&gt; for simplicity. Seems nicer to have all segment amalgamation\u003cbr\\/\u003e\\n&gt; management in one place, rather than some in one class and some in\u003cbr\\/\u003e\\n&gt; another. Could be factored into an optional base merge policy for\u003cbr\\/\u003e\\n&gt; derived classes to use as they might like.\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t see this as simpler: I see it as making the MergePolicy\u003cbr\\/\u003e\\nwriter\'s job more complex.  I also see it as substantial duplicated\u003cbr\\/\u003e\\ncode (I just had to copy\\/paste a bunch of code in working on my\u003cbr\\/\u003e\\nMergePolicy in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e).\u003c\\/p\u003e\\n\\n\u003cp\u003eI think factoring into a base class is an OK solution, but, it\u003cbr\\/\u003e\\nshouldn\'t be MergePolicy\'s job to remember to call this final \\\"move\u003cbr\\/\u003e\\nany segments in the wrong directory over\\\" code.  As long as its in one\u003cbr\\/\u003e\\nplace and people don\'t have to copy\\/paste code between MergePolicy\u003cbr\\/\u003e\\nsources.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; The \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it\u003cbr\\/\u003e\\n&gt; &gt; belongs back in IndexWriter: I think we don\'t want every\u003cbr\\/\u003e\\n&gt; &gt; MergePolicy having to replicate that tricky while condition.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The reason for not doing this was I can imagine different merge\u003cbr\\/\u003e\\n&gt; policies having a different model of what optimize means. I can\u003cbr\\/\u003e\\n&gt; imagine some policies that would not optimize everything down to a\u003cbr\\/\u003e\\n&gt; single segment but instead obeyed a max segment size. But we could\u003cbr\\/\u003e\\n&gt; factor the default conditional into an optional base class, as\u003cbr\\/\u003e\\n&gt; above.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; It is an ugly conditional that there might be better way to\u003cbr\\/\u003e\\n&gt; formulate, so that policies don\'t have to look at the grody details\u003cbr\\/\u003e\\n&gt; like hasSeparateNorms. But I\'d still like the merge policies to be\u003cbr\\/\u003e\\n&gt; able to decide what optimize means at a high level.\u003c\\/p\u003e\\n\\n\u003cp\u003eAgreed: I too don\'t want to preclude variants to optimize like\u003cbr\\/\u003e\\n\\\"optimize to at most N segments\\\".  (Maybe we should add that method,\u003cbr\\/\u003e\\nnow, to IndexWriter, and fix MergePolicy to work with this?).\u003c\\/p\u003e\\n\\n\u003cp\u003eSo, yes, please at least factor this out into a base class.  In\u003cbr\\/\u003e\\n\u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e this was another copy\\/paste for me (ick).  I think there\u003cbr\\/\u003e\\nshould in fact be a default optimize() in the base class that does\u003cbr\\/\u003e\\nwhat current IndexWriter now does so that a MergePolicy need not\u003cbr\\/\u003e\\nimplement optimize at all.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\"\u003cbr\\/\u003e\\n&gt; &gt; which, if true, means that the MergePolicy must now pick a merge\u003cbr\\/\u003e\\n&gt; &gt; even if it didn\'t think it was time to. This would let us move\u003cbr\\/\u003e\\n&gt; &gt; that tricky while condition logic back into IndexWriter.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I didn\'t follow this. forced == optimize? If not, what does pick a\u003cbr\\/\u003e\\n&gt; merge mean? Not sure what LogDoc should do for merge(force=true) if\u003cbr\\/\u003e\\n&gt; it thinks everything is fine?\u003c\\/p\u003e\\n\\n\u003cp\u003eNo, forced would mean the merge policy must do a merge; whereas,\u003cbr\\/\u003e\\nnormally, it\'s free not to do a merge until it wants to.  Instead of\u003cbr\\/\u003e\\nboolean argument we could have two methods, one called \\\"merge\\\" (you\u003cbr\\/\u003e\\nmust merge) and one called \\\"maybeMerge\\\" or \\\"checkForMerges\\\".\u003c\\/p\u003e\\n\\n\u003cp\u003eIe, optimize is really a series of forced merges: we are merging\u003cbr\\/\u003e\\nsegments from different levels, N times, until we are down to 1\u003cbr\\/\u003e\\nsegment w\\/ no deletes, norms, etc.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Also, I think at some point we may want to have an optimize()\u003cbr\\/\u003e\\n&gt; &gt; method that takes an int parameter stating the max # segments in\u003cbr\\/\u003e\\n&gt; &gt; the resulting index.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think this is great functionality for a merge policy, but what\u003cbr\\/\u003e\\n&gt; about just making that part of the individual merge policy\u003cbr\\/\u003e\\n&gt; interface, rather than linked to IndexWriter? That was one goal of\u003cbr\\/\u003e\\n&gt; making a factored merge policy: that you could do these tweaks\u003cbr\\/\u003e\\n&gt; without changing IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, it\'s sort of awkward if you want to vary that max # segments.\u003cbr\\/\u003e\\nSay during the day you optimize down to 15 segments every time you\u003cbr\\/\u003e\\nupdate the index, but then at night you want to optimize down to 5.\u003cbr\\/\u003e\\nIf we don\'t add method to IndexWriter you then must have instance var\u003cbr\\/\u003e\\non your MergePolicy that you set, then you call optimize.  It\'s not\u003cbr\\/\u003e\\nclean since really it should be a parameter.\u003c\\/p\u003e\\n\\n\u003cp\u003eAnd, with the merge\\/maybeMerge separation above, every merge policy\u003cbr\\/\u003e\\ncould have a default implementation for optimize(int maxNumSegments)\u003cbr\\/\u003e\\n(in MergePolicy base class or in IndexWriter).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Can we support non-contiguous merges? If I understand it\u003cbr\\/\u003e\\n&gt; &gt; correctly, the MergeSpecification can express such a merge, it\'s\u003cbr\\/\u003e\\n&gt; &gt; just that the current IndexMerger (IndexWriter) cannot execute it,\u003cbr\\/\u003e\\n&gt; &gt; right? So we are at least not precluding fixing this in the\u003cbr\\/\u003e\\n&gt; &gt; future.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; As far as I\'ve seen so far, there are no barriers to non-contiguous\u003cbr\\/\u003e\\n&gt; merges. Maybe something will crop up that is, but in what I\'ve done,\u003cbr\\/\u003e\\n&gt; I haven\'t seen any.\u003c\\/p\u003e\\n\\n\u003cp\u003eWait: there is a barrier, right?  In IndexWriter.replace we don\'t do\u003cbr\\/\u003e\\nthe right thing with non-contiguous merges?  What I\'m asking is: is\u003cbr\\/\u003e\\nthat the only barrier?  Ie MergePolicy API will not need to change in\u003cbr\\/\u003e\\nthe future once we fix IndexWriter.replace to handle non-contiguous\u003cbr\\/\u003e\\nmerges?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; It confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can\u003cbr\\/\u003e\\n&gt; &gt; we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I suppose. I\'m not a big fan of the \\\"maybeFoo\\\" style of naming. I\u003cbr\\/\u003e\\n&gt; think of \\\"merge\\\" like \\\"optimize\\\": make it so \\/ idempotent. But I\'m\u003cbr\\/\u003e\\n&gt; certainly willing to write whatever people find clearest.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\" \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  It\'s\u003cbr\\/\u003e\\noverloaded now.\u003c\\/p\u003e\\n\\n\u003cp\u003eEG IndexMerger interface has a method called \\\"merge\\\" that is named\u003cbr\\/\u003e\\ncorrectly because it will specifically go a do the requested merge.\u003cbr\\/\u003e\\nSo does IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eThen, you have other \u003cspan class=\\\"error\\\"\u003e&#91;overloaded&#93;\u003c\\/span\u003e methods in LogDocMergePolicy called\u003cbr\\/\u003e\\n\\\"merge\\\" that are named appropriately (they will do a specific merge).\u003c\\/p\u003e\\n\\n\u003cp\u003eHow about \\\"checkForMerges()\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Instead of IndexWriter.releaseMergePolicy() can we have\u003cbr\\/\u003e\\n&gt; &gt; IndexWriter only close the merge policy if it was the one that had\u003cbr\\/\u003e\\n&gt; &gt; created it? (Similar to how IndexWriter closes the dir if it has\u003cbr\\/\u003e\\n&gt; &gt; opened it from a String or File, but does not close it if it was\u003cbr\\/\u003e\\n&gt; &gt; passed in).\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; This precludes\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; iw.setMergePolicy(new MyMergePolicy(...));\u003cbr\\/\u003e\\n&gt;      ...\u003cbr\\/\u003e\\n&gt; iw.close();\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The implementation\'s much cleaner using the semantics you describe,\u003cbr\\/\u003e\\n&gt; but I was thinking it\'d be better to optimize for the usability of the\u003cbr\\/\u003e\\n&gt; common client code case? \u003c\\/p\u003e\\n\\n\u003cp\u003eThe thing is, that method leaves IndexWriter in a broken state (null\u003cbr\\/\u003e\\nmergePolicy).  What if you keep adding docs after that then suddenly\u003cbr\\/\u003e\\nhit an NPE?\u003c\\/p\u003e\\n\\n\u003cp\u003eAlso, I\'m OK if people need to separately close their MergePolicy\u003cbr\\/\u003e\\ninstances: this is an advanced use of Lucene so it\'s OK to expect that\u003cbr\\/\u003e\\n(\\\"simple things should be simple; complex things should be possible\\\").\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe we could add a \\\"setMergePolicy(MergePolicy policy, boolean\u003cbr\\/\u003e\\ndoClose)\\\" and default doClose to true?\u003c\\/p\u003e\\n\\n\u003cp\u003eFinally: does MergePolicy really need a close()?  Is this overkill (at\u003cbr\\/\u003e\\nthis point)?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Well I think the current MergePolicy API (where the \\\"merge\\\" method\u003cbr\\/\u003e\\n&gt; calls IndexWriter.merge itself, must cascade itself, etc.) makes it\u003cbr\\/\u003e\\n&gt; hard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you\u003cbr\\/\u003e\\n&gt; could use to make any MergePolicy concurrent \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/help_16.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e. How would you do\u003cbr\\/\u003e\\n&gt; it?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I really haven\'t had time to go heads down on this (the old\u003cbr\\/\u003e\\n&gt; concurrent merge policy was a derived class rather than a wrapper\u003cbr\\/\u003e\\n&gt; class). But I was thinking that perhaps ConurrentMergePolicy would\u003cbr\\/\u003e\\n&gt; actually wrap IndexWriter as well as the serial merge policy, i.e.,\u003cbr\\/\u003e\\n&gt; implement IndexMerger (my biggest argument for IM at this\u003cbr\\/\u003e\\n&gt; point). But I haven\'t looked deeply at whether this will work but I\u003cbr\\/\u003e\\n&gt; think it has at least a chance.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I should know more about this is a day or two. \u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t see how it can work (building the generic concurrency wrapper\u003cbr\\/\u003e\\n\\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial control\\\",\u003cbr\\/\u003e\\neg, when it wants to cascade merges.  How will you return that thread\u003cbr\\/\u003e\\nback to IndexWriter?\u003c\\/p\u003e\\n\\n\u003cp\u003eAlso it feels like the wrong place for concurrency &#8211; I think\u003cbr\\/\u003e\\ngenerally for \\\"macro\\\" concurrency you want it higher up, not lower\u003cbr\\/\u003e\\ndown, in the call stack.\u003c\\/p\u003e\\n\\n\u003cp\u003eWith concurrency wrapper \\\"on the top\\\" it\'s able to easily take a merge\u003cbr\\/\u003e\\nrequest as returned by the policy, kick it off in the backrground, and\u003cbr\\/\u003e\\nimmediately return control of original thread back to IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eBut if you see a way to make it work \\\"on the bottom\\\", let\'s definitely\u003cbr\\/\u003e\\nexplore it &amp; understand the tradeoffs.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think you can still have state (as instance variables in your\u003cbr\\/\u003e\\n&gt; &gt; class)? How would this simplification restrict the space of merge\u003cbr\\/\u003e\\n&gt; &gt; policies?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; s\\/state\\/stack state\\/. Yeah, you can always unwind your loops and\u003cbr\\/\u003e\\n&gt; lift your recursions, put all that stack state into instance\u003cbr\\/\u003e\\n&gt; variables. But, well, yuck. I\'d like to make it easy to write simple\u003cbr\\/\u003e\\n&gt; merge policies and take up the heavy lifting elsewhere. Hopefully\u003cbr\\/\u003e\\n&gt; there will be more merge policies than index writers.\u003c\\/p\u003e\\n\\n\u003cp\u003eCan you give an example of the kind of \\\"state\\\" we\'re talking about?\u003cbr\\/\u003e\\nIs this just academic?\u003c\\/p\u003e\\n\\n\u003cp\u003eSince the segments change in an unpredictable way (as seen by\u003cbr\\/\u003e\\nMergePolicy) eg from addIndexes*, flushing, concurrent merge swapping\u003cbr\\/\u003e\\nthings at random times (thus requiring careful locking), etc, it seems\u003cbr\\/\u003e\\nlike you can\'t be keeping much state (stack or instance) that depends\u003cbr\\/\u003e\\non what segments are in the index?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Oh, no: ConcurrentMergePolicy would still call\u003cbr\\/\u003e\\n&gt; &gt; IndexWriter.merge(spec), just with a separate thread. And so all\u003cbr\\/\u003e\\n&gt; &gt; synchronization required is still inside IndexWriter (I think?).\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; That\'s my idea.\u003c\\/p\u003e\\n\\n\u003cp\u003eActually I was talking about my idea (to \\\"simplify MergePolicy.merge\u003cbr\\/\u003e\\nAPI\\\").  With the simplification (whereby MergePolicy.merge just\u003cbr\\/\u003e\\nreturns the MergeSpecification instead of driving the merge itself) I\u003cbr\\/\u003e\\nbelieve it\'s simple to make a concurrency wrapper around any merge\u003cbr\\/\u003e\\npolicy, and, have all necessary locking for SegmentInfos inside\u003cbr\\/\u003e\\nIndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; In fact, if we stick with the current MergePolicy API, aren\'t you\u003cbr\\/\u003e\\n&gt; &gt; going to have to put some locking into eg the LogDocMergePolicy\u003cbr\\/\u003e\\n&gt; &gt; when concurrent merges might be happening?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Yes and no. If CMP implements IndexMerger, I think we might be okay?\u003c\\/p\u003e\\n\\n\u003cp\u003eIf CMP implements IndexMerger you must have locking inside any\u003cbr\\/\u003e\\nMergePolicy that\'s calling into CMP?  Whereas with the simplified\u003cbr\\/\u003e\\nMergePolicy.merge API, no locking is necessary because IndexWriter\u003cbr\\/\u003e\\nwould lock segmentInfos whenever it calls MergePolicy.merge.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; In the previous iteration, I used derivation so that\u003cbr\\/\u003e\\n&gt; ConcurrentLogDocMergePolicy derived from the serial version but had\u003cbr\\/\u003e\\n&gt; the necessary threading. I agree that a wrapper is better solution\u003cbr\\/\u003e\\n&gt; if it can be made to work.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think it (concurrency wrapper around any merge policy) can be made\u003cbr\\/\u003e\\nto work, if we do simplify the MergePolicy.merge API.  I\'m not sure it\u003cbr\\/\u003e\\ncan be made to work if we don\'t, but if you have an approach we should\u003cbr\\/\u003e\\nwork through it!\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518435_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518435_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 12:48\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T12:48:18+0000\'\u003e08\\/Aug\\/07 12:48\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    New feedback: \\n\\n \\n\\t Are you going to fix all unit tests that call the now-deprecated \\n    APIs?  (You should still leave a few tests using the deprecated \\n    APIs to make sure they in fact continue to work, but most tests \\n    should not use the deprecated APIs). \\n \\n\\n\\n Responses to previous feedback: \\n\\n &gt; As an example, it\'s not a good idea for merge policies to be able to \\n&gt; access IndexWriter#segmentInfos directly. (That\'s a case I would \\n&gt; like to solve by making segmentInfos private, but I haven\'t looked \\n&gt; at that completely yet and even beyond that case, I\'d still like \\n&gt; merge policies to have a very clean interface with IWs.) \\n\\n Agreed, but the solution to that is to make segmentInfos private, not \\nto make a whole new interface.  Ie, this is an IndexWriter problem, so \\nwe should fix it in IndexWriter. \\n\\n &gt; &gt; While LogDocMergePolicy does need \\\"maxBufferedDocs\\\", I think, \\n&gt; &gt; instead, in IndexWriter\'s \\\"setMaxBufferedDocs()\\\" it should \\\"write \\n&gt; &gt; through\\\" to the LogDocMergePolicy if that is the merge policy in \\n&gt; &gt; use (and LogDocMergePolicy should store its own private \\n&gt; &gt; \\\"minMergeDocs\\\"). \\n&gt; \\n&gt; The thing here is that the merge policy has nothing to do with max \\n&gt; buffered docs, right? The code for buffering docs for the first \\n&gt; segment is wholly in the IndexWriter. LogDocMergePolicy happens to \\n&gt; need it (in its current incarnation) in order to handle the way the \\n&gt; log levels are computed. This could, of course, be changed. There\'s \\n&gt; nothing that says a merge policy has to look at these values, just \\n&gt; that they\'re available should the merge policy want to look. \\n\\n Exactly: these settings decide when a segment is flushed, so, why put \\nthem into IndexMerger interface?  They shouldn\'t have anything to with \\nmerging; I think they should be removed. \\n\\n For   LUCENE-845   I\'m working on a replacement for LogDocMergePolicy that \\ndoes not use maxBufferedDocs. \\n\\n &gt; I guess my idea was that the index writer was responsible for \\n&gt; handling the initial segment (with DocsWriter, if it wants) and also \\n&gt; to provide an indication to the merge policies how it was handling \\n&gt; them. \\n&gt; \\n&gt; It\'s possible to have the merge policy influence the first segment \\n&gt; size but that opens up a lot of issues. Does every merge policy then \\n&gt; have to know how to trade between buffering by doc count and \\n&gt; buffering by ram? I was hoping to avoid that. \\n\\n Yeah, I don\'t think merge policy should dictate flushing either; \\nespecially because app logic above IndexWriter can already easily call \\nflush() if necessary. \\n\\n &gt; &gt; In LogDocMergePolicy, it seems like the checking that\'s done for \\n&gt; &gt; whether a SegmentInfo is in a different directory, as well as the \\n&gt; &gt; subsequent copy to move it over to the IndexWriter\'s directory, \\n&gt; &gt; should not live in the MergePolicy? \\n&gt; \\n&gt; I see two parts to this. \\n&gt;  \\n&gt; First, I hesitate to make it not possible for merge policy to see \\n&gt; the directory information, i.e., remove \\n&gt; IndexMerger#getDirectory(). Copying a segment is one way to get it \\n&gt; into the current directory, but merging with other segments does \\n&gt; to. A merge policy could decide to go ahead and merge a bunch of \\n&gt; segments that are in other directories rather than just copy them \\n&gt; individually. Taking away getDirectory() removes that option. \\n\\n Agreed, a \\\"sophisticated\\\" merge policy would go and merge segments in \\nother directories.  But, it should not have to. \\n\\n I\'m not proposing making it \\\"not possible\\\"; I\'m proposing the merge \\npolicy is given IndexWriter at which point it can getDirectory() from \\nit.  (Ie the extra interface solely for this purpose is overkill). \\n\\n &gt; As to how to handle the case where single segments are copied, I \\n&gt; guess my main reason for leaving that in the merge policy would be \\n&gt; for simplicity. Seems nicer to have all segment amalgamation \\n&gt; management in one place, rather than some in one class and some in \\n&gt; another. Could be factored into an optional base merge policy for \\n&gt; derived classes to use as they might like. \\n\\n I don\'t see this as simpler: I see it as making the MergePolicy \\nwriter\'s job more complex.  I also see it as substantial duplicated \\ncode (I just had to copy\\/paste a bunch of code in working on my \\nMergePolicy in   LUCENE-845  ). \\n\\n I think factoring into a base class is an OK solution, but, it \\nshouldn\'t be MergePolicy\'s job to remember to call this final \\\"move \\nany segments in the wrong directory over\\\" code.  As long as its in one \\nplace and people don\'t have to copy\\/paste code between MergePolicy \\nsources. \\n\\n &gt; &gt; The \\\"checkOptimize\\\" method in LogDocMergePolicy seems like it \\n&gt; &gt; belongs back in IndexWriter: I think we don\'t want every \\n&gt; &gt; MergePolicy having to replicate that tricky while condition. \\n&gt; \\n&gt; The reason for not doing this was I can imagine different merge \\n&gt; policies having a different model of what optimize means. I can \\n&gt; imagine some policies that would not optimize everything down to a \\n&gt; single segment but instead obeyed a max segment size. But we could \\n&gt; factor the default conditional into an optional base class, as \\n&gt; above. \\n&gt; \\n&gt; It is an ugly conditional that there might be better way to \\n&gt; formulate, so that policies don\'t have to look at the grody details \\n&gt; like hasSeparateNorms. But I\'d still like the merge policies to be \\n&gt; able to decide what optimize means at a high level. \\n\\n Agreed: I too don\'t want to preclude variants to optimize like \\n\\\"optimize to at most N segments\\\".  (Maybe we should add that method, \\nnow, to IndexWriter, and fix MergePolicy to work with this?). \\n\\n So, yes, please at least factor this out into a base class.  In \\n  LUCENE-845   this was another copy\\/paste for me (ick).  I think there \\nshould in fact be a default optimize() in the base class that does \\nwhat current IndexWriter now does so that a MergePolicy need not \\nimplement optimize at all. \\n\\n &gt; &gt; Maybe we could change MergePolicy.merge to take a boolean \\\"forced\\\" \\n&gt; &gt; which, if true, means that the MergePolicy must now pick a merge \\n&gt; &gt; even if it didn\'t think it was time to. This would let us move \\n&gt; &gt; that tricky while condition logic back into IndexWriter. \\n&gt; \\n&gt; I didn\'t follow this. forced == optimize? If not, what does pick a \\n&gt; merge mean? Not sure what LogDoc should do for merge(force=true) if \\n&gt; it thinks everything is fine? \\n\\n No, forced would mean the merge policy must do a merge; whereas, \\nnormally, it\'s free not to do a merge until it wants to.  Instead of \\nboolean argument we could have two methods, one called \\\"merge\\\" (you \\nmust merge) and one called \\\"maybeMerge\\\" or \\\"checkForMerges\\\". \\n\\n Ie, optimize is really a series of forced merges: we are merging \\nsegments from different levels, N times, until we are down to 1 \\nsegment w\\/ no deletes, norms, etc. \\n\\n &gt; &gt; Also, I think at some point we may want to have an optimize() \\n&gt; &gt; method that takes an int parameter stating the max # segments in \\n&gt; &gt; the resulting index. \\n&gt; \\n&gt; I think this is great functionality for a merge policy, but what \\n&gt; about just making that part of the individual merge policy \\n&gt; interface, rather than linked to IndexWriter? That was one goal of \\n&gt; making a factored merge policy: that you could do these tweaks \\n&gt; without changing IndexWriter. \\n\\n Well, it\'s sort of awkward if you want to vary that max # segments. \\nSay during the day you optimize down to 15 segments every time you \\nupdate the index, but then at night you want to optimize down to 5. \\nIf we don\'t add method to IndexWriter you then must have instance var \\non your MergePolicy that you set, then you call optimize.  It\'s not \\nclean since really it should be a parameter. \\n\\n And, with the merge\\/maybeMerge separation above, every merge policy \\ncould have a default implementation for optimize(int maxNumSegments) \\n(in MergePolicy base class or in IndexWriter). \\n\\n &gt; &gt; Can we support non-contiguous merges? If I understand it \\n&gt; &gt; correctly, the MergeSpecification can express such a merge, it\'s \\n&gt; &gt; just that the current IndexMerger (IndexWriter) cannot execute it, \\n&gt; &gt; right? So we are at least not precluding fixing this in the \\n&gt; &gt; future. \\n&gt; \\n&gt; As far as I\'ve seen so far, there are no barriers to non-contiguous \\n&gt; merges. Maybe something will crop up that is, but in what I\'ve done, \\n&gt; I haven\'t seen any. \\n\\n Wait: there is a barrier, right?  In IndexWriter.replace we don\'t do \\nthe right thing with non-contiguous merges?  What I\'m asking is: is \\nthat the only barrier?  Ie MergePolicy API will not need to change in \\nthe future once we fix IndexWriter.replace to handle non-contiguous \\nmerges? \\n\\n &gt; &gt; It confuses me that MergePolicy has a method \\\"merge(...)\\\" &#8211; can \\n&gt; &gt; we rename it to \\\"maybeMerge(..)\\\" or \\\"checkForMerge(...)\\\"? \\n&gt; \\n&gt; I suppose. I\'m not a big fan of the \\\"maybeFoo\\\" style of naming. I \\n&gt; think of \\\"merge\\\" like \\\"optimize\\\": make it so \\/ idempotent. But I\'m \\n&gt; certainly willing to write whatever people find clearest. \\n\\n I\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\"    It\'s \\noverloaded now. \\n\\n EG IndexMerger interface has a method called \\\"merge\\\" that is named \\ncorrectly because it will specifically go a do the requested merge. \\nSo does IndexWriter. \\n\\n Then, you have other  &#91;overloaded&#93;  methods in LogDocMergePolicy called \\n\\\"merge\\\" that are named appropriately (they will do a specific merge). \\n\\n How about \\\"checkForMerges()\\\"? \\n\\n &gt; &gt; Instead of IndexWriter.releaseMergePolicy() can we have \\n&gt; &gt; IndexWriter only close the merge policy if it was the one that had \\n&gt; &gt; created it? (Similar to how IndexWriter closes the dir if it has \\n&gt; &gt; opened it from a String or File, but does not close it if it was \\n&gt; &gt; passed in). \\n&gt;  \\n&gt; This precludes \\n&gt;  \\n&gt; iw.setMergePolicy(new MyMergePolicy(...)); \\n&gt;      ... \\n&gt; iw.close(); \\n&gt; \\n&gt; The implementation\'s much cleaner using the semantics you describe, \\n&gt; but I was thinking it\'d be better to optimize for the usability of the \\n&gt; common client code case?  \\n\\n The thing is, that method leaves IndexWriter in a broken state (null \\nmergePolicy).  What if you keep adding docs after that then suddenly \\nhit an NPE? \\n\\n Also, I\'m OK if people need to separately close their MergePolicy \\ninstances: this is an advanced use of Lucene so it\'s OK to expect that \\n(\\\"simple things should be simple; complex things should be possible\\\"). \\n\\n Maybe we could add a \\\"setMergePolicy(MergePolicy policy, boolean \\ndoClose)\\\" and default doClose to true? \\n\\n Finally: does MergePolicy really need a close()?  Is this overkill (at \\nthis point)? \\n\\n &gt; &gt; Well I think the current MergePolicy API (where the \\\"merge\\\" method \\n&gt; calls IndexWriter.merge itself, must cascade itself, etc.) makes it \\n&gt; hard to build a generic ConcurrentMergePolicy \\\"wrapper\\\" that you \\n&gt; could use to make any MergePolicy concurrent  . How would you do \\n&gt; it? \\n&gt; \\n&gt; I really haven\'t had time to go heads down on this (the old \\n&gt; concurrent merge policy was a derived class rather than a wrapper \\n&gt; class). But I was thinking that perhaps ConurrentMergePolicy would \\n&gt; actually wrap IndexWriter as well as the serial merge policy, i.e., \\n&gt; implement IndexMerger (my biggest argument for IM at this \\n&gt; point). But I haven\'t looked deeply at whether this will work but I \\n&gt; think it has at least a chance. \\n&gt; \\n&gt; I should know more about this is a day or two.  \\n\\n I don\'t see how it can work (building the generic concurrency wrapper \\n\\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial control\\\", \\neg, when it wants to cascade merges.  How will you return that thread \\nback to IndexWriter? \\n\\n Also it feels like the wrong place for concurrency &#8211; I think \\ngenerally for \\\"macro\\\" concurrency you want it higher up, not lower \\ndown, in the call stack. \\n\\n With concurrency wrapper \\\"on the top\\\" it\'s able to easily take a merge \\nrequest as returned by the policy, kick it off in the backrground, and \\nimmediately return control of original thread back to IndexWriter. \\n\\n But if you see a way to make it work \\\"on the bottom\\\", let\'s definitely \\nexplore it &amp; understand the tradeoffs. \\n\\n &gt; &gt; I think you can still have state (as instance variables in your \\n&gt; &gt; class)? How would this simplification restrict the space of merge \\n&gt; &gt; policies? \\n&gt; \\n&gt; s\\/state\\/stack state\\/. Yeah, you can always unwind your loops and \\n&gt; lift your recursions, put all that stack state into instance \\n&gt; variables. But, well, yuck. I\'d like to make it easy to write simple \\n&gt; merge policies and take up the heavy lifting elsewhere. Hopefully \\n&gt; there will be more merge policies than index writers. \\n\\n Can you give an example of the kind of \\\"state\\\" we\'re talking about? \\nIs this just academic? \\n\\n Since the segments change in an unpredictable way (as seen by \\nMergePolicy) eg from addIndexes*, flushing, concurrent merge swapping \\nthings at random times (thus requiring careful locking), etc, it seems \\nlike you can\'t be keeping much state (stack or instance) that depends \\non what segments are in the index? \\n\\n &gt; &gt; Oh, no: ConcurrentMergePolicy would still call \\n&gt; &gt; IndexWriter.merge(spec), just with a separate thread. And so all \\n&gt; &gt; synchronization required is still inside IndexWriter (I think?). \\n&gt; \\n&gt; That\'s my idea. \\n\\n Actually I was talking about my idea (to \\\"simplify MergePolicy.merge \\nAPI\\\").  With the simplification (whereby MergePolicy.merge just \\nreturns the MergeSpecification instead of driving the merge itself) I \\nbelieve it\'s simple to make a concurrency wrapper around any merge \\npolicy, and, have all necessary locking for SegmentInfos inside \\nIndexWriter. \\n\\n &gt; &gt; In fact, if we stick with the current MergePolicy API, aren\'t you \\n&gt; &gt; going to have to put some locking into eg the LogDocMergePolicy \\n&gt; &gt; when concurrent merges might be happening? \\n&gt; \\n&gt; Yes and no. If CMP implements IndexMerger, I think we might be okay? \\n\\n If CMP implements IndexMerger you must have locking inside any \\nMergePolicy that\'s calling into CMP?  Whereas with the simplified \\nMergePolicy.merge API, no locking is necessary because IndexWriter \\nwould lock segmentInfos whenever it calls MergePolicy.merge. \\n\\n &gt; In the previous iteration, I used derivation so that \\n&gt; ConcurrentLogDocMergePolicy derived from the serial version but had \\n&gt; the necessary threading. I agree that a wrapper is better solution \\n&gt; if it can be made to work. \\n\\n I think it (concurrency wrapper around any merge policy) can be made \\nto work, if we do simplify the MergePolicy.merge API.  I\'m not sure it \\ncan be made to work if we don\'t, but if you have an approach we should \\nwork through it!              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518453\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518453&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518453\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518453_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518453_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 14:23\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T14:23:44+0000\'\u003e08\\/Aug\\/07 14:23\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOn 8\\/8\\/07, Michael McCandless (JIRA) &lt;jira@apache.org&gt; wrote:\u003cbr\\/\u003e\\n&gt; Actually I was talking about my idea (to \\\"simplify MergePolicy.merge\u003cbr\\/\u003e\\n&gt; API\\\").  With the simplification (whereby MergePolicy.merge just\u003cbr\\/\u003e\\n&gt; returns the MergeSpecification instead of driving the merge itself) I\u003cbr\\/\u003e\\n&gt; believe it\'s simple to make a concurrency wrapper around any merge\u003cbr\\/\u003e\\n&gt; policy, and, have all necessary locking for SegmentInfos inside\u003cbr\\/\u003e\\n&gt; IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eI agree with Mike. In fact, MergeSelector.select, which is the counterpart\u003cbr\\/\u003e\\nof MergePolicy.merge in the patch I submitted for concurrent merge,\u003cbr\\/\u003e\\nsimply returns a MergeSpecification. It\'s simple and sufficient to have\u003cbr\\/\u003e\\nall necessary lockings for SegmentInfos in one class, say IndexWriter.\u003cbr\\/\u003e\\nFor example, IndexWriter locks SegmentInfos when MergePolicy(MergeSelector)\u003cbr\\/\u003e\\npicks a merge spec. Another example, when a merge is finished, say\u003cbr\\/\u003e\\nIndexWriter.checkin is called which locks SegmentInfos and replaces\u003cbr\\/\u003e\\nthe source segment infos with the target segment info.\u003c\\/p\u003e\\n\\n\\n\u003cp\u003eOn 8\\/7\\/07, Steven Parkes (JIRA) &lt;jira@apache.org&gt; wrote:\u003cbr\\/\u003e\\n&gt; The synchronization is still tricky, since parts of segmentInfos are\u003cbr\\/\u003e\\n&gt; getting changed at various times and there are references and\\/or\u003cbr\\/\u003e\\n&gt; copies of it other places. And as Ning pointed out to me, we also\u003cbr\\/\u003e\\n&gt; have to deal with buffered delete terms. I\'d say I got about 80% of\u003cbr\\/\u003e\\n&gt;the way there on the last go around. I\'m hoping to get all the way\u003cbr\\/\u003e\\n&gt; this time.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt just occurred to me that there is a neat way to handle deletes that\u003cbr\\/\u003e\\nare flushed during a concurrent merge. For example, MergePolicy\u003cbr\\/\u003e\\ndecides to merge segments B and C, with B\'s delete file 0001 and\u003cbr\\/\u003e\\nC\'s 100. When the concurrent merge finishes, B\'s delete file becomes\u003cbr\\/\u003e\\n0011 and C\'s 110. We do a simple computation on the delete bit\u003cbr\\/\u003e\\nvectors and check in the merged segment with delete file 00110.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518453_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518453_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 14:23\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T14:23:44+0000\'\u003e08\\/Aug\\/07 14:23\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    On 8\\/8\\/07, Michael McCandless (JIRA) &lt;jira@apache.org&gt; wrote: \\n&gt; Actually I was talking about my idea (to \\\"simplify MergePolicy.merge \\n&gt; API\\\").  With the simplification (whereby MergePolicy.merge just \\n&gt; returns the MergeSpecification instead of driving the merge itself) I \\n&gt; believe it\'s simple to make a concurrency wrapper around any merge \\n&gt; policy, and, have all necessary locking for SegmentInfos inside \\n&gt; IndexWriter. \\n\\n I agree with Mike. In fact, MergeSelector.select, which is the counterpart \\nof MergePolicy.merge in the patch I submitted for concurrent merge, \\nsimply returns a MergeSpecification. It\'s simple and sufficient to have \\nall necessary lockings for SegmentInfos in one class, say IndexWriter. \\nFor example, IndexWriter locks SegmentInfos when MergePolicy(MergeSelector) \\npicks a merge spec. Another example, when a merge is finished, say \\nIndexWriter.checkin is called which locks SegmentInfos and replaces \\nthe source segment infos with the target segment info. \\n\\n\\n On 8\\/7\\/07, Steven Parkes (JIRA) &lt;jira@apache.org&gt; wrote: \\n&gt; The synchronization is still tricky, since parts of segmentInfos are \\n&gt; getting changed at various times and there are references and\\/or \\n&gt; copies of it other places. And as Ning pointed out to me, we also \\n&gt; have to deal with buffered delete terms. I\'d say I got about 80% of \\n&gt;the way there on the last go around. I\'m hoping to get all the way \\n&gt; this time. \\n\\n It just occurred to me that there is a neat way to handle deletes that \\nare flushed during a concurrent merge. For example, MergePolicy \\ndecides to merge segments B and C, with B\'s delete file 0001 and \\nC\'s 100. When the concurrent merge finishes, B\'s delete file becomes \\n0011 and C\'s 110. We do a simple computation on the delete bit \\nvectors and check in the merged segment with delete file 00110.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518486\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518486&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518486\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518486_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518486_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 16:02\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T16:02:47+0000\'\u003e08\\/Aug\\/07 16:02\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eThe following comments are about the impact on merge if we add\u003cbr\\/\u003e\\n\\\"deleteDocument(int doc)\\\" (and deprecate IndexModifier). Since it\u003cbr\\/\u003e\\nconcerns the topic in this issue, I also post it here to get your opinions.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m thinking about the impact of adding \\\"deleteDocument(int doc)\\\" on\u003cbr\\/\u003e\\n\u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e, especially on concurrent merge. The semantics of\u003cbr\\/\u003e\\n\\\"deleteDocument(int doc)\\\" is that the document to delete is specified\u003cbr\\/\u003e\\nby the document id on the index at the time of the call. When a merge\u003cbr\\/\u003e\\nis finished and the result is being checked into IndexWriter\'s\u003cbr\\/\u003e\\nSegmentInfos, document ids may change. Therefore, it may be necessary\u003cbr\\/\u003e\\nto flush buffered delete doc ids (thus buffered docs and delete terms\u003cbr\\/\u003e\\nas well) before a merge result is checked in.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe flush is not necessary if there is no buffered delete doc ids. I\u003cbr\\/\u003e\\ndon\'t think it should be the reason not to support \\\"deleteDocument(int\u003cbr\\/\u003e\\ndoc)\\\" in IndexWriter. But its impact on concurrent merge is a concern.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518486_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518486_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 16:02\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T16:02:47+0000\'\u003e08\\/Aug\\/07 16:02\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    The following comments are about the impact on merge if we add \\n\\\"deleteDocument(int doc)\\\" (and deprecate IndexModifier). Since it \\nconcerns the topic in this issue, I also post it here to get your opinions. \\n\\n I\'m thinking about the impact of adding \\\"deleteDocument(int doc)\\\" on \\n  LUCENE-847  , especially on concurrent merge. The semantics of \\n\\\"deleteDocument(int doc)\\\" is that the document to delete is specified \\nby the document id on the index at the time of the call. When a merge \\nis finished and the result is being checked into IndexWriter\'s \\nSegmentInfos, document ids may change. Therefore, it may be necessary \\nto flush buffered delete doc ids (thus buffered docs and delete terms \\nas well) before a merge result is checked in. \\n\\n The flush is not necessary if there is no buffered delete doc ids. I \\ndon\'t think it should be the reason not to support \\\"deleteDocument(int \\ndoc)\\\" in IndexWriter. But its impact on concurrent merge is a concern.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518508\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518508&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518508\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518508_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518508_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 17:09\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T17:09:29+0000\'\u003e08\\/Aug\\/07 17:09\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; It just occurred to me that there is a neat way to handle deletes\u003cbr\\/\u003e\\n&gt; that are flushed during a concurrent merge. For example, MergePolicy\u003cbr\\/\u003e\\n&gt; decides to merge segments B and C, with B\'s delete file 0001 and C\'s\u003cbr\\/\u003e\\n&gt; 100. When the concurrent merge finishes, B\'s delete file becomes\u003cbr\\/\u003e\\n&gt; 0011 and C\'s 110. We do a simple computation on the delete bit\u003cbr\\/\u003e\\n&gt; vectors and check in the merged segment with delete file 00110\u003c\\/p\u003e\\n\\n\u003cp\u003eExcellent!  This lets you efficiently merge in the additional deletes\u003cbr\\/\u003e\\n(if any) that were flushed against each of the merged segments after\u003cbr\\/\u003e\\nthe merge had begun.  Furthermore, I think this is all contained\u003cbr\\/\u003e\\nwithin IndexWriter, right?\u003c\\/p\u003e\\n\\n\u003cp\u003eIe when we go to \\\"replace\\/checkin\\\" the newly merged segment, this\u003cbr\\/\u003e\\n\\\"merge newly flushed deletes\\\" would execute at that time.  And, I\u003cbr\\/\u003e\\nthink, we would block flushes while this is happening, but\u003cbr\\/\u003e\\naddDocument\\/deleteDocument\\/updateDocument would still be allowed?\u003c\\/p\u003e\\n\\n\u003cp\u003eIt should in fact be quite fast to run since delete BitVectors is all\u003cbr\\/\u003e\\nin RAM.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I\'m thinking about the impact of adding \\\"deleteDocument(int doc)\\\" on\u003cbr\\/\u003e\\n&gt; \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e, especially on concurrent merge. The semantics of\u003cbr\\/\u003e\\n&gt; \\\"deleteDocument(int doc)\\\" is that the document to delete is\u003cbr\\/\u003e\\n&gt; specified by the document id on the index at the time of the\u003cbr\\/\u003e\\n&gt; call. When a merge is finished and the result is being checked into\u003cbr\\/\u003e\\n&gt; IndexWriter\'s SegmentInfos, document ids may change. Therefore, it\u003cbr\\/\u003e\\n&gt; may be necessary to flush buffered delete doc ids (thus buffered\u003cbr\\/\u003e\\n&gt; docs and delete terms as well) before a merge result is checked in.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The flush is not necessary if there is no buffered delete doc ids. I\u003cbr\\/\u003e\\n&gt; don\'t think it should be the reason not to support\u003cbr\\/\u003e\\n&gt; \\\"deleteDocument(int doc)\\\" in IndexWriter. But its impact on\u003cbr\\/\u003e\\n&gt; concurrent merge is a concern.\u003c\\/p\u003e\\n\\n\u003cp\u003eCouldn\'t we also just update the docIDs of pending deletes, and not\u003cbr\\/\u003e\\nflush?  Ie we know the mapping of old -&gt; new docID caused by the\u003cbr\\/\u003e\\nmerge, so we can run through all deleted docIDs and remap?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12518508_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518508_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 17:09\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T17:09:29+0000\'\u003e08\\/Aug\\/07 17:09\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; It just occurred to me that there is a neat way to handle deletes \\n&gt; that are flushed during a concurrent merge. For example, MergePolicy \\n&gt; decides to merge segments B and C, with B\'s delete file 0001 and C\'s \\n&gt; 100. When the concurrent merge finishes, B\'s delete file becomes \\n&gt; 0011 and C\'s 110. We do a simple computation on the delete bit \\n&gt; vectors and check in the merged segment with delete file 00110 \\n\\n Excellent!  This lets you efficiently merge in the additional deletes \\n(if any) that were flushed against each of the merged segments after \\nthe merge had begun.  Furthermore, I think this is all contained \\nwithin IndexWriter, right? \\n\\n Ie when we go to \\\"replace\\/checkin\\\" the newly merged segment, this \\n\\\"merge newly flushed deletes\\\" would execute at that time.  And, I \\nthink, we would block flushes while this is happening, but \\naddDocument\\/deleteDocument\\/updateDocument would still be allowed? \\n\\n It should in fact be quite fast to run since delete BitVectors is all \\nin RAM. \\n\\n &gt; I\'m thinking about the impact of adding \\\"deleteDocument(int doc)\\\" on \\n&gt;   LUCENE-847  , especially on concurrent merge. The semantics of \\n&gt; \\\"deleteDocument(int doc)\\\" is that the document to delete is \\n&gt; specified by the document id on the index at the time of the \\n&gt; call. When a merge is finished and the result is being checked into \\n&gt; IndexWriter\'s SegmentInfos, document ids may change. Therefore, it \\n&gt; may be necessary to flush buffered delete doc ids (thus buffered \\n&gt; docs and delete terms as well) before a merge result is checked in. \\n&gt; \\n&gt; The flush is not necessary if there is no buffered delete doc ids. I \\n&gt; don\'t think it should be the reason not to support \\n&gt; \\\"deleteDocument(int doc)\\\" in IndexWriter. But its impact on \\n&gt; concurrent merge is a concern. \\n\\n Couldn\'t we also just update the docIDs of pending deletes, and not \\nflush?  Ie we know the mapping of old -&gt; new docID caused by the \\nmerge, so we can run through all deleted docIDs and remap?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12518520\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12518520&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12518520\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518520_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518520_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 17:48\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T17:48:34+0000\'\u003e08\\/Aug\\/07 17:48\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Furthermore, I think this is all contained within IndexWriter, right?\u003cbr\\/\u003e\\n&gt; Ie when we go to \\\"replace\\/checkin\\\" the newly merged segment, this\u003cbr\\/\u003e\\n&gt; \\\"merge newly flushed deletes\\\" would execute at that time. And, I\u003cbr\\/\u003e\\n&gt; think, we would block flushes while this is happening, but\u003cbr\\/\u003e\\n&gt; addDocument\\/deleteDocument\\/updateDocument would still be allowed?\u003c\\/p\u003e\\n\\n\u003cp\u003eYes and yes. \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Couldn\'t we also just update the docIDs of pending deletes, and not\u003cbr\\/\u003e\\n&gt; flush? Ie we know the mapping of old -&gt; new docID caused by the\u003cbr\\/\u003e\\n&gt; merge, so we can run through all deleted docIDs and remap? \u003c\\/p\u003e\\n\\n\u003cp\u003eHmm, I was worried quite a number of delete docIDs could be buffered,\u003cbr\\/\u003e\\nbut I guess it\'s still better than having to do a flush. So yes, this is better!\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12518520_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12518520_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Aug\\/07 17:48\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-08T17:48:34+0000\'\u003e08\\/Aug\\/07 17:48\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Furthermore, I think this is all contained within IndexWriter, right? \\n&gt; Ie when we go to \\\"replace\\/checkin\\\" the newly merged segment, this \\n&gt; \\\"merge newly flushed deletes\\\" would execute at that time. And, I \\n&gt; think, we would block flushes while this is happening, but \\n&gt; addDocument\\/deleteDocument\\/updateDocument would still be allowed? \\n\\n Yes and yes.   \\n\\n &gt; Couldn\'t we also just update the docIDs of pending deletes, and not \\n&gt; flush? Ie we know the mapping of old -&gt; new docID caused by the \\n&gt; merge, so we can run through all deleted docIDs and remap?  \\n\\n Hmm, I was worried quite a number of delete docIDs could be buffered, \\nbut I guess it\'s still better than having to do a flush. So yes, this is better!              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12519790\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12519790&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12519790\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12519790_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12519790_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Aug\\/07 21:49\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-14T21:49:25+0000\'\u003e14\\/Aug\\/07 21:49\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tAre you going to fix all unit tests that call the now-deprecated APIs?\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah. Thanks for the reminder.\u003c\\/p\u003e\\n\\n\u003cp\u003eAs to the IndexWriter vs. IndexMerger issue, I still think having the interface is useful if not only that it makes my testing much easier. I have a MockIndexMerger that implements only the functions in the interface and therefore I can test merge policies without creating a writer. For me this has been a big win ...\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tExactly: these settings decide when a segment is flushed, so, why put\u003cbr\\/\u003e\\n\\tthem into IndexMerger interface?  They shouldn\'t have anything to with\u003cbr\\/\u003e\\n\\tmerging; I think they should be removed.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tFor \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e I\'m working on a replacement for LogDocMergePolicy that\u003cbr\\/\u003e\\n\\tdoes not use maxBufferedDocs.\u003c\\/p\u003e\\n\\n\u003cp\u003eI can see that one could write a merge policy that didn\'t have any idea of how the initial buffering was done, but I worry about precluding it. Maybe the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e patch will show a strong enough pattern to believe no merge policies will need it?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think factoring into a base class is an OK solution, but, it\u003cbr\\/\u003e\\n\\tshouldn\'t be MergePolicy\'s job to remember to call this final \\\"move\u003cbr\\/\u003e\\n\\tany segments in the wrong directory over\\\" code.  As long as its in one\u003cbr\\/\u003e\\n\\tplace and people don\'t have to copy\\/paste code between MergePolicy\u003cbr\\/\u003e\\n\\tsources.\u003c\\/p\u003e\\n\\n\u003cp\u003eIn the case of concurrent merges, I think this gets more complicated. When do you do those directory copies? I think you can\'t do them at the return from the merge policy because the merge policy may want to do them, but later.\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t think IndexWriter has enough information to know when the copies need to done. Doubly so if we have concurrent merges?\u003c\\/p\u003e\\n\\n\u003cp\u003eI still stand by it should be the merge policy making the choice. You could have the code in IndexWriter too, but then there\'d be duplicate code. To put the code only in IndexWriter removes the choice from the merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think there\u003cbr\\/\u003e\\n\\tshould in fact be a default optimize() in the base class that does\u003cbr\\/\u003e\\n\\twhat current IndexWriter now does so that a MergePolicy need not\u003cbr\\/\u003e\\n\\timplement optimize at all.\u003c\\/p\u003e\\n\\n\u003cp\u003eIt\'d be nice, but I don\'t know how to do it: the merge factor is not generic, so I don\'t know how to implement the loop generically.\u003c\\/p\u003e\\n\\n\u003cp\u003eAh ... I see: with your forced merge ... hmmm.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tNo, forced would mean the merge policy must do a merge; whereas,\u003cbr\\/\u003e\\n\\tnormally, it\'s free not to do a merge until it wants to.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmmm ...\u003c\\/p\u003e\\n\\n\u003cp\u003eI think adding a forced merge concept here is new ... If it\'s simply to support optimize, I\'m not sure I find it too compelling. LogDoc as it stands uses different algorithms for incremental merges and optimize, so there\'s not too much of a concept of forced merges vs. optional merges to be factored out. So I guess I\'m not seeing a strong compelling case for creating it?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWell, it\'s sort of awkward if you want to vary that max # segments.\u003cbr\\/\u003e\\n\\tSay during the day you optimize down to 15 segments every time you\u003cbr\\/\u003e\\n\\tupdate the index, but then at night you want to optimize down to 5.\u003cbr\\/\u003e\\n\\tIf we don\'t add method to IndexWriter you then must have instance var\u003cbr\\/\u003e\\n\\ton your MergePolicy that you set, then you call optimize.  It\'s not\u003cbr\\/\u003e\\n\\tclean since really it should be a parameter.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, I don\'t know if I buy the argument that it should be a parameter. The merge policy has lots of state like docs\\/seg. I don\'t really see why segs\\/optimize is different.\u003c\\/p\u003e\\n\\n\u003cp\u003eMy main reason for not wanting put this into IndexWriter is then every merge policy must support it.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWait: there is a barrier, right?  In IndexWriter.replace we don\'t do\u003cbr\\/\u003e\\n\\tthe right thing with non-contiguous merges?\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, I meant that I\'m not aware of any barriers except fixing IndexWriter#replace, in other words, I\'m not aware of any other places where non-contiguity would cause a failure.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\" \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  It\'s\u003cbr\\/\u003e\\n\\toverloaded now.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tEG IndexMerger interface has a method called \\\"merge\\\" that is named\u003cbr\\/\u003e\\n\\tcorrectly because it will specifically go a do the requested merge.\u003cbr\\/\u003e\\n\\tSo does IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tThen, you have other \u003cspan class=\\\"error\\\"\u003e&#91;overloaded&#93;\u003c\\/span\u003e methods in LogDocMergePolicy called\u003cbr\\/\u003e\\n\\t\\\"merge\\\" that are named appropriately (they will do a specific merge).\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tHow about \\\"checkForMerges()\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t find it ambiguous based on class and argument type. It\'s all personal, of course.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'d definitely prefer maybe over checkFor because that sounds like a predicate.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tMaybe we could add a \\\"setMergePolicy(MergePolicy policy, boolean\u003cbr\\/\u003e\\n\\tdoClose)\\\" and default doClose to true?\u003c\\/p\u003e\\n\\n\u003cp\u003eThat sounds good.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tFinally: does MergePolicy really need a close()?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think so. The concurrent merge policy maintains all sorts of state.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI don\'t see how it can work (building the generic concurrency wrapper\u003cbr\\/\u003e\\n\\t\\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial control\\\",\u003cbr\\/\u003e\\n\\teg, when it wants to cascade merges.  How will you return that thread\u003cbr\\/\u003e\\n\\tback to IndexWriter?\u003c\\/p\u003e\\n\\n\u003cp\u003eSo this is how it looks now: the concurrent merge policy is both a merge policy and an index merger. The serial merge policy knows nothing about it other than it does not get IndexWriter as its merge.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe index writer wants its merge, so it does it merge\\/maybeMerge call on the concurrent merge policy. The CMP calls merge on the serial policy, but substitutes itself for the merger rather than IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe serial merge policy goes on its merry way, looking for merges to do (in the current model, this is a loop; more on that in a minute). Each time it has a subset of segments to merge, it calls merger.merge(...).\u003c\\/p\u003e\\n\\n\u003cp\u003eAt this point, the concurrent merge policy takes over again. It looks at the segments to be merged and other segments being processed by all existing merge threads and determines if there\'s a conflict (a request to merge a segment that\'s currently in a merge). If there\'s no conflict, it starts a merge thread and calls IndexWriter#merge on the thread. The original calling thread returns immediately. (I have a few ideas how to handle conflicts, the simplest of which is to wait for the conflicting merge and the restart the serial merge, e.g., revert to serial).\u003c\\/p\u003e\\n\\n\u003cp\u003eThis seems to work pretty well, so far. The only difference in API for the serial merges is that the merge operation can\'t return the number of documents in the result (since it isn\'t known how many docs will be deleted).   \u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWith concurrency wrapper \\\"on the top\\\" it\'s able to easily take a merge\u003cbr\\/\u003e\\n\\trequest as returned by the policy, kick it off in the backrground, and\u003cbr\\/\u003e\\n\\timmediately return control of original thread back to IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eWhat I don\'t know how to do with this is figure out how to do a bunch of merges. Lets say I have two levels in LogDoc that are merge worthy. If I call LogDoc, it\'ll return the lower level. That\'s all good. But what about doing the higher level in parallel? If I call LogDoc again, it\'s going to return the lower level again because it knows nothing about the current merge going on.\u003c\\/p\u003e\\n\\n\u003cp\u003eLogDoc already does things in a loop: it\'s pretty much set up to call all possible merges at one time (if they return immediately).\u003c\\/p\u003e\\n\\n\u003cp\u003eIt would be possible to have it return a vector of segmentInfo subsets, but I don\'t see the gain (and it doesn\'t work out as well for my putative conflict resolution).\u003c\\/p\u003e\\n\\n\u003cp\u003e\\thave all necessary locking for SegmentInfos inside\u003cbr\\/\u003e\\n\\tIndexWriter\u003c\\/p\u003e\\n\\n\u003cp\u003eThis was a red-herring on my part. All the \\\"segmentInfos locking\\\" has always been in IndexWriter. That\'s note exactly sufficient. The fundamental issue is that IndexWriter#merge has to operate without a lock on IndexWriter. At some point, I was thinking that meant it would have to lock SegmentInfos but that\'s ludicrous, actually. It\'s sufficient for IndexWriter#replace to be synchronized.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tIf CMP implements IndexMerger you must have locking inside any\u003cbr\\/\u003e\\n\\tMergePolicy that\'s calling into CMP?\u003c\\/p\u003e\\n\\n\u003cp\u003eNo. CMP does it\'s own locking (for purposes of thread management) but the serial merge policies no nothing of this (and they can expect to be called synchronously).\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12519790_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12519790_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Aug\\/07 21:49\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-14T21:49:25+0000\'\u003e14\\/Aug\\/07 21:49\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tAre you going to fix all unit tests that call the now-deprecated APIs? \\n\\n Yeah. Thanks for the reminder. \\n\\n As to the IndexWriter vs. IndexMerger issue, I still think having the interface is useful if not only that it makes my testing much easier. I have a MockIndexMerger that implements only the functions in the interface and therefore I can test merge policies without creating a writer. For me this has been a big win ... \\n\\n \\tExactly: these settings decide when a segment is flushed, so, why put \\n\\tthem into IndexMerger interface?  They shouldn\'t have anything to with \\n\\tmerging; I think they should be removed. \\n\\n \\tFor   LUCENE-845   I\'m working on a replacement for LogDocMergePolicy that \\n\\tdoes not use maxBufferedDocs. \\n\\n I can see that one could write a merge policy that didn\'t have any idea of how the initial buffering was done, but I worry about precluding it. Maybe the   LUCENE-845   patch will show a strong enough pattern to believe no merge policies will need it? \\n\\n \\tI think factoring into a base class is an OK solution, but, it \\n\\tshouldn\'t be MergePolicy\'s job to remember to call this final \\\"move \\n\\tany segments in the wrong directory over\\\" code.  As long as its in one \\n\\tplace and people don\'t have to copy\\/paste code between MergePolicy \\n\\tsources. \\n\\n In the case of concurrent merges, I think this gets more complicated. When do you do those directory copies? I think you can\'t do them at the return from the merge policy because the merge policy may want to do them, but later. \\n\\n I don\'t think IndexWriter has enough information to know when the copies need to done. Doubly so if we have concurrent merges? \\n\\n I still stand by it should be the merge policy making the choice. You could have the code in IndexWriter too, but then there\'d be duplicate code. To put the code only in IndexWriter removes the choice from the merge policy. \\n\\n \\tI think there \\n\\tshould in fact be a default optimize() in the base class that does \\n\\twhat current IndexWriter now does so that a MergePolicy need not \\n\\timplement optimize at all. \\n\\n It\'d be nice, but I don\'t know how to do it: the merge factor is not generic, so I don\'t know how to implement the loop generically. \\n\\n Ah ... I see: with your forced merge ... hmmm. \\n\\n \\tNo, forced would mean the merge policy must do a merge; whereas, \\n\\tnormally, it\'s free not to do a merge until it wants to. \\n\\n Hmmmm ... \\n\\n I think adding a forced merge concept here is new ... If it\'s simply to support optimize, I\'m not sure I find it too compelling. LogDoc as it stands uses different algorithms for incremental merges and optimize, so there\'s not too much of a concept of forced merges vs. optional merges to be factored out. So I guess I\'m not seeing a strong compelling case for creating it? \\n\\n \\tWell, it\'s sort of awkward if you want to vary that max # segments. \\n\\tSay during the day you optimize down to 15 segments every time you \\n\\tupdate the index, but then at night you want to optimize down to 5. \\n\\tIf we don\'t add method to IndexWriter you then must have instance var \\n\\ton your MergePolicy that you set, then you call optimize.  It\'s not \\n\\tclean since really it should be a parameter. \\n\\n Well, I don\'t know if I buy the argument that it should be a parameter. The merge policy has lots of state like docs\\/seg. I don\'t really see why segs\\/optimize is different. \\n\\n My main reason for not wanting put this into IndexWriter is then every merge policy must support it. \\n\\n \\tWait: there is a barrier, right?  In IndexWriter.replace we don\'t do \\n\\tthe right thing with non-contiguous merges? \\n\\n Yeah, I meant that I\'m not aware of any barriers except fixing IndexWriter#replace, in other words, I\'m not aware of any other places where non-contiguity would cause a failure. \\n\\n \\tI\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\"    It\'s \\n\\toverloaded now. \\n\\n \\tEG IndexMerger interface has a method called \\\"merge\\\" that is named \\n\\tcorrectly because it will specifically go a do the requested merge. \\n\\tSo does IndexWriter. \\n\\n \\tThen, you have other  &#91;overloaded&#93;  methods in LogDocMergePolicy called \\n\\t\\\"merge\\\" that are named appropriately (they will do a specific merge). \\n\\n \\tHow about \\\"checkForMerges()\\\"? \\n\\n I don\'t find it ambiguous based on class and argument type. It\'s all personal, of course. \\n\\n I\'d definitely prefer maybe over checkFor because that sounds like a predicate. \\n\\n \\tMaybe we could add a \\\"setMergePolicy(MergePolicy policy, boolean \\n\\tdoClose)\\\" and default doClose to true? \\n\\n That sounds good. \\n\\n \\tFinally: does MergePolicy really need a close()? \\n\\n I think so. The concurrent merge policy maintains all sorts of state. \\n\\n \\tI don\'t see how it can work (building the generic concurrency wrapper \\n\\t\\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial control\\\", \\n\\teg, when it wants to cascade merges.  How will you return that thread \\n\\tback to IndexWriter? \\n\\n So this is how it looks now: the concurrent merge policy is both a merge policy and an index merger. The serial merge policy knows nothing about it other than it does not get IndexWriter as its merge. \\n\\n The index writer wants its merge, so it does it merge\\/maybeMerge call on the concurrent merge policy. The CMP calls merge on the serial policy, but substitutes itself for the merger rather than IndexWriter. \\n\\n The serial merge policy goes on its merry way, looking for merges to do (in the current model, this is a loop; more on that in a minute). Each time it has a subset of segments to merge, it calls merger.merge(...). \\n\\n At this point, the concurrent merge policy takes over again. It looks at the segments to be merged and other segments being processed by all existing merge threads and determines if there\'s a conflict (a request to merge a segment that\'s currently in a merge). If there\'s no conflict, it starts a merge thread and calls IndexWriter#merge on the thread. The original calling thread returns immediately. (I have a few ideas how to handle conflicts, the simplest of which is to wait for the conflicting merge and the restart the serial merge, e.g., revert to serial). \\n\\n This seems to work pretty well, so far. The only difference in API for the serial merges is that the merge operation can\'t return the number of documents in the result (since it isn\'t known how many docs will be deleted).    \\n\\n \\tWith concurrency wrapper \\\"on the top\\\" it\'s able to easily take a merge \\n\\trequest as returned by the policy, kick it off in the backrground, and \\n\\timmediately return control of original thread back to IndexWriter. \\n\\n What I don\'t know how to do with this is figure out how to do a bunch of merges. Lets say I have two levels in LogDoc that are merge worthy. If I call LogDoc, it\'ll return the lower level. That\'s all good. But what about doing the higher level in parallel? If I call LogDoc again, it\'s going to return the lower level again because it knows nothing about the current merge going on. \\n\\n LogDoc already does things in a loop: it\'s pretty much set up to call all possible merges at one time (if they return immediately). \\n\\n It would be possible to have it return a vector of segmentInfo subsets, but I don\'t see the gain (and it doesn\'t work out as well for my putative conflict resolution). \\n\\n \\thave all necessary locking for SegmentInfos inside \\n\\tIndexWriter \\n\\n This was a red-herring on my part. All the \\\"segmentInfos locking\\\" has always been in IndexWriter. That\'s note exactly sufficient. The fundamental issue is that IndexWriter#merge has to operate without a lock on IndexWriter. At some point, I was thinking that meant it would have to lock SegmentInfos but that\'s ludicrous, actually. It\'s sufficient for IndexWriter#replace to be synchronized. \\n\\n \\tIf CMP implements IndexMerger you must have locking inside any \\n\\tMergePolicy that\'s calling into CMP? \\n\\n No. CMP does it\'s own locking (for purposes of thread management) but the serial merge policies no nothing of this (and they can expect to be called synchronously).              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12519793\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12519793&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12519793\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12519793_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12519793_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Aug\\/07 21:52\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-14T21:52:07+0000\'\u003e14\\/Aug\\/07 21:52\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tIt just occurred to me that there is a neat way to handle deletes that\u003cbr\\/\u003e\\n\\tare flushed during a concurrent merge. For example, MergePolicy\u003cbr\\/\u003e\\n\\tdecides to merge segments B and C, with B\'s delete file 0001 and\u003cbr\\/\u003e\\n\\tC\'s 100. When the concurrent merge finishes, B\'s delete file becomes\u003cbr\\/\u003e\\n\\t0011 and C\'s 110. We do a simple computation on the delete bit\u003cbr\\/\u003e\\n\\tvectors and check in the merged segment with delete file 00110.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, that makes my life much easier. Now I don\'t have to figure out what to do, just have to make it so ...\u003c\\/p\u003e\\n\\n\u003cp\u003eThanks!\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12519793_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12519793_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Aug\\/07 21:52\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-14T21:52:07+0000\'\u003e14\\/Aug\\/07 21:52\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tIt just occurred to me that there is a neat way to handle deletes that \\n\\tare flushed during a concurrent merge. For example, MergePolicy \\n\\tdecides to merge segments B and C, with B\'s delete file 0001 and \\n\\tC\'s 100. When the concurrent merge finishes, B\'s delete file becomes \\n\\t0011 and C\'s 110. We do a simple computation on the delete bit \\n\\tvectors and check in the merged segment with delete file 00110. \\n\\n Well, that makes my life much easier. Now I don\'t have to figure out what to do, just have to make it so ... \\n\\n Thanks!              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520071\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520071&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520071\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520071_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520071_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'15\\/Aug\\/07 19:32\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-15T19:32:29+0000\'\u003e15\\/Aug\\/07 19:32\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eUpdated patch:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eDon\'t call deprecated methods\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003enote: currently renamed with \\\"_\\\" prepended to make easy to find; don\'t commit\u003cbr\\/\u003e\\n    those\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\u003cul\u003e\\n\\t\u003cli\u003eFactor MergePolicyBase\u003c\\/li\u003e\\n\\t\u003cli\u003ecomments to remind to delete before commit (though might still have missed some)\u003c\\/li\u003e\\n\\t\u003cli\u003eMake LDMP casts not throw bad cast\u003c\\/li\u003e\\n\\t\u003cli\u003eGet rid of releaseMergePolicy and add doClose parameter on set\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eDidn\'t factor copy from other dirs: requires compound file choices\u003c\\/li\u003e\\n\\t\u003cli\u003eDidn\'t (yet) rename merge -&gt; maybeMerge\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eDoes this mean optimize -&gt; maybeOptimize, too?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520071_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520071_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'15\\/Aug\\/07 19:32\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-15T19:32:29+0000\'\u003e15\\/Aug\\/07 19:32\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Updated patch: \\n\\n \\n\\t Don\'t call deprecated methods \\n \\n \\n\\t note: currently renamed with \\\"_\\\" prepended to make easy to find; don\'t commit \\n    those \\n \\n \\n\\t Factor MergePolicyBase \\n\\t comments to remind to delete before commit (though might still have missed some) \\n\\t Make LDMP casts not throw bad cast \\n\\t Get rid of releaseMergePolicy and add doClose parameter on set \\n \\n\\n\\n \\n\\t Didn\'t factor copy from other dirs: requires compound file choices \\n\\t Didn\'t (yet) rename merge -&gt; maybeMerge \\n \\n \\n\\t Does this mean optimize -&gt; maybeOptimize, too? \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520260\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520260&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520260\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520260_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520260_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 14:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T14:20:50+0000\'\u003e16\\/Aug\\/07 14:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOne new small item: you\'ve added a \\\"public void merge()\\\" to\u003cbr\\/\u003e\\nIndexWriter so that people can externally kick off a merge request,\u003cbr\\/\u003e\\nwhich is good I think.\u003c\\/p\u003e\\n\\n\u003cp\u003eBut, is it really necessary to flush here?  It would be better to not\u003cbr\\/\u003e\\nflush so that users then have two separate methods (flush() and\u003cbr\\/\u003e\\nmerge()) to do each function independently.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Are you going to fix all unit tests that call the now-deprecated\u003cbr\\/\u003e\\n&gt; &gt; APIs?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Yeah. Thanks for the reminder.\u003c\\/p\u003e\\n\\n\u003cp\u003eOn thinking about this more ... and on seeing all the diffs ... I no\u003cbr\\/\u003e\\nlonger feel we should be deprecating \\\"get\\/setUseCompoundFile()\\\" nor\u003cbr\\/\u003e\\n\\\"get\\/setMergeFactor()\\\" nor \\\"get\\/setMaxMergeDocs()\\\" in IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe vast majoriy of Lucene users will not make their own merge policy\u003cbr\\/\u003e\\n(just use the default merge policy) and so I don\'t think we should be\u003cbr\\/\u003e\\ncomplicating their lives with having to now write lines like this when\u003cbr\\/\u003e\\nthey want to change settings:\u003c\\/p\u003e\\n\\n\u003cp\u003e   ((LogDocMergePolicy)writer.getMergePolicy()).setUseCompoundFile(useCompoundFile);\u003c\\/p\u003e\\n\\n\u003cp\u003eAlso, this ties our hands if ever we want to change the default merge\u003cbr\\/\u003e\\npolicy (which, under \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, I\'d like to do).\u003c\\/p\u003e\\n\\n\u003cp\u003eI think instead we should leave the methods, not deprecated, as\u003cbr\\/\u003e\\nconvenience (sugar) methods.  Simple things should be simple; complex\u003cbr\\/\u003e\\nthings should be possible.  Sorry I didn\'t think of this before you\u003cbr\\/\u003e\\nmade the new patch Steve \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/sad.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\" \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003cbr\\/\u003e\\n&gt; &gt; It\'s overloaded now.\u003cbr\\/\u003e\\n&gt; &gt; \u003cbr\\/\u003e\\n&gt; &gt; EG IndexMerger interface has a method called \\\"merge\\\" that is named\u003cbr\\/\u003e\\n&gt; &gt; correctly because it will specifically go a do the requested\u003cbr\\/\u003e\\n&gt; &gt; merge.  So does IndexWriter.\u003cbr\\/\u003e\\n&gt; &gt;\u003cbr\\/\u003e\\n&gt; &gt; Then, you have other \u003cspan class=\\\"error\\\"\u003e&#91;overloaded&#93;\u003c\\/span\u003e methods in LogDocMergePolicy\u003cbr\\/\u003e\\n&gt; &gt; called \\\"merge\\\" that are named appropriately (they will do a\u003cbr\\/\u003e\\n&gt; &gt; specific merge).\u003cbr\\/\u003e\\n&gt; &gt; \u003cbr\\/\u003e\\n&gt; &gt; How about \\\"checkForMerges()\\\"?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I don\'t find it ambiguous based on class and argument type. It\'s all\u003cbr\\/\u003e\\n&gt; personal, of course.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; I\'d definitely prefer maybe over checkFor because that sounds like a\u003cbr\\/\u003e\\n&gt; predicate.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK let\'s settle on \\\"maybeMerge\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt;    - Does this mean optimize -&gt; maybeOptimize, too?\u003c\\/p\u003e\\n\\n\u003cp\u003eUh, no: when someone calls optimize that means it really must be done,\u003cbr\\/\u003e\\nright?  So \\\"optimize\\\" is the right name I think.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; * Make LDMP casts not throw bad cast \u003c\\/p\u003e\\n\\n\u003cp\u003eCan you factor this out, eg add a private method\u003cbr\\/\u003e\\n\\\"getLogDocMergePolicy(String reason)\\\" that would be the one place that\u003cbr\\/\u003e\\ndoes the class casting &amp; throwing an error message from one single\u003cbr\\/\u003e\\nsource line?  Right now the message is copied in multiple places and,\u003cbr\\/\u003e\\nit\'s wrong for mergeFactor (was copied from useCompoundFile).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; * Get rid of releaseMergePolicy and add doClose parameter on set\u003c\\/p\u003e\\n\\n\u003cp\u003eLooks good, thanks.  Can you add javadocs (w\\/ params) for both of\u003cbr\\/\u003e\\nthese new methods?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; As to the IndexWriter vs. IndexMerger issue, I still think having\u003cbr\\/\u003e\\n&gt; the interface is useful if not only that it makes my testing much\u003cbr\\/\u003e\\n&gt; easier. I have a MockIndexMerger that implements only the functions\u003cbr\\/\u003e\\n&gt; in the interface and therefore I can test merge policies without\u003cbr\\/\u003e\\n&gt; creating a writer. For me this has been a big win ...\u003c\\/p\u003e\\n\\n\u003cp\u003eSubclassing IndexWriter to make MockIndexMerger would also work for\u003cbr\\/\u003e\\ntesting?  This is what MockRAMDirectory does for example...\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Exactly: these settings decide when a segment is flushed, so, why\u003cbr\\/\u003e\\n&gt; &gt; put them into IndexMerger interface? They shouldn\'t have anything\u003cbr\\/\u003e\\n&gt; &gt; to with merging; I think they should be removed.\u003cbr\\/\u003e\\n&gt; &gt; \u003cbr\\/\u003e\\n&gt; &gt; For \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e I\'m working on a replacement for LogDocMergePolicy\u003cbr\\/\u003e\\n&gt; &gt; that does not use maxBufferedDocs.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I can see that one could write a merge policy that didn\'t have any\u003cbr\\/\u003e\\n&gt; idea of how the initial buffering was done, but I worry about\u003cbr\\/\u003e\\n&gt; precluding it. Maybe the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e patch will show a strong enough\u003cbr\\/\u003e\\n&gt; pattern to believe no merge policies will need it?\u003c\\/p\u003e\\n\\n\u003cp\u003eWe wouldn\'t be precluding it (people can still get it from their\u003cbr\\/\u003e\\nIndexWriter).  This is one of the big reasons that I don\'t like making\u003cbr\\/\u003e\\nan interface out of IndexMerger: here we are having to pick &amp; choose\u003cbr\\/\u003e\\nwhich settings from IndexWriter a merge policy is \\\"allowed\\\" to use.  I\u003cbr\\/\u003e\\ndon\'t think that\'s necessary (we are just making extra work for\u003cbr\\/\u003e\\nourselves) and inevitably we won\'t get it right...\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think factoring into a base class is an OK solution, but, it\u003cbr\\/\u003e\\n&gt; &gt; shouldn\'t be MergePolicy\'s job to remember to call this final\u003cbr\\/\u003e\\n&gt; &gt; \\\"move any segments in the wrong directory over\\\" code. As long as\u003cbr\\/\u003e\\n&gt; &gt; its in one place and people don\'t have to copy\\/paste code\u003cbr\\/\u003e\\n&gt; &gt; between MergePolicy sources.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; In the case of concurrent merges, I think this gets more\u003cbr\\/\u003e\\n&gt; complicated. When do you do those directory copies? I think you\u003cbr\\/\u003e\\n&gt; can\'t do them at the return from the merge policy because the merge\u003cbr\\/\u003e\\n&gt; policy may want to do them, but later.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I don\'t think IndexWriter has enough information to know when the\u003cbr\\/\u003e\\n&gt; copies need to done. Doubly so if we have concurrent merges? \u003c\\/p\u003e\\n\\n\u003cp\u003eAhh, good point.  Though, this raises the tricky question of index\u003cbr\\/\u003e\\nconsistency ... IndexWriter commits the new segments file right after\u003cbr\\/\u003e\\nmergePolicy.merge returns ... so for CMP we suddenly have an unusable\u003cbr\\/\u003e\\nindex (as seen by an IndexReader).  EG if things crash any time after\u003cbr\\/\u003e\\nthis point and before the background merging finishes &amp; commits,\u003cbr\\/\u003e\\nyou\'re hosed.\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe it\'s too ambitious to allow merges of segments from other\u003cbr\\/\u003e\\ndirectories to run concurrently?\u003c\\/p\u003e\\n\\n\u003cp\u003eI would consider it a hard error in IndexWriter if after calling\u003cbr\\/\u003e\\nmergePolicy.merge from any of the addIndexes*, there remain segments\u003cbr\\/\u003e\\nin other directories.  I think we should catch this &amp; throw an\u003cbr\\/\u003e\\nexception?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I still stand by it should be the merge policy making the\u003cbr\\/\u003e\\n&gt; choice. You could have the code in IndexWriter too, but then there\'d\u003cbr\\/\u003e\\n&gt; be duplicate code. To put the code only in IndexWriter removes the\u003cbr\\/\u003e\\n&gt; choice from the merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eI agree that merge policy should be the one making the choice, but the\u003cbr\\/\u003e\\nexecution of it should be a centralized place (IndexWriter).  EG with\u003cbr\\/\u003e\\nthe simplified API, the merge policy would just return, one by one,\u003cbr\\/\u003e\\neach of the segments that is in a different directory...\u003c\\/p\u003e\\n\\n\u003cp\u003eWe can\'t all be copy\\/pasting code (like I had to do for \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e)\u003cbr\\/\u003e\\nfor checking &amp; then moving segments across directories.  I think we\u003cbr\\/\u003e\\nneed single source for this, somehow.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think there should in fact be a default optimize() in the base class\u003cbr\\/\u003e\\n&gt; &gt; that does what current IndexWriter now does so that a MergePolicy need\u003cbr\\/\u003e\\n&gt; &gt; not implement optimize at all.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; It\'d be nice, but I don\'t know how to do it: the merge factor is not\u003cbr\\/\u003e\\n&gt; generic, so I don\'t know how to implement the loop generically.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmm, OK.  I think what you did (factoring out that massive\u003cbr\\/\u003e\\nconditional) is good here.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Ah ... I see: with your forced merge ... hmmm.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; No, forced would mean the merge policy must do a merge; whereas,\u003cbr\\/\u003e\\n&gt; normally, it\'s free not to do a merge until it wants to.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think adding a forced merge concept here is new ... If it\'s simply\u003cbr\\/\u003e\\n&gt; to support optimize, I\'m not sure I find it too compelling. LogDoc\u003cbr\\/\u003e\\n&gt; as it stands uses different algorithms for incremental merges and\u003cbr\\/\u003e\\n&gt; optimize, so there\'s not too much of a concept of forced merges\u003cbr\\/\u003e\\n&gt; vs. optional merges to be factored out. So I guess I\'m not seeing a\u003cbr\\/\u003e\\n&gt; strong compelling case for creating it?\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, I agree, let\'s not add \\\"forced\\\".  How about, instead we only\u003cbr\\/\u003e\\nrequire mergePolicy to implement optimize(int maxNumSegments)?  (And\u003cbr\\/\u003e\\ncurrent IndexWriter.optimize() calls this with parameter \\\"1\\\").\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Well, it\'s sort of awkward if you want to vary that max #\u003cbr\\/\u003e\\n&gt; &gt; segments.  Say during the day you optimize down to 15 segments\u003cbr\\/\u003e\\n&gt; &gt; every time you update the index, but then at night you want to\u003cbr\\/\u003e\\n&gt; &gt; optimize down to 5.  If we don\'t add method to IndexWriter you\u003cbr\\/\u003e\\n&gt; &gt; then must have instance var on your MergePolicy that you set,\u003cbr\\/\u003e\\n&gt; &gt; then you call optimize. It\'s not clean since really it should be\u003cbr\\/\u003e\\n&gt; &gt; a parameter.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Well, I don\'t know if I buy the argument that it should be a\u003cbr\\/\u003e\\n&gt; parameter. The merge policy has lots of state like docs\\/seg. I don\'t\u003cbr\\/\u003e\\n&gt; really see why segs\\/optimize is different.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think this would be a useful enough method that it should be \\\"made\u003cbr\\/\u003e\\nsimple\\\" (ie, this is different from the \\\"other state\\\" that a merge\u003cbr\\/\u003e\\npolicy would store).  I opened a separate issue \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-982\\\" title=\\\"Create new method optimize(int maxNumSegments) in IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-982\\\"\u003e\u003cdel\u003eLUCENE-982\u003c\\/del\u003e\u003c\\/a\u003e to track\u003cbr\\/\u003e\\nthis.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; My main reason for not wanting put this into IndexWriter is then\u003cbr\\/\u003e\\n&gt; every merge policy must support it.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is why I want to address it now, while we are cementing the\u003cbr\\/\u003e\\nMergePolicy API: I don\'t want to preclude it.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Wait: there is a barrier, right? In IndexWriter.replace we don\'t do\u003cbr\\/\u003e\\n&gt; &gt; the right thing with non-contiguous merges?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Yeah, I meant that I\'m not aware of any barriers except fixing\u003cbr\\/\u003e\\n&gt; IndexWriter#replace, in other words, I\'m not aware of any other\u003cbr\\/\u003e\\n&gt; places where non-contiguity would cause a failure.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, good, that\'s my impression too.\u003c\\/p\u003e\\n\\n\u003cp\u003eAlthough ... do you think we need need some way for merge policy to\u003cbr\\/\u003e\\nstate where the new segment should be inserted into SegmentInfos?  For\u003cbr\\/\u003e\\nthe contiguous case it seems clear that we should default to what is\u003cbr\\/\u003e\\ndone now (new segment goes into same spot where old segments were).\u003cbr\\/\u003e\\nBut for the non-contiguous case, how would IndexWriter know where to\u003cbr\\/\u003e\\nput the newly created segment?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Finally: does MergePolicy really need a close()?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; I think so. The concurrent merge policy maintains all sorts of\u003cbr\\/\u003e\\n&gt; state.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK.  Hmmm, does CMP block on close while it joins to any running merge\u003cbr\\/\u003e\\nthreads?  How can the user close IndexWriter and abort the running\u003cbr\\/\u003e\\nmerges?  I guess CMP would provide a method to abort any running\u003cbr\\/\u003e\\nmerges, and user would first call that before calling\u003cbr\\/\u003e\\nIndexWriter.close?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I don\'t see how it can work (building the generic concurrency\u003cbr\\/\u003e\\n&gt; &gt; wrapper \\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial\u003cbr\\/\u003e\\n&gt; &gt; control\\\", eg, when it wants to cascade merges. How will you return\u003cbr\\/\u003e\\n&gt; &gt; that thread back to IndexWriter?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; So this is how it looks now: the concurrent merge policy is both a\u003cbr\\/\u003e\\n&gt; merge policy and an index merger. The serial merge policy knows\u003cbr\\/\u003e\\n&gt; nothing about it other than it does not get IndexWriter as its\u003cbr\\/\u003e\\n&gt; merge.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The index writer wants its merge, so it does it merge\\/maybeMerge\u003cbr\\/\u003e\\n&gt; call on the concurrent merge policy. The CMP calls merge on the\u003cbr\\/\u003e\\n&gt; serial policy, but substitutes itself for the merger rather than\u003cbr\\/\u003e\\n&gt; IndexWriter.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; The serial merge policy goes on its merry way, looking for merges to\u003cbr\\/\u003e\\n&gt; do (in the current model, this is a loop; more on that in a\u003cbr\\/\u003e\\n&gt; minute). Each time it has a subset of segments to merge, it calls\u003cbr\\/\u003e\\n&gt; merger.merge(...).\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; At this point, the concurrent merge policy takes over again. It\u003cbr\\/\u003e\\n&gt; looks at the segments to be merged and other segments being\u003cbr\\/\u003e\\n&gt; processed by all existing merge threads and determines if there\'s a\u003cbr\\/\u003e\\n&gt; conflict (a request to merge a segment that\'s currently in a\u003cbr\\/\u003e\\n&gt; merge). If there\'s no conflict, it starts a merge thread and calls\u003cbr\\/\u003e\\n&gt; IndexWriter#merge on the thread. The original calling thread returns\u003cbr\\/\u003e\\n&gt; immediately. (I have a few ideas how to handle conflicts, the\u003cbr\\/\u003e\\n&gt; simplest of which is to wait for the conflicting merge and the\u003cbr\\/\u003e\\n&gt; restart the serial merge, e.g., revert to serial).\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; This seems to work pretty well, so far. The only difference in API\u003cbr\\/\u003e\\n&gt; for the serial merges is that the merge operation can\'t return the\u003cbr\\/\u003e\\n&gt; number of documents in the result (since it isn\'t known how many\u003cbr\\/\u003e\\n&gt; docs will be deleted).\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmm.  This looks more complex than the proposed API simplification,\u003cbr\\/\u003e\\nbecause you now have CMP on the top and on the bottom.  Also, this\u003cbr\\/\u003e\\nrequires the IndexMerger interface, but with the simplification we\u003cbr\\/\u003e\\nwould not need a separate interface.  Finally, I\'m pretty sure you\u003cbr\\/\u003e\\nhave locking issues (more below...), which are required of all merge\u003cbr\\/\u003e\\npolicies, that the simplified API wouldn\'t have.\u003c\\/p\u003e\\n\\n\u003cp\u003eHow we handle conflicts is important but I think independent of this\u003cbr\\/\u003e\\nAPI discussion (ie both your CMP and my CMP have this same challenge,\u003cbr\\/\u003e\\nand I agree we should start simple by just blocking when the selected\u003cbr\\/\u003e\\nmerge conflicts with a previous one that\'s still in progress).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; With concurrency wrapper \\\"on the top\\\" it\'s able to easily take a\u003cbr\\/\u003e\\n&gt; &gt; merge request as returned by the policy, kick it off in the\u003cbr\\/\u003e\\n&gt; &gt; backrground, and immediately return control of original thread\u003cbr\\/\u003e\\n&gt; &gt; back to IndexWriter.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; What I don\'t know how to do with this is figure out how to do a\u003cbr\\/\u003e\\n&gt; bunch of merges. Lets say I have two levels in LogDoc that are merge\u003cbr\\/\u003e\\n&gt; worthy. If I call LogDoc, it\'ll return the lower level. That\'s all\u003cbr\\/\u003e\\n&gt; good. But what about doing the higher level in parallel? If I call\u003cbr\\/\u003e\\n&gt; LogDoc again, it\'s going to return the lower level again because it\u003cbr\\/\u003e\\n&gt; knows nothing about the current merge going on.\u003c\\/p\u003e\\n\\n\u003cp\u003eTrue, LogDoc as it now stands would never exploit concurrency (it will\u003cbr\\/\u003e\\nalways return the highest level that needs merging).  But, we could\u003cbr\\/\u003e\\nrelax that such that if ever the lowest level has &gt; 2*mergeFactor\u003cbr\\/\u003e\\npending segments to merge then we select the 2nd set.  This would\u003cbr\\/\u003e\\nexpose concurrency that would only be used when CMP is in use.  But I\u003cbr\\/\u003e\\nthink we should do this, later, as an enhancement.  Let\'s focus on\u003cbr\\/\u003e\\nsimplifying the API now...\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; It would be possible to have it return a vector of segmentInfo\u003cbr\\/\u003e\\n&gt; subsets, but I don\'t see the gain (and it doesn\'t work out as well\u003cbr\\/\u003e\\n&gt; for my putative conflict resolution).\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah that would make the API even more complex, which is the wrong\u003cbr\\/\u003e\\ndirection here \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; have all necessary locking for SegmentInfos inside IndexWriter\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; This was a red-herring on my part. All the \\\"segmentInfos locking\\\"\u003cbr\\/\u003e\\n&gt; has always been in IndexWriter. That\'s note exactly sufficient. The\u003cbr\\/\u003e\\n&gt; fundamental issue is that IndexWriter#merge has to operate without a\u003cbr\\/\u003e\\n&gt; lock on IndexWriter. At some point, I was thinking that meant it\u003cbr\\/\u003e\\n&gt; would have to lock SegmentInfos but that\'s ludicrous, actually. It\'s\u003cbr\\/\u003e\\n&gt; sufficient for IndexWriter#replace to be synchronized.\u003c\\/p\u003e\\n\\n\u003cp\u003eRight: merging certainly shouldn\'t hold lock on IndexWriter nor\u003cbr\\/\u003e\\nsegmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; If CMP implements IndexMerger you must have locking inside any\u003cbr\\/\u003e\\n&gt; &gt; MergePolicy that\'s calling into CMP?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; No. CMP does it\'s own locking (for purposes of thread management)\u003cbr\\/\u003e\\n&gt; but the serial merge policies no nothing of this (and they can\u003cbr\\/\u003e\\n&gt; expect to be called synchronously).\u003c\\/p\u003e\\n\\n\u003cp\u003eThis I don\'t get: it seems to me that the serial merge policies must\u003cbr\\/\u003e\\ndo their own locking when they access the SegmentInfos that\'s passed\u003cbr\\/\u003e\\nin?  And that lock must be released, somehow, when they call merge?\u003cbr\\/\u003e\\nWould merge (inside IndexWriter) somehow release the lock on being\u003cbr\\/\u003e\\ncalled?  I don\'t see how you\'re going to make the locking work, but I\u003cbr\\/\u003e\\nthink it\'s required with the current API.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is another benefit of the simplified API: MergePolicy.maybeMerge\u003cbr\\/\u003e\\nwould only be called with a lock already acquired (by IndexWriter) on\u003cbr\\/\u003e\\nthe segmentInfos.  Then maybeMerge looks @ the segmentInfos, makes its\u003cbr\\/\u003e\\nchoice, and returns it, and the lock is released.  The lock is not\u003cbr\\/\u003e\\nheld for an extended period of time...\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520260_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520260_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 14:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T14:20:50+0000\'\u003e16\\/Aug\\/07 14:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    One new small item: you\'ve added a \\\"public void merge()\\\" to \\nIndexWriter so that people can externally kick off a merge request, \\nwhich is good I think. \\n\\n But, is it really necessary to flush here?  It would be better to not \\nflush so that users then have two separate methods (flush() and \\nmerge()) to do each function independently. \\n\\n &gt; &gt; Are you going to fix all unit tests that call the now-deprecated \\n&gt; &gt; APIs? \\n&gt;  \\n&gt; Yeah. Thanks for the reminder. \\n\\n On thinking about this more ... and on seeing all the diffs ... I no \\nlonger feel we should be deprecating \\\"get\\/setUseCompoundFile()\\\" nor \\n\\\"get\\/setMergeFactor()\\\" nor \\\"get\\/setMaxMergeDocs()\\\" in IndexWriter. \\n\\n The vast majoriy of Lucene users will not make their own merge policy \\n(just use the default merge policy) and so I don\'t think we should be \\ncomplicating their lives with having to now write lines like this when \\nthey want to change settings: \\n\\n    ((LogDocMergePolicy)writer.getMergePolicy()).setUseCompoundFile(useCompoundFile); \\n\\n Also, this ties our hands if ever we want to change the default merge \\npolicy (which, under   LUCENE-845  , I\'d like to do). \\n\\n I think instead we should leave the methods, not deprecated, as \\nconvenience (sugar) methods.  Simple things should be simple; complex \\nthings should be possible.  Sorry I didn\'t think of this before you \\nmade the new patch Steve   \\n\\n &gt; &gt; I\'m not wed to \\\"maybeMerge()\\\" but I really don\'t like \\\"merge\\\"   \\n&gt; &gt; It\'s overloaded now. \\n&gt; &gt;  \\n&gt; &gt; EG IndexMerger interface has a method called \\\"merge\\\" that is named \\n&gt; &gt; correctly because it will specifically go a do the requested \\n&gt; &gt; merge.  So does IndexWriter. \\n&gt; &gt; \\n&gt; &gt; Then, you have other  &#91;overloaded&#93;  methods in LogDocMergePolicy \\n&gt; &gt; called \\\"merge\\\" that are named appropriately (they will do a \\n&gt; &gt; specific merge). \\n&gt; &gt;  \\n&gt; &gt; How about \\\"checkForMerges()\\\"? \\n&gt; \\n&gt; I don\'t find it ambiguous based on class and argument type. It\'s all \\n&gt; personal, of course. \\n&gt;  \\n&gt; I\'d definitely prefer maybe over checkFor because that sounds like a \\n&gt; predicate. \\n\\n OK let\'s settle on \\\"maybeMerge\\\"? \\n\\n &gt;    - Does this mean optimize -&gt; maybeOptimize, too? \\n\\n Uh, no: when someone calls optimize that means it really must be done, \\nright?  So \\\"optimize\\\" is the right name I think. \\n\\n &gt; * Make LDMP casts not throw bad cast  \\n\\n Can you factor this out, eg add a private method \\n\\\"getLogDocMergePolicy(String reason)\\\" that would be the one place that \\ndoes the class casting &amp; throwing an error message from one single \\nsource line?  Right now the message is copied in multiple places and, \\nit\'s wrong for mergeFactor (was copied from useCompoundFile). \\n\\n &gt; * Get rid of releaseMergePolicy and add doClose parameter on set \\n\\n Looks good, thanks.  Can you add javadocs (w\\/ params) for both of \\nthese new methods? \\n\\n &gt; As to the IndexWriter vs. IndexMerger issue, I still think having \\n&gt; the interface is useful if not only that it makes my testing much \\n&gt; easier. I have a MockIndexMerger that implements only the functions \\n&gt; in the interface and therefore I can test merge policies without \\n&gt; creating a writer. For me this has been a big win ... \\n\\n Subclassing IndexWriter to make MockIndexMerger would also work for \\ntesting?  This is what MockRAMDirectory does for example... \\n\\n &gt; &gt; Exactly: these settings decide when a segment is flushed, so, why \\n&gt; &gt; put them into IndexMerger interface? They shouldn\'t have anything \\n&gt; &gt; to with merging; I think they should be removed. \\n&gt; &gt;  \\n&gt; &gt; For   LUCENE-845   I\'m working on a replacement for LogDocMergePolicy \\n&gt; &gt; that does not use maxBufferedDocs. \\n\\n &gt; I can see that one could write a merge policy that didn\'t have any \\n&gt; idea of how the initial buffering was done, but I worry about \\n&gt; precluding it. Maybe the   LUCENE-845   patch will show a strong enough \\n&gt; pattern to believe no merge policies will need it? \\n\\n We wouldn\'t be precluding it (people can still get it from their \\nIndexWriter).  This is one of the big reasons that I don\'t like making \\nan interface out of IndexMerger: here we are having to pick &amp; choose \\nwhich settings from IndexWriter a merge policy is \\\"allowed\\\" to use.  I \\ndon\'t think that\'s necessary (we are just making extra work for \\nourselves) and inevitably we won\'t get it right... \\n\\n &gt; &gt; I think factoring into a base class is an OK solution, but, it \\n&gt; &gt; shouldn\'t be MergePolicy\'s job to remember to call this final \\n&gt; &gt; \\\"move any segments in the wrong directory over\\\" code. As long as \\n&gt; &gt; its in one place and people don\'t have to copy\\/paste code \\n&gt; &gt; between MergePolicy sources. \\n&gt;  \\n&gt; In the case of concurrent merges, I think this gets more \\n&gt; complicated. When do you do those directory copies? I think you \\n&gt; can\'t do them at the return from the merge policy because the merge \\n&gt; policy may want to do them, but later. \\n&gt; \\n&gt; I don\'t think IndexWriter has enough information to know when the \\n&gt; copies need to done. Doubly so if we have concurrent merges?  \\n\\n Ahh, good point.  Though, this raises the tricky question of index \\nconsistency ... IndexWriter commits the new segments file right after \\nmergePolicy.merge returns ... so for CMP we suddenly have an unusable \\nindex (as seen by an IndexReader).  EG if things crash any time after \\nthis point and before the background merging finishes &amp; commits, \\nyou\'re hosed. \\n\\n Maybe it\'s too ambitious to allow merges of segments from other \\ndirectories to run concurrently? \\n\\n I would consider it a hard error in IndexWriter if after calling \\nmergePolicy.merge from any of the addIndexes*, there remain segments \\nin other directories.  I think we should catch this &amp; throw an \\nexception? \\n\\n &gt; I still stand by it should be the merge policy making the \\n&gt; choice. You could have the code in IndexWriter too, but then there\'d \\n&gt; be duplicate code. To put the code only in IndexWriter removes the \\n&gt; choice from the merge policy. \\n\\n I agree that merge policy should be the one making the choice, but the \\nexecution of it should be a centralized place (IndexWriter).  EG with \\nthe simplified API, the merge policy would just return, one by one, \\neach of the segments that is in a different directory... \\n\\n We can\'t all be copy\\/pasting code (like I had to do for   LUCENE-845  ) \\nfor checking &amp; then moving segments across directories.  I think we \\nneed single source for this, somehow. \\n\\n &gt; &gt; I think there should in fact be a default optimize() in the base class \\n&gt; &gt; that does what current IndexWriter now does so that a MergePolicy need \\n&gt; &gt; not implement optimize at all. \\n&gt; \\n&gt; It\'d be nice, but I don\'t know how to do it: the merge factor is not \\n&gt; generic, so I don\'t know how to implement the loop generically. \\n\\n Hmmm, OK.  I think what you did (factoring out that massive \\nconditional) is good here. \\n\\n &gt; Ah ... I see: with your forced merge ... hmmm. \\n&gt;  \\n&gt; No, forced would mean the merge policy must do a merge; whereas, \\n&gt; normally, it\'s free not to do a merge until it wants to. \\n&gt; \\n&gt; I think adding a forced merge concept here is new ... If it\'s simply \\n&gt; to support optimize, I\'m not sure I find it too compelling. LogDoc \\n&gt; as it stands uses different algorithms for incremental merges and \\n&gt; optimize, so there\'s not too much of a concept of forced merges \\n&gt; vs. optional merges to be factored out. So I guess I\'m not seeing a \\n&gt; strong compelling case for creating it? \\n\\n OK, I agree, let\'s not add \\\"forced\\\".  How about, instead we only \\nrequire mergePolicy to implement optimize(int maxNumSegments)?  (And \\ncurrent IndexWriter.optimize() calls this with parameter \\\"1\\\"). \\n\\n &gt; &gt; Well, it\'s sort of awkward if you want to vary that max # \\n&gt; &gt; segments.  Say during the day you optimize down to 15 segments \\n&gt; &gt; every time you update the index, but then at night you want to \\n&gt; &gt; optimize down to 5.  If we don\'t add method to IndexWriter you \\n&gt; &gt; then must have instance var on your MergePolicy that you set, \\n&gt; &gt; then you call optimize. It\'s not clean since really it should be \\n&gt; &gt; a parameter. \\n&gt; \\n&gt; Well, I don\'t know if I buy the argument that it should be a \\n&gt; parameter. The merge policy has lots of state like docs\\/seg. I don\'t \\n&gt; really see why segs\\/optimize is different. \\n\\n I think this would be a useful enough method that it should be \\\"made \\nsimple\\\" (ie, this is different from the \\\"other state\\\" that a merge \\npolicy would store).  I opened a separate issue   LUCENE-982   to track \\nthis. \\n\\n &gt; My main reason for not wanting put this into IndexWriter is then \\n&gt; every merge policy must support it. \\n\\n This is why I want to address it now, while we are cementing the \\nMergePolicy API: I don\'t want to preclude it. \\n\\n &gt; &gt; Wait: there is a barrier, right? In IndexWriter.replace we don\'t do \\n&gt; &gt; the right thing with non-contiguous merges? \\n&gt;  \\n&gt; Yeah, I meant that I\'m not aware of any barriers except fixing \\n&gt; IndexWriter#replace, in other words, I\'m not aware of any other \\n&gt; places where non-contiguity would cause a failure. \\n\\n OK, good, that\'s my impression too. \\n\\n Although ... do you think we need need some way for merge policy to \\nstate where the new segment should be inserted into SegmentInfos?  For \\nthe contiguous case it seems clear that we should default to what is \\ndone now (new segment goes into same spot where old segments were). \\nBut for the non-contiguous case, how would IndexWriter know where to \\nput the newly created segment? \\n\\n &gt; &gt; Finally: does MergePolicy really need a close()? \\n&gt;  \\n&gt; I think so. The concurrent merge policy maintains all sorts of \\n&gt; state. \\n\\n OK.  Hmmm, does CMP block on close while it joins to any running merge \\nthreads?  How can the user close IndexWriter and abort the running \\nmerges?  I guess CMP would provide a method to abort any running \\nmerges, and user would first call that before calling \\nIndexWriter.close? \\n\\n &gt; &gt; I don\'t see how it can work (building the generic concurrency \\n&gt; &gt; wrapper \\\"under\\\" IndexMerger) because the MergePolicy is in \\\"serial \\n&gt; &gt; control\\\", eg, when it wants to cascade merges. How will you return \\n&gt; &gt; that thread back to IndexWriter? \\n&gt; \\n&gt; So this is how it looks now: the concurrent merge policy is both a \\n&gt; merge policy and an index merger. The serial merge policy knows \\n&gt; nothing about it other than it does not get IndexWriter as its \\n&gt; merge. \\n&gt; \\n&gt; The index writer wants its merge, so it does it merge\\/maybeMerge \\n&gt; call on the concurrent merge policy. The CMP calls merge on the \\n&gt; serial policy, but substitutes itself for the merger rather than \\n&gt; IndexWriter. \\n&gt; \\n&gt; The serial merge policy goes on its merry way, looking for merges to \\n&gt; do (in the current model, this is a loop; more on that in a \\n&gt; minute). Each time it has a subset of segments to merge, it calls \\n&gt; merger.merge(...). \\n&gt; \\n&gt; At this point, the concurrent merge policy takes over again. It \\n&gt; looks at the segments to be merged and other segments being \\n&gt; processed by all existing merge threads and determines if there\'s a \\n&gt; conflict (a request to merge a segment that\'s currently in a \\n&gt; merge). If there\'s no conflict, it starts a merge thread and calls \\n&gt; IndexWriter#merge on the thread. The original calling thread returns \\n&gt; immediately. (I have a few ideas how to handle conflicts, the \\n&gt; simplest of which is to wait for the conflicting merge and the \\n&gt; restart the serial merge, e.g., revert to serial). \\n&gt; \\n&gt; This seems to work pretty well, so far. The only difference in API \\n&gt; for the serial merges is that the merge operation can\'t return the \\n&gt; number of documents in the result (since it isn\'t known how many \\n&gt; docs will be deleted). \\n\\n Hmmm.  This looks more complex than the proposed API simplification, \\nbecause you now have CMP on the top and on the bottom.  Also, this \\nrequires the IndexMerger interface, but with the simplification we \\nwould not need a separate interface.  Finally, I\'m pretty sure you \\nhave locking issues (more below...), which are required of all merge \\npolicies, that the simplified API wouldn\'t have. \\n\\n How we handle conflicts is important but I think independent of this \\nAPI discussion (ie both your CMP and my CMP have this same challenge, \\nand I agree we should start simple by just blocking when the selected \\nmerge conflicts with a previous one that\'s still in progress). \\n\\n &gt; &gt; With concurrency wrapper \\\"on the top\\\" it\'s able to easily take a \\n&gt; &gt; merge request as returned by the policy, kick it off in the \\n&gt; &gt; backrground, and immediately return control of original thread \\n&gt; &gt; back to IndexWriter. \\n&gt; \\n&gt; What I don\'t know how to do with this is figure out how to do a \\n&gt; bunch of merges. Lets say I have two levels in LogDoc that are merge \\n&gt; worthy. If I call LogDoc, it\'ll return the lower level. That\'s all \\n&gt; good. But what about doing the higher level in parallel? If I call \\n&gt; LogDoc again, it\'s going to return the lower level again because it \\n&gt; knows nothing about the current merge going on. \\n\\n True, LogDoc as it now stands would never exploit concurrency (it will \\nalways return the highest level that needs merging).  But, we could \\nrelax that such that if ever the lowest level has &gt; 2*mergeFactor \\npending segments to merge then we select the 2nd set.  This would \\nexpose concurrency that would only be used when CMP is in use.  But I \\nthink we should do this, later, as an enhancement.  Let\'s focus on \\nsimplifying the API now... \\n\\n &gt; It would be possible to have it return a vector of segmentInfo \\n&gt; subsets, but I don\'t see the gain (and it doesn\'t work out as well \\n&gt; for my putative conflict resolution). \\n\\n Yeah that would make the API even more complex, which is the wrong \\ndirection here   \\n\\n &gt; &gt; have all necessary locking for SegmentInfos inside IndexWriter \\n&gt; \\n&gt; This was a red-herring on my part. All the \\\"segmentInfos locking\\\" \\n&gt; has always been in IndexWriter. That\'s note exactly sufficient. The \\n&gt; fundamental issue is that IndexWriter#merge has to operate without a \\n&gt; lock on IndexWriter. At some point, I was thinking that meant it \\n&gt; would have to lock SegmentInfos but that\'s ludicrous, actually. It\'s \\n&gt; sufficient for IndexWriter#replace to be synchronized. \\n\\n Right: merging certainly shouldn\'t hold lock on IndexWriter nor \\nsegmentInfos. \\n\\n &gt; &gt; If CMP implements IndexMerger you must have locking inside any \\n&gt; &gt; MergePolicy that\'s calling into CMP? \\n&gt; \\n&gt; No. CMP does it\'s own locking (for purposes of thread management) \\n&gt; but the serial merge policies no nothing of this (and they can \\n&gt; expect to be called synchronously). \\n\\n This I don\'t get: it seems to me that the serial merge policies must \\ndo their own locking when they access the SegmentInfos that\'s passed \\nin?  And that lock must be released, somehow, when they call merge? \\nWould merge (inside IndexWriter) somehow release the lock on being \\ncalled?  I don\'t see how you\'re going to make the locking work, but I \\nthink it\'s required with the current API. \\n\\n This is another benefit of the simplified API: MergePolicy.maybeMerge \\nwould only be called with a lock already acquired (by IndexWriter) on \\nthe segmentInfos.  Then maybeMerge looks @ the segmentInfos, makes its \\nchoice, and returns it, and the lock is released.  The lock is not \\nheld for an extended period of time...              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520293\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520293&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520293\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520293_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520293_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 16:26\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T16:26:34+0000\'\u003e16\\/Aug\\/07 16:26\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tOne new small item: you\'ve added a \\\"public void merge()\\\" to\u003cbr\\/\u003e\\n\\tIndexWriter so that people can externally kick off a merge request,\u003cbr\\/\u003e\\n\\twhich is good I think.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tBut, is it really necessary to flush here?  It would be better to not\u003cbr\\/\u003e\\n\\tflush so that users then have two separate methods (flush() and\u003cbr\\/\u003e\\n\\tmerge()) to do each function independently.\u003c\\/p\u003e\\n\\n\u003cp\u003eThat makes sense.\u003c\\/p\u003e\\n\\n\u003cp\u003eNote that merge() was added not for users (which I have no strong opinion about) but so that, potentially, CMP can check again for merges when a set of merge threads completes, i.e., cascade.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think instead we should leave the methods, not deprecated, as\u003cbr\\/\u003e\\n\\tconvenience (sugar) methods.  Simple things should be simple; complex\u003cbr\\/\u003e\\n\\tthings should be possible.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think this argues for a LegacyMergePolicy interface again, then? If we change the default merge policy and someone changes their code to use LogDoc for their own purposes, in both cases the getters\\/setters should work? So cast to the interface and as long as the merge policy supports this, the getters\\/setters work (unless the merge policy decides to throw within), otherwise the getters\\/setters throw? \u003c\\/p\u003e\\n\\n\u003cp\u003e\\tUh, no: when someone calls optimize that means it really must be done,\u003cbr\\/\u003e\\n\\tright?  So \\\"optimize\\\" is the right name I think.\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, but it might do nothing. Just as merge might do nothing.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tCan you factor this out, eg add a private method\u003cbr\\/\u003e\\n\\t\\\"getLogDocMergePolicy(String reason)\\\"\u003c\\/p\u003e\\n\\n\u003cp\u003eSure.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tLooks good, thanks.  Can you add javadocs (w\\/ params) for both of\u003cbr\\/\u003e\\n\\tthese new methods?\u003c\\/p\u003e\\n\\n\u003cp\u003eSure.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tThough, this raises the tricky question of index\u003cbr\\/\u003e\\n\\tconsistency ...\u003c\\/p\u003e\\n\\n\u003cp\u003eDefinitely. I\'m still trying to understand all the subtleties here.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tIndexWriter commits the new segments file right after\u003cbr\\/\u003e\\n\\tmergePolicy.merge returns ... so for CMP we suddenly have an unusable\u003cbr\\/\u003e\\n\\tindex (as seen by an IndexReader).\u003c\\/p\u003e\\n\\n\u003cp\u003eHow so? I figured that after mergePolicy.merge returns, in the case of CMP with an ongoing merge, segmentInfos won\'t have changed at all. Is that a problem?\u003c\\/p\u003e\\n\\n\u003cp\u003eI thought the issue would be on the other end, where the concurrent merge finishes and needs to update segmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tMaybe it\'s too ambitious to allow merges of segments from other\u003cbr\\/\u003e\\n\\tdirectories to run concurrently?\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, that might be the case. At least as a default?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI would consider it a hard error in IndexWriter if after calling\u003cbr\\/\u003e\\n\\tmergePolicy.merge from any of the addIndexes*, there remain segments\u003cbr\\/\u003e\\n\\tin other directories.  I think we should catch this &amp; throw an\u003cbr\\/\u003e\\n\\texception?\u003c\\/p\u003e\\n\\n\u003cp\u003eIt would be easy enough for CMP to block in this case, rather than returning immediately. Wouldn\'t that be better? And I suppose it\'s possible to imagine an API on CMP for specifying this behavior?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI opened a separate issue \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-982\\\" title=\\\"Create new method optimize(int maxNumSegments) in IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-982\\\"\u003e\u003cdel\u003eLUCENE-982\u003c\\/del\u003e\u003c\\/a\u003e to track this.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think this is good. I think it\'s an interesting issue but not directly related to the refactor?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tAlthough ... do you think we need need some way for merge policy to\u003cbr\\/\u003e\\n\\tstate where the new segment should be inserted into SegmentInfos?\u003c\\/p\u003e\\n\\n\u003cp\u003eRight now I assumed it would replace the left most-segment.\u003c\\/p\u003e\\n\\n\u003cp\u003eSince I don\'t really know the details of what such a merge policy would like, I don\'t really know what it needs.\u003c\\/p\u003e\\n\\n\u003cp\u003eIf you\'ve thought about this more, do you have a suggestion? I suppose we could just add an int. But, then again, I\'d do that as a separate function, leaving the original available, so we can do this later, completely compatibly?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tHmmm, does CMP block on close while it joins to any running merge\u003cbr\\/\u003e\\n\\tthreads?\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, at least in my sandbox.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tHow can the user close IndexWriter and abort the running\u003cbr\\/\u003e\\n\\tmerges?  I guess CMP would provide a method to abort any running\u003cbr\\/\u003e\\n\\tmerges, and user would first call that before calling\u003cbr\\/\u003e\\n\\tIndexWriter.close?\u003c\\/p\u003e\\n\\n\u003cp\u003eI hadn\'t really thought about this but I can see that should be made possible. It\'s always safe to abandon a merge so it should be available, for fast, safe, and clean shutdown.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tTrue, LogDoc as it now stands would never exploit concurrency (it will\u003cbr\\/\u003e\\n\\talways return the highest level that needs merging).  But, we could\u003cbr\\/\u003e\\n\\trelax that such that if ever the lowest level has &gt; 2*mergeFactor\u003cbr\\/\u003e\\n\\tpending segments to merge then we select the 2nd set.\u003c\\/p\u003e\\n\\n\u003cp\u003eOkay. But it will always return that? Still doesn\'t sound concurrent?\u003c\\/p\u003e\\n\\n\u003cp\u003eThe thing is, the serial merge policy has no concept of concurrent merges, so if the API is always to select the best merge, until a pervious merge finishes, it will always return that as the best merge.\u003c\\/p\u003e\\n\\n\u003cp\u003eConcurrent is going to require, by hook or by crook, that a merge policy be able to generate a set of non-conflicting merges, is it not?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge policy does this now, given that CMP gathers up the merge calls. I\'m not sure the current \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e merge policy does (I\'d have to double check) because it sometimes will try to use the result of the current merge in the next merge. The \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge doesn\'t try to do this which is a\u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/thumbs_down.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e (inconsequential) change?\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tThis is another benefit of the simplified API: MergePolicy.maybeMerge\u003cbr\\/\u003e\\n\\twould only be called with a lock already acquired (by IndexWriter) on\u003cbr\\/\u003e\\n\\tthe segmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003eDo you really mean a lock on segmentInfos or just the lock on IndexWriter? I\'m assuming the latter and I think this is the case for both API models.\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t think it\'s feasible to have a lock on segmentInfos separately. Only IndexWriter should change segmentInfos and no code should try to look at segmentInfos w\\/o being called via an IW synch method.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis does imply that CMP has to copy any segmentInfos data it plans to use during concurrent merging, since the IW lock is not held during these periods. Then, when the merge is done, segmentInfos is updated in IndexWriter via a synch call to IW#replace.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis means IW#segmentInfos can change while a merge is in progress and this has to be accounted for. That\'s what I\'m walking through now.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520293_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520293_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 16:26\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T16:26:34+0000\'\u003e16\\/Aug\\/07 16:26\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tOne new small item: you\'ve added a \\\"public void merge()\\\" to \\n\\tIndexWriter so that people can externally kick off a merge request, \\n\\twhich is good I think. \\n\\n \\tBut, is it really necessary to flush here?  It would be better to not \\n\\tflush so that users then have two separate methods (flush() and \\n\\tmerge()) to do each function independently. \\n\\n That makes sense. \\n\\n Note that merge() was added not for users (which I have no strong opinion about) but so that, potentially, CMP can check again for merges when a set of merge threads completes, i.e., cascade. \\n\\n \\tI think instead we should leave the methods, not deprecated, as \\n\\tconvenience (sugar) methods.  Simple things should be simple; complex \\n\\tthings should be possible. \\n\\n I think this argues for a LegacyMergePolicy interface again, then? If we change the default merge policy and someone changes their code to use LogDoc for their own purposes, in both cases the getters\\/setters should work? So cast to the interface and as long as the merge policy supports this, the getters\\/setters work (unless the merge policy decides to throw within), otherwise the getters\\/setters throw?  \\n\\n \\tUh, no: when someone calls optimize that means it really must be done, \\n\\tright?  So \\\"optimize\\\" is the right name I think. \\n\\n Yeah, but it might do nothing. Just as merge might do nothing. \\n\\n \\tCan you factor this out, eg add a private method \\n\\t\\\"getLogDocMergePolicy(String reason)\\\" \\n\\n Sure. \\n\\n \\tLooks good, thanks.  Can you add javadocs (w\\/ params) for both of \\n\\tthese new methods? \\n\\n Sure. \\n\\n \\tThough, this raises the tricky question of index \\n\\tconsistency ... \\n\\n Definitely. I\'m still trying to understand all the subtleties here. \\n\\n \\tIndexWriter commits the new segments file right after \\n\\tmergePolicy.merge returns ... so for CMP we suddenly have an unusable \\n\\tindex (as seen by an IndexReader). \\n\\n How so? I figured that after mergePolicy.merge returns, in the case of CMP with an ongoing merge, segmentInfos won\'t have changed at all. Is that a problem? \\n\\n I thought the issue would be on the other end, where the concurrent merge finishes and needs to update segmentInfos. \\n\\n \\tMaybe it\'s too ambitious to allow merges of segments from other \\n\\tdirectories to run concurrently? \\n\\n Yeah, that might be the case. At least as a default? \\n\\n \\tI would consider it a hard error in IndexWriter if after calling \\n\\tmergePolicy.merge from any of the addIndexes*, there remain segments \\n\\tin other directories.  I think we should catch this &amp; throw an \\n\\texception? \\n\\n It would be easy enough for CMP to block in this case, rather than returning immediately. Wouldn\'t that be better? And I suppose it\'s possible to imagine an API on CMP for specifying this behavior? \\n\\n \\tI opened a separate issue   LUCENE-982   to track this. \\n\\n I think this is good. I think it\'s an interesting issue but not directly related to the refactor? \\n\\n \\tAlthough ... do you think we need need some way for merge policy to \\n\\tstate where the new segment should be inserted into SegmentInfos? \\n\\n Right now I assumed it would replace the left most-segment. \\n\\n Since I don\'t really know the details of what such a merge policy would like, I don\'t really know what it needs. \\n\\n If you\'ve thought about this more, do you have a suggestion? I suppose we could just add an int. But, then again, I\'d do that as a separate function, leaving the original available, so we can do this later, completely compatibly? \\n\\n \\tHmmm, does CMP block on close while it joins to any running merge \\n\\tthreads? \\n\\n Yeah, at least in my sandbox. \\n\\n \\tHow can the user close IndexWriter and abort the running \\n\\tmerges?  I guess CMP would provide a method to abort any running \\n\\tmerges, and user would first call that before calling \\n\\tIndexWriter.close? \\n\\n I hadn\'t really thought about this but I can see that should be made possible. It\'s always safe to abandon a merge so it should be available, for fast, safe, and clean shutdown. \\n\\n \\tTrue, LogDoc as it now stands would never exploit concurrency (it will \\n\\talways return the highest level that needs merging).  But, we could \\n\\trelax that such that if ever the lowest level has &gt; 2*mergeFactor \\n\\tpending segments to merge then we select the 2nd set. \\n\\n Okay. But it will always return that? Still doesn\'t sound concurrent? \\n\\n The thing is, the serial merge policy has no concept of concurrent merges, so if the API is always to select the best merge, until a pervious merge finishes, it will always return that as the best merge. \\n\\n Concurrent is going to require, by hook or by crook, that a merge policy be able to generate a set of non-conflicting merges, is it not? \\n\\n I think the   LUCENE-845   merge policy does this now, given that CMP gathers up the merge calls. I\'m not sure the current   LUCENE-847   merge policy does (I\'d have to double check) because it sometimes will try to use the result of the current merge in the next merge. The   LUCENE-845   merge doesn\'t try to do this which is a  (inconsequential) change? \\n\\n \\tThis is another benefit of the simplified API: MergePolicy.maybeMerge \\n\\twould only be called with a lock already acquired (by IndexWriter) on \\n\\tthe segmentInfos. \\n\\n Do you really mean a lock on segmentInfos or just the lock on IndexWriter? I\'m assuming the latter and I think this is the case for both API models. \\n\\n I don\'t think it\'s feasible to have a lock on segmentInfos separately. Only IndexWriter should change segmentInfos and no code should try to look at segmentInfos w\\/o being called via an IW synch method. \\n\\n This does imply that CMP has to copy any segmentInfos data it plans to use during concurrent merging, since the IW lock is not held during these periods. Then, when the merge is done, segmentInfos is updated in IndexWriter via a synch call to IW#replace. \\n\\n This means IW#segmentInfos can change while a merge is in progress and this has to be accounted for. That\'s what I\'m walking through now.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520374\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520374&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520374\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520374_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520374_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 21:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T21:11:13+0000\'\u003e16\\/Aug\\/07 21:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Note that merge() was added not for users (which I have no strong\u003cbr\\/\u003e\\n&gt; opinion about) but so that, potentially, CMP can check again for\u003cbr\\/\u003e\\n&gt; merges when a set of merge threads completes, i.e., cascade.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, got it.  In fact, then it seems more important that we NOT flush\u003cbr\\/\u003e\\nat this point?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think instead we should leave the methods, not deprecated, as\u003cbr\\/\u003e\\n&gt; &gt; convenience (sugar) methods. Simple things should be simple;\u003cbr\\/\u003e\\n&gt; &gt; complex things should be possible.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think this argues for a LegacyMergePolicy interface again, then?\u003cbr\\/\u003e\\n&gt; If we change the default merge policy and someone changes their code\u003cbr\\/\u003e\\n&gt; to use LogDoc for their own purposes, in both cases the\u003cbr\\/\u003e\\n&gt; getters\\/setters should work? So cast to the interface and as long as\u003cbr\\/\u003e\\n&gt; the merge policy supports this, the getters\\/setters work (unless the\u003cbr\\/\u003e\\n&gt; merge policy decides to throw within), otherwise the getters\\/setters\u003cbr\\/\u003e\\n&gt; throw?\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t think so: I think if someone changes the merge policy to\u003cbr\\/\u003e\\nsomething else, it\'s fine to require that they then do settings\u003cbr\\/\u003e\\ndirectly through that merge policy.  I don\'t think we should bring\u003cbr\\/\u003e\\nback the LegacyMergePolicy interface.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Uh, no: when someone calls optimize that means it really must be\u003cbr\\/\u003e\\n&gt; &gt; done, right? So \\\"optimize\\\" is the right name I think.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Yeah, but it might do nothing. Just as merge might do nothing.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell... that\'s the exception not the rule.  My vote would be for\u003cbr\\/\u003e\\n\\\"maybeMerge(...)\\\"  and \\\"optimize(..)\\\".\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Though, this raises the tricky question of index consistency ...\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Definitely. I\'m still trying to understand all the subtleties here.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; &gt; IndexWriter commits the new segments file right after\u003cbr\\/\u003e\\n&gt; &gt; mergePolicy.merge returns ... so for CMP we suddenly have an\u003cbr\\/\u003e\\n&gt; &gt; unusable index (as seen by an IndexReader).\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; How so? I figured that after mergePolicy.merge returns, in the case\u003cbr\\/\u003e\\n&gt; of CMP with an ongoing merge, segmentInfos won\'t have changed at\u003cbr\\/\u003e\\n&gt; all. Is that a problem?\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is inside addIndexes that we\'re talking about.  It will have\u003cbr\\/\u003e\\nchanged because the added indexes were stuck into the segmentInfos.\u003cbr\\/\u003e\\nIf you commit that segmentInfos, which now references segments in\u003cbr\\/\u003e\\nother directories, the index is inconsistent, until the merge policy\u003cbr\\/\u003e\\nfinishes its work (including copying over segments from other dirs).\u003cbr\\/\u003e\\nIn fact this used to be an issue but was fixed in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-702\\\" title=\\\"Disk full during addIndexes(Directory[]) can corrupt index\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-702\\\"\u003e\u003cdel\u003eLUCENE-702\u003c\\/del\u003e\u003c\\/a\u003e.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Maybe it\'s too ambitious to allow merges of segments from other\u003cbr\\/\u003e\\n&gt; &gt; directories to run concurrently?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Yeah, that might be the case. At least as a default?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think it\'s worse: I think we shouldn\'t allow any mergePolicy to\u003cbr\\/\u003e\\nleave the index inconsistent (failing to copy over segments from other\u003cbr\\/\u003e\\ndirectories).  I think it\'s a bug if the mergePolicy does that and we\u003cbr\\/\u003e\\nshould check &amp; raise an exception, and not commit the new segments\u003cbr\\/\u003e\\nfile.   IndexWriter should in general protect itself from a mergePolicy\u003cbr\\/\u003e\\nthat makes the index inconsistent (and, refuse to commit the resulting\u003cbr\\/\u003e\\nsegments file).\u003c\\/p\u003e\\n\\n\u003cp\u003eWith the proposed \\\"stateless API\\\" we would keep calling the\u003cbr\\/\u003e\\nmergePolicy, after each merge, until it returned null, and then do the\u003cbr\\/\u003e\\ncheck that index is consistent.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I would consider it a hard error in IndexWriter if after calling\u003cbr\\/\u003e\\n&gt; &gt; mergePolicy.merge from any of the addIndexes*, there remain\u003cbr\\/\u003e\\n&gt; &gt; segments in other directories. I think we should catch this &amp;\u003cbr\\/\u003e\\n&gt; &gt; throw an exception?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; It would be easy enough for CMP to block in this case, rather than\u003cbr\\/\u003e\\n&gt; returning immediately. Wouldn\'t that be better? And I suppose it\'s\u003cbr\\/\u003e\\n&gt; possible to imagine an API on CMP for specifying this behavior?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think CMP should indeed block in this case.  I wouldn\'t add an API\u003cbr\\/\u003e\\nto change it.  It\'s too dangerous to allow an index to become\u003cbr\\/\u003e\\ninconsistent.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I opened a separate issue \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-982\\\" title=\\\"Create new method optimize(int maxNumSegments) in IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-982\\\"\u003e\u003cdel\u003eLUCENE-982\u003c\\/del\u003e\u003c\\/a\u003e to track this.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think this is good. I think it\'s an interesting issue but not\u003cbr\\/\u003e\\n&gt; directly related to the refactor?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think it is related: we should not preclude it in this refactoring.\u003cbr\\/\u003e\\nI think we should fix MergePolicy.optimize to take \\\"int\u003cbr\\/\u003e\\nmaxNumSegments\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Although ... do you think we need need some way for merge policy\u003cbr\\/\u003e\\n&gt; &gt; to state where the new segment should be inserted into\u003cbr\\/\u003e\\n&gt; &gt; SegmentInfos?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Right now I assumed it would replace the left most-segment.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Since I don\'t really know the details of what such a merge policy\u003cbr\\/\u003e\\n&gt; would like, I don\'t really know what it needs.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; If you\'ve thought about this more, do you have a suggestion? I\u003cbr\\/\u003e\\n&gt; suppose we could just add an int. But, then again, I\'d do that as a\u003cbr\\/\u003e\\n&gt; separate function, leaving the original available, so we can do this\u003cbr\\/\u003e\\n&gt; later, completely compatibly?\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t have a suggestion \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  And I agree, this is safely postponed while\u003cbr\\/\u003e\\nkeeping future backwards compatibility, so, punt!\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; How can the user close IndexWriter and abort the running merges?  I\u003cbr\\/\u003e\\n&gt; &gt; guess CMP would provide a method to abort any running merges, and\u003cbr\\/\u003e\\n&gt; &gt; user would first call that before calling IndexWriter.close?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I hadn\'t really thought about this but I can see that should be made\u003cbr\\/\u003e\\n&gt; possible. It\'s always safe to abandon a merge so it should be\u003cbr\\/\u003e\\n&gt; available, for fast, safe, and clean shutdown.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK.  Seems like a CMP specific issue (doesn\'t impact this discussion).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; True, LogDoc as it now stands would never exploit concurrency (it\u003cbr\\/\u003e\\n&gt; &gt; will always return the highest level that needs merging). But, we\u003cbr\\/\u003e\\n&gt; &gt; could relax that such that if ever the lowest level has &gt;\u003cbr\\/\u003e\\n&gt; &gt; 2*mergeFactor pending segments to merge then we select the 2nd\u003cbr\\/\u003e\\n&gt; &gt; set.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Okay. But it will always return that? Still doesn\'t sound\u003cbr\\/\u003e\\n&gt; concurrent?\u003c\\/p\u003e\\n\\n\u003cp\u003eNo, after another N (= mergeFactor) flushes, it would return a new\u003cbr\\/\u003e\\nsuggested merge.  I think this gives CMP concurrency to work with.\u003cbr\\/\u003e\\nAlso I think other merge policies (eg the rough suggestion in\u003cbr\\/\u003e\\n\u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-854\\\" title=\\\"Create merge policy that doesn&#39;t periodically inadvertently optimize\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-854\\\"\u003e\u003cdel\u003eLUCENE-854\u003c\\/del\u003e\u003c\\/a\u003e) could provide substantial concurrency.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; The thing is, the serial merge policy has no concept of concurrent\u003cbr\\/\u003e\\n&gt; merges, so if the API is always to select the best merge, until a\u003cbr\\/\u003e\\n&gt; pervious merge finishes, it will always return that as the best\u003cbr\\/\u003e\\n&gt; merge.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Concurrent is going to require, by hook or by crook, that a merge\u003cbr\\/\u003e\\n&gt; policy be able to generate a set of non-conflicting merges, is it\u003cbr\\/\u003e\\n&gt; not?\u003c\\/p\u003e\\n\\n\u003cp\u003eCorrect, if we want more than 1 merge running at once then\u003cbr\\/\u003e\\nmergePolicy must provide non-conflicting merges.\u003c\\/p\u003e\\n\\n\u003cp\u003eBut, providing just a single concurrent merge already gains us\u003cbr\\/\u003e\\nconcurrency of merging with adding of docs.  Just that is a great step\u003cbr\\/\u003e\\nforward, and, it\'s not clear we can expect performance gains by doing\u003cbr\\/\u003e\\n2 merges simultaneously with adding docs.  Have you tested this to\u003cbr\\/\u003e\\nsee?\u003c\\/p\u003e\\n\\n\u003cp\u003eIf we think there are still gains there, we can use the idea above, or\u003cbr\\/\u003e\\napps can use other merge policies (like \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-854\\\" title=\\\"Create merge policy that doesn&#39;t periodically inadvertently optimize\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-854\\\"\u003e\u003cdel\u003eLUCENE-854\u003c\\/del\u003e\u003c\\/a\u003e) that don\'t always\u003cbr\\/\u003e\\nchoose non-concurrent (conflicting) merges.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I think the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge policy does this now, given that CMP\u003cbr\\/\u003e\\n&gt; gathers up the merge calls. I\'m not sure the current \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e\u003cbr\\/\u003e\\n&gt; merge policy does (I\'d have to double check) because it sometimes\u003cbr\\/\u003e\\n&gt; will try to use the result of the current merge in the next\u003cbr\\/\u003e\\n&gt; merge. The \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge doesn\'t try to do this which is a\u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/thumbs_down.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003cbr\\/\u003e\\n&gt; (inconsequential) change?\u003c\\/p\u003e\\n\\n\u003cp\u003eRight, the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge policy doesn\'t look @ the return result of\u003cbr\\/\u003e\\n\\\"merge\\\".  It just looks at the newly created SegmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmmm, in fact, I think your CMP wrapper would not work with the merge\u003cbr\\/\u003e\\npolicy in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, right?  Ie, won\'t it will just recurse forever?\u003cbr\\/\u003e\\nSo actually I don\'t see how your CMP (using the current API) can in\u003cbr\\/\u003e\\ngeneral safely \\\"wrap\\\" around a merge policy w\\/o breaking things?\u003c\\/p\u003e\\n\\n\u003cp\u003eWhereas w\\/ stateless API, where merge policy just returns what should\u003cbr\\/\u003e\\nbe merged rather than executing it itself and cascading, would work\u003cbr\\/\u003e\\nfine.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; This is another benefit of the simplified API:\u003cbr\\/\u003e\\n&gt; &gt; MergePolicy.maybeMerge would only be called with a lock already\u003cbr\\/\u003e\\n&gt; &gt; acquired (by IndexWriter) on the segmentInfos.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Do you really mean a lock on segmentInfos or just the lock on\u003cbr\\/\u003e\\n&gt; IndexWriter? I\'m assuming the latter and I think this is the case\u003cbr\\/\u003e\\n&gt; for both API models.\u003c\\/p\u003e\\n\\n\u003cp\u003eBut, if you lock on IndexWriter, what about apps that use multiple\u003cbr\\/\u003e\\nthreads to add documents and but don\'t use CMP?  When one thread gets\u003cbr\\/\u003e\\ntied up merging, you\'ll then block on the other synchronized methods?\u003cbr\\/\u003e\\nAnd you also can\'t flush from other threads either?  I think flushing\u003cbr\\/\u003e\\na new segment should be allowed to run concurrently with the merge?\u003c\\/p\u003e\\n\\n\u003cp\u003eWhereas if you lock only segmentInfos, and use the proposed stateless\u003cbr\\/\u003e\\nAPI, I think the other threads would not be blocked?  I guess I don\'t\u003cbr\\/\u003e\\nsee the reason to synchronize on IndexWriter instead of segmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003eNet\\/net I\'m still thinking we should simplify this API to be\u003cbr\\/\u003e\\nstateless.  I think there are a number of benefits:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eWe would no longer need to add a new IndexMerger interface that\u003cbr\\/\u003e\\n    adds unecessary complexity to Lucnee (and, make the awkward\u003cbr\\/\u003e\\n    decisions up front on which IndexWriter fields are allowed to be\u003cbr\\/\u003e\\n    visible through the interface).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eKeep CMP simpler (only top of stack (where I think \\\"macro\\\"\u003cbr\\/\u003e\\n    concurrency should live), not top and bottom).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eWork correctly as wrapper around other merge policies (ie not hit\u003cbr\\/\u003e\\n    infinite recursion because mergePolicy had naturally assumed that\u003cbr\\/\u003e\\n    \\\"merge\\\" would have changed the segmentInfos)\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eAllows locking on segmentInfos (not IndexWriter), and allows\u003cbr\\/\u003e\\n    concurrency on multiple threads adding docs even without using\u003cbr\\/\u003e\\n    CMP.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520374_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520374_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 21:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T21:11:13+0000\'\u003e16\\/Aug\\/07 21:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Note that merge() was added not for users (which I have no strong \\n&gt; opinion about) but so that, potentially, CMP can check again for \\n&gt; merges when a set of merge threads completes, i.e., cascade. \\n\\n OK, got it.  In fact, then it seems more important that we NOT flush \\nat this point? \\n\\n &gt; &gt; I think instead we should leave the methods, not deprecated, as \\n&gt; &gt; convenience (sugar) methods. Simple things should be simple; \\n&gt; &gt; complex things should be possible. \\n&gt; \\n&gt; I think this argues for a LegacyMergePolicy interface again, then? \\n&gt; If we change the default merge policy and someone changes their code \\n&gt; to use LogDoc for their own purposes, in both cases the \\n&gt; getters\\/setters should work? So cast to the interface and as long as \\n&gt; the merge policy supports this, the getters\\/setters work (unless the \\n&gt; merge policy decides to throw within), otherwise the getters\\/setters \\n&gt; throw? \\n\\n I don\'t think so: I think if someone changes the merge policy to \\nsomething else, it\'s fine to require that they then do settings \\ndirectly through that merge policy.  I don\'t think we should bring \\nback the LegacyMergePolicy interface. \\n\\n &gt; &gt; Uh, no: when someone calls optimize that means it really must be \\n&gt; &gt; done, right? So \\\"optimize\\\" is the right name I think. \\n&gt;  \\n&gt; Yeah, but it might do nothing. Just as merge might do nothing. \\n\\n Well... that\'s the exception not the rule.  My vote would be for \\n\\\"maybeMerge(...)\\\"  and \\\"optimize(..)\\\". \\n\\n &gt; &gt; Though, this raises the tricky question of index consistency ... \\n&gt;  \\n&gt; Definitely. I\'m still trying to understand all the subtleties here. \\n&gt; \\n&gt; &gt; IndexWriter commits the new segments file right after \\n&gt; &gt; mergePolicy.merge returns ... so for CMP we suddenly have an \\n&gt; &gt; unusable index (as seen by an IndexReader). \\n&gt; \\n&gt; How so? I figured that after mergePolicy.merge returns, in the case \\n&gt; of CMP with an ongoing merge, segmentInfos won\'t have changed at \\n&gt; all. Is that a problem? \\n\\n This is inside addIndexes that we\'re talking about.  It will have \\nchanged because the added indexes were stuck into the segmentInfos. \\nIf you commit that segmentInfos, which now references segments in \\nother directories, the index is inconsistent, until the merge policy \\nfinishes its work (including copying over segments from other dirs). \\nIn fact this used to be an issue but was fixed in   LUCENE-702  . \\n\\n &gt; &gt; Maybe it\'s too ambitious to allow merges of segments from other \\n&gt; &gt; directories to run concurrently? \\n&gt;  \\n&gt; Yeah, that might be the case. At least as a default? \\n\\n I think it\'s worse: I think we shouldn\'t allow any mergePolicy to \\nleave the index inconsistent (failing to copy over segments from other \\ndirectories).  I think it\'s a bug if the mergePolicy does that and we \\nshould check &amp; raise an exception, and not commit the new segments \\nfile.   IndexWriter should in general protect itself from a mergePolicy \\nthat makes the index inconsistent (and, refuse to commit the resulting \\nsegments file). \\n\\n With the proposed \\\"stateless API\\\" we would keep calling the \\nmergePolicy, after each merge, until it returned null, and then do the \\ncheck that index is consistent. \\n\\n &gt; &gt; I would consider it a hard error in IndexWriter if after calling \\n&gt; &gt; mergePolicy.merge from any of the addIndexes*, there remain \\n&gt; &gt; segments in other directories. I think we should catch this &amp; \\n&gt; &gt; throw an exception? \\n&gt; \\n&gt; It would be easy enough for CMP to block in this case, rather than \\n&gt; returning immediately. Wouldn\'t that be better? And I suppose it\'s \\n&gt; possible to imagine an API on CMP for specifying this behavior? \\n\\n I think CMP should indeed block in this case.  I wouldn\'t add an API \\nto change it.  It\'s too dangerous to allow an index to become \\ninconsistent. \\n\\n &gt; &gt; I opened a separate issue   LUCENE-982   to track this. \\n&gt; \\n&gt; I think this is good. I think it\'s an interesting issue but not \\n&gt; directly related to the refactor? \\n\\n I think it is related: we should not preclude it in this refactoring. \\nI think we should fix MergePolicy.optimize to take \\\"int \\nmaxNumSegments\\\"? \\n\\n &gt; &gt; Although ... do you think we need need some way for merge policy \\n&gt; &gt; to state where the new segment should be inserted into \\n&gt; &gt; SegmentInfos? \\n&gt; \\n&gt; Right now I assumed it would replace the left most-segment. \\n&gt; \\n&gt; Since I don\'t really know the details of what such a merge policy \\n&gt; would like, I don\'t really know what it needs. \\n&gt; \\n&gt; If you\'ve thought about this more, do you have a suggestion? I \\n&gt; suppose we could just add an int. But, then again, I\'d do that as a \\n&gt; separate function, leaving the original available, so we can do this \\n&gt; later, completely compatibly? \\n\\n I don\'t have a suggestion    And I agree, this is safely postponed while \\nkeeping future backwards compatibility, so, punt! \\n\\n &gt; &gt; How can the user close IndexWriter and abort the running merges?  I \\n&gt; &gt; guess CMP would provide a method to abort any running merges, and \\n&gt; &gt; user would first call that before calling IndexWriter.close? \\n&gt; \\n&gt; I hadn\'t really thought about this but I can see that should be made \\n&gt; possible. It\'s always safe to abandon a merge so it should be \\n&gt; available, for fast, safe, and clean shutdown. \\n\\n OK.  Seems like a CMP specific issue (doesn\'t impact this discussion). \\n\\n &gt; &gt; True, LogDoc as it now stands would never exploit concurrency (it \\n&gt; &gt; will always return the highest level that needs merging). But, we \\n&gt; &gt; could relax that such that if ever the lowest level has &gt; \\n&gt; &gt; 2*mergeFactor pending segments to merge then we select the 2nd \\n&gt; &gt; set. \\n&gt;  \\n&gt; Okay. But it will always return that? Still doesn\'t sound \\n&gt; concurrent? \\n\\n No, after another N (= mergeFactor) flushes, it would return a new \\nsuggested merge.  I think this gives CMP concurrency to work with. \\nAlso I think other merge policies (eg the rough suggestion in \\n  LUCENE-854  ) could provide substantial concurrency. \\n\\n &gt; The thing is, the serial merge policy has no concept of concurrent \\n&gt; merges, so if the API is always to select the best merge, until a \\n&gt; pervious merge finishes, it will always return that as the best \\n&gt; merge. \\n&gt; \\n&gt; Concurrent is going to require, by hook or by crook, that a merge \\n&gt; policy be able to generate a set of non-conflicting merges, is it \\n&gt; not? \\n\\n Correct, if we want more than 1 merge running at once then \\nmergePolicy must provide non-conflicting merges. \\n\\n But, providing just a single concurrent merge already gains us \\nconcurrency of merging with adding of docs.  Just that is a great step \\nforward, and, it\'s not clear we can expect performance gains by doing \\n2 merges simultaneously with adding docs.  Have you tested this to \\nsee? \\n\\n If we think there are still gains there, we can use the idea above, or \\napps can use other merge policies (like   LUCENE-854  ) that don\'t always \\nchoose non-concurrent (conflicting) merges. \\n\\n &gt; I think the   LUCENE-845   merge policy does this now, given that CMP \\n&gt; gathers up the merge calls. I\'m not sure the current   LUCENE-847   \\n&gt; merge policy does (I\'d have to double check) because it sometimes \\n&gt; will try to use the result of the current merge in the next \\n&gt; merge. The   LUCENE-845   merge doesn\'t try to do this which is a  \\n&gt; (inconsequential) change? \\n\\n Right, the   LUCENE-845   merge policy doesn\'t look @ the return result of \\n\\\"merge\\\".  It just looks at the newly created SegmentInfos. \\n\\n Hmmmm, in fact, I think your CMP wrapper would not work with the merge \\npolicy in   LUCENE-845  , right?  Ie, won\'t it will just recurse forever? \\nSo actually I don\'t see how your CMP (using the current API) can in \\ngeneral safely \\\"wrap\\\" around a merge policy w\\/o breaking things? \\n\\n Whereas w\\/ stateless API, where merge policy just returns what should \\nbe merged rather than executing it itself and cascading, would work \\nfine. \\n\\n &gt; &gt; This is another benefit of the simplified API: \\n&gt; &gt; MergePolicy.maybeMerge would only be called with a lock already \\n&gt; &gt; acquired (by IndexWriter) on the segmentInfos. \\n&gt; \\n&gt; Do you really mean a lock on segmentInfos or just the lock on \\n&gt; IndexWriter? I\'m assuming the latter and I think this is the case \\n&gt; for both API models. \\n\\n But, if you lock on IndexWriter, what about apps that use multiple \\nthreads to add documents and but don\'t use CMP?  When one thread gets \\ntied up merging, you\'ll then block on the other synchronized methods? \\nAnd you also can\'t flush from other threads either?  I think flushing \\na new segment should be allowed to run concurrently with the merge? \\n\\n Whereas if you lock only segmentInfos, and use the proposed stateless \\nAPI, I think the other threads would not be blocked?  I guess I don\'t \\nsee the reason to synchronize on IndexWriter instead of segmentInfos. \\n\\n Net\\/net I\'m still thinking we should simplify this API to be \\nstateless.  I think there are a number of benefits: \\n\\n \\n\\t We would no longer need to add a new IndexMerger interface that \\n    adds unecessary complexity to Lucnee (and, make the awkward \\n    decisions up front on which IndexWriter fields are allowed to be \\n    visible through the interface). \\n \\n\\n\\n \\n\\t Keep CMP simpler (only top of stack (where I think \\\"macro\\\" \\n    concurrency should live), not top and bottom). \\n \\n\\n\\n \\n\\t Work correctly as wrapper around other merge policies (ie not hit \\n    infinite recursion because mergePolicy had naturally assumed that \\n    \\\"merge\\\" would have changed the segmentInfos) \\n \\n\\n\\n \\n\\t Allows locking on segmentInfos (not IndexWriter), and allows \\n    concurrency on multiple threads adding docs even without using \\n    CMP. \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520408\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520408&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520408\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520408_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520408_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 23:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T23:20:38+0000\'\u003e16\\/Aug\\/07 23:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tI don\'t think so: I think if someone changes the merge policy to\u003cbr\\/\u003e\\n\\tsomething else, it\'s fine to require that they then do settings\u003cbr\\/\u003e\\n\\tdirectly through that merge policy.\u003c\\/p\u003e\\n\\n\u003cp\u003eYou\'re going to want to change the default merge policy, right?  So you\'re going to change the hard cast in IW to that policy? So it\'ll fail for anyone that wants to just getMergePolicy back to the old policy?\u003c\\/p\u003e\\n\\n\u003cp\u003eIf that\'s the case, I\'m going to keep those tests the way they are because when you do change the policy, I\'m assuming you\'ll keep many of them, just add the manual setMergePolicy(), and they\'ll need to have those casts put back in?\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe we just put it in MergePolicy interface and let them throw (e.g., via MergePolicyBase) if called on an unsupported merge policy? That\'s moving from compile time checking to run time checking, but ... \u003c\\/p\u003e\\n\\n\u003cp\u003e\\tThis is inside addIndexes that we\'re talking about.\u003c\\/p\u003e\\n\\n\u003cp\u003eAh. Right.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think we shouldn\'t allow any mergePolicy to\u003cbr\\/\u003e\\n\\tleave the index inconsistent (failing to copy over segments from other\u003cbr\\/\u003e\\n\\tdirectories).\u003c\\/p\u003e\\n\\n\u003cp\u003eThat makes sense to me. CMP could enforce this, even in the case of concurrent merges.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tNo, after another N (= mergeFactor) flushes, it would return a new\u003cbr\\/\u003e\\n\\tsuggested merge.\u003c\\/p\u003e\\n\\n\u003cp\u003eOkay. I think I\'m following you here.\u003c\\/p\u003e\\n\\n\u003cp\u003eHere\'s what I understand: in your model, (1) each call to merge will only ever generate one merge thread (regardless of how many levels might be full) and (2) you can get concurrency out of this as long as you consider a level \\\"merge worthy\\\" as different from \\\"full\\\", i.e., blocking).\u003c\\/p\u003e\\n\\n\u003cp\u003eYou did say  \u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; But, we\u003cbr\\/\u003e\\n&gt; &gt; could relax that such that if ever the lowest level has &gt;\u003cbr\\/\u003e\\n&gt; &gt; 2*mergeFactor pending segments to merge then we select the 2nd\u003cbr\\/\u003e\\n&gt; &gt; set.\u003c\\/p\u003e\\n\\n\u003cp\u003eAnd I think you\'d want to modify that to select the lowest sufficiently over subscribed level, not just the lowest level if it\'s oversubscribed?\u003c\\/p\u003e\\n\\n\u003cp\u003ePerhaps this is sufficient, but not necessary? I see it as simpler just to have the merge policy (abstractly) generate a set of non-conflicting merges and let someone else worry about scheduling them.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tBut, providing just a single concurrent merge already gains us\u003cbr\\/\u003e\\n\\tconcurrency of merging with adding of docs.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m worried about when you start the leftmost merge, that, say, is going to take a day. With a steady influx of docs, it\'s not going to be long before you need another merge and if you have only one thread, you\'re going to block for the rest of the day. You\'ve bought a little concurrency, but it\'s the almost day-long block I really want to avoid.\u003c\\/p\u003e\\n\\n\u003cp\u003eWith a log-like policy, I think it\'s feasible to have logN threads. You might not want them all doing disk i\\/o at the same time: you\'d want to prioritize threads on the small merges and\\/or suspend large merge threads.  The speed with which the larger merge threads can vary when other merges are taking place, you just have to not stop them and start over. \u003c\\/p\u003e\\n\\n\u003cp\u003e\\tRight, the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge policy doesn\'t look @ the return result of\u003cbr\\/\u003e\\n\\t\\\"merge\\\".  It just looks at the newly created SegmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah. My thinking was this would be tweaked. If merger.merge returns a valid number of docs, it could recurse as it does. If merger.merge returned -1 (which CMP does), it would not recurse but simply continue the loop.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tHmmmm, in fact, I think your CMP wrapper would not work with the merge\u003cbr\\/\u003e\\n\\tpolicy in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, right?  Ie, won\'t it will just recurse forever?\u003cbr\\/\u003e\\n\\tSo actually I don\'t see how your CMP (using the current API) can in\u003cbr\\/\u003e\\n\\tgeneral safely \\\"wrap\\\" around a merge policy w\\/o breaking things?\u003c\\/p\u003e\\n\\n\u003cp\u003eI think it\'s safe, just not concurrent. The recursion would generate the same set of segments to merge and CMP would make the second call block (abstractly, anyway: it actually throws an exception that unwinds the stack and causes the call to start again from the top when the conflicting merge finishes).\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tBut, if you lock on IndexWriter, what about apps that use multiple\u003cbr\\/\u003e\\n\\tthreads to add documents and but don\'t use CMP?  When one thread gets\u003cbr\\/\u003e\\n\\ttied up merging, you\'ll then block on the other synchronized methods?\u003cbr\\/\u003e\\n\\tAnd you also can\'t flush from other threads either?  I think flushing\u003cbr\\/\u003e\\n\\ta new segment should be allowed to run concurrently with the merge?\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m not sure I\'m following this. That\'s what happens now, right? Are you trying to get more concurrency then there is now w\\/o using CMP? I certainly haven\'t been trying to do that.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI guess I don\'t\u003cbr\\/\u003e\\n\\tsee the reason to synchronize on IndexWriter instead of segmentInfos.\u003c\\/p\u003e\\n\\n\u003cp\u003eI looked at trying to make IW work when a synchronization of IW didn\'t imply a synchronization of segmentInfos. It\'s a very, very heavily used little data structure. I found it very hard to convince myself I could catch all the places locks would be required. And at the same time, I seemed to be able to do everything I needed with IW locking.\u003c\\/p\u003e\\n\\n\u003cp\u003eThat said, the code\'s not done, so ....\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tNet\\/net I\'m still thinking we should simplify this API to be\u003cbr\\/\u003e\\n\\tstateless.  I think there are a number of benefits:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eWe would no longer need to add a new IndexMerger interface that\u003cbr\\/\u003e\\n\\t    adds unecessary complexity to Lucnee (and, make the awkward\u003cbr\\/\u003e\\n\\t    decisions up front on which IndexWriter fields are allowed to be\u003cbr\\/\u003e\\n\\t    visible through the interface).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eKeep CMP simpler (only top of stack (where I think \\\"macro\\\"\u003cbr\\/\u003e\\n\\t    concurrency should live), not top and bottom).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eWork correctly as wrapper around other merge policies (ie not hit\u003cbr\\/\u003e\\n\\t    infinite recursion because mergePolicy had naturally assumed that\u003cbr\\/\u003e\\n\\t    \\\"merge\\\" would have changed the segmentInfos)\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eAllows locking on segmentInfos (not IndexWriter), and allows\u003cbr\\/\u003e\\n \\t   concurrency on multiple threads adding docs even without using\u003cbr\\/\u003e\\n \\t   CMP.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eHmmm ... I guess our approaches are pretty different. If you want to take a stab at this ...\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520408_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520408_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'16\\/Aug\\/07 23:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-16T23:20:38+0000\'\u003e16\\/Aug\\/07 23:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tI don\'t think so: I think if someone changes the merge policy to \\n\\tsomething else, it\'s fine to require that they then do settings \\n\\tdirectly through that merge policy. \\n\\n You\'re going to want to change the default merge policy, right?  So you\'re going to change the hard cast in IW to that policy? So it\'ll fail for anyone that wants to just getMergePolicy back to the old policy? \\n\\n If that\'s the case, I\'m going to keep those tests the way they are because when you do change the policy, I\'m assuming you\'ll keep many of them, just add the manual setMergePolicy(), and they\'ll need to have those casts put back in? \\n\\n Maybe we just put it in MergePolicy interface and let them throw (e.g., via MergePolicyBase) if called on an unsupported merge policy? That\'s moving from compile time checking to run time checking, but ...  \\n\\n \\tThis is inside addIndexes that we\'re talking about. \\n\\n Ah. Right. \\n\\n \\tI think we shouldn\'t allow any mergePolicy to \\n\\tleave the index inconsistent (failing to copy over segments from other \\n\\tdirectories). \\n\\n That makes sense to me. CMP could enforce this, even in the case of concurrent merges. \\n\\n \\tNo, after another N (= mergeFactor) flushes, it would return a new \\n\\tsuggested merge. \\n\\n Okay. I think I\'m following you here. \\n\\n Here\'s what I understand: in your model, (1) each call to merge will only ever generate one merge thread (regardless of how many levels might be full) and (2) you can get concurrency out of this as long as you consider a level \\\"merge worthy\\\" as different from \\\"full\\\", i.e., blocking). \\n\\n You did say   \\n\\n &gt; &gt; But, we \\n&gt; &gt; could relax that such that if ever the lowest level has &gt; \\n&gt; &gt; 2*mergeFactor pending segments to merge then we select the 2nd \\n&gt; &gt; set. \\n\\n And I think you\'d want to modify that to select the lowest sufficiently over subscribed level, not just the lowest level if it\'s oversubscribed? \\n\\n Perhaps this is sufficient, but not necessary? I see it as simpler just to have the merge policy (abstractly) generate a set of non-conflicting merges and let someone else worry about scheduling them. \\n\\n \\tBut, providing just a single concurrent merge already gains us \\n\\tconcurrency of merging with adding of docs. \\n\\n I\'m worried about when you start the leftmost merge, that, say, is going to take a day. With a steady influx of docs, it\'s not going to be long before you need another merge and if you have only one thread, you\'re going to block for the rest of the day. You\'ve bought a little concurrency, but it\'s the almost day-long block I really want to avoid. \\n\\n With a log-like policy, I think it\'s feasible to have logN threads. You might not want them all doing disk i\\/o at the same time: you\'d want to prioritize threads on the small merges and\\/or suspend large merge threads.  The speed with which the larger merge threads can vary when other merges are taking place, you just have to not stop them and start over.  \\n\\n \\tRight, the   LUCENE-845   merge policy doesn\'t look @ the return result of \\n\\t\\\"merge\\\".  It just looks at the newly created SegmentInfos. \\n\\n Yeah. My thinking was this would be tweaked. If merger.merge returns a valid number of docs, it could recurse as it does. If merger.merge returned -1 (which CMP does), it would not recurse but simply continue the loop. \\n\\n \\tHmmmm, in fact, I think your CMP wrapper would not work with the merge \\n\\tpolicy in   LUCENE-845  , right?  Ie, won\'t it will just recurse forever? \\n\\tSo actually I don\'t see how your CMP (using the current API) can in \\n\\tgeneral safely \\\"wrap\\\" around a merge policy w\\/o breaking things? \\n\\n I think it\'s safe, just not concurrent. The recursion would generate the same set of segments to merge and CMP would make the second call block (abstractly, anyway: it actually throws an exception that unwinds the stack and causes the call to start again from the top when the conflicting merge finishes). \\n\\n \\tBut, if you lock on IndexWriter, what about apps that use multiple \\n\\tthreads to add documents and but don\'t use CMP?  When one thread gets \\n\\ttied up merging, you\'ll then block on the other synchronized methods? \\n\\tAnd you also can\'t flush from other threads either?  I think flushing \\n\\ta new segment should be allowed to run concurrently with the merge? \\n\\n I\'m not sure I\'m following this. That\'s what happens now, right? Are you trying to get more concurrency then there is now w\\/o using CMP? I certainly haven\'t been trying to do that. \\n\\n \\tI guess I don\'t \\n\\tsee the reason to synchronize on IndexWriter instead of segmentInfos. \\n\\n I looked at trying to make IW work when a synchronization of IW didn\'t imply a synchronization of segmentInfos. It\'s a very, very heavily used little data structure. I found it very hard to convince myself I could catch all the places locks would be required. And at the same time, I seemed to be able to do everything I needed with IW locking. \\n\\n That said, the code\'s not done, so .... \\n\\n \\tNet\\/net I\'m still thinking we should simplify this API to be \\n\\tstateless.  I think there are a number of benefits: \\n\\n \\n\\t We would no longer need to add a new IndexMerger interface that \\n\\t    adds unecessary complexity to Lucnee (and, make the awkward \\n\\t    decisions up front on which IndexWriter fields are allowed to be \\n\\t    visible through the interface). \\n \\n\\n\\n \\n\\t Keep CMP simpler (only top of stack (where I think \\\"macro\\\" \\n\\t    concurrency should live), not top and bottom). \\n \\n\\n\\n \\n\\t Work correctly as wrapper around other merge policies (ie not hit \\n\\t    infinite recursion because mergePolicy had naturally assumed that \\n\\t    \\\"merge\\\" would have changed the segmentInfos) \\n \\n\\n\\n \\n\\t Allows locking on segmentInfos (not IndexWriter), and allows \\n \\t   concurrency on multiple threads adding docs even without using \\n \\t   CMP. \\n \\n\\n\\n Hmmm ... I guess our approaches are pretty different. If you want to take a stab at this ...              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520874\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520874&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520874\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520874_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520874_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'18\\/Aug\\/07 18:01\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-18T18:01:10+0000\'\u003e18\\/Aug\\/07 18:01\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; &gt; I don\'t think so: I think if someone changes the merge policy to\u003cbr\\/\u003e\\n&gt; &gt; something else, it\'s fine to require that they then do settings\u003cbr\\/\u003e\\n&gt; &gt; directly through that merge policy.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; You\'re going to want to change the default merge policy, right?  So\u003cbr\\/\u003e\\n&gt; you\'re going to change the hard cast in IW to that policy? So it\'ll\u003cbr\\/\u003e\\n&gt; fail for anyone that wants to just getMergePolicy back to the old\u003cbr\\/\u003e\\n&gt; policy?\u003c\\/p\u003e\\n\\n\u003cp\u003eI don\'t really follow... my feeling is we should not deprecate\u003cbr\\/\u003e\\nsetUseCompoundFile, setMergeFactor, setMaxMergeDocs.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I think we shouldn\'t allow any mergePolicy to leave the index\u003cbr\\/\u003e\\n&gt; &gt; inconsistent (failing to copy over segments from other\u003cbr\\/\u003e\\n&gt; &gt; directories).\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; That makes sense to me. CMP could enforce this, even in the case of\u003cbr\\/\u003e\\n&gt; concurrent merges.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think IndexWriter should enforce it?  Ie no merge policy should be\u003cbr\\/\u003e\\nallowed to leave segments in other dirs (= at inconsistent index) at\u003cbr\\/\u003e\\npoint of commit.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Perhaps this is sufficient, but not necessary? I see it as simpler\u003cbr\\/\u003e\\n&gt; just to have the merge policy (abstractly) generate a set of\u003cbr\\/\u003e\\n&gt; non-conflicting merges and let someone else worry about scheduling\u003cbr\\/\u003e\\n&gt; them.\u003c\\/p\u003e\\n\\n\u003cp\u003eI like that idea \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  It fits well w\\/ the stateless API.  Ie, merge\u003cbr\\/\u003e\\npolicy returns all possible merges and \\\"someone above\\\" takes care of\u003cbr\\/\u003e\\nscheduling them.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; But, providing just a single concurrent merge already gains us\u003cbr\\/\u003e\\n&gt; &gt; concurrency of merging with adding of docs.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I\'m worried about when you start the leftmost merge, that, say, is\u003cbr\\/\u003e\\n&gt; going to take a day. With a steady influx of docs, it\'s not going to\u003cbr\\/\u003e\\n&gt; be long before you need another merge and if you have only one\u003cbr\\/\u003e\\n&gt; thread, you\'re going to block for the rest of the day. You\'ve bought\u003cbr\\/\u003e\\n&gt; a little concurrency, but it\'s the almost day-long block I really\u003cbr\\/\u003e\\n&gt; want to avoid.\u003c\\/p\u003e\\n\\n\u003cp\u003eAhh ... very good point.  I agree.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; With a log-like policy, I think it\'s feasible to have logN\u003cbr\\/\u003e\\n&gt; threads. You might not want them all doing disk i\\/o at the same\u003cbr\\/\u003e\\n&gt; time: you\'d want to prioritize threads on the small merges and\\/or\u003cbr\\/\u003e\\n&gt; suspend large merge threads.  The speed with which the larger merge\u003cbr\\/\u003e\\n&gt; threads can vary when other merges are taking place, you just have\u003cbr\\/\u003e\\n&gt; to not stop them and start over.\u003c\\/p\u003e\\n\\n\u003cp\u003eAgreed: CMP should do this.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Right, the \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e merge policy doesn\'t look @ the return\u003cbr\\/\u003e\\n&gt; &gt; result of \\\"merge\\\".  It just looks at the newly created\u003cbr\\/\u003e\\n&gt; &gt; SegmentInfos.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Yeah. My thinking was this would be tweaked. If merger.merge returns\u003cbr\\/\u003e\\n&gt; a valid number of docs, it could recurse as it does. If merger.merge\u003cbr\\/\u003e\\n&gt; returned -1 (which CMP does), it would not recurse but simply\u003cbr\\/\u003e\\n&gt; continue the loop.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmm.  This means each merge policy must know whether it\'s talking to\u003cbr\\/\u003e\\nCMP or IndexWriter underneith?  With the stateless approach this\u003cbr\\/\u003e\\nwouldn\'t happen.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Hmmmm, in fact, I think your CMP wrapper would not work with the\u003cbr\\/\u003e\\n&gt; &gt; merge policy in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, right?  Ie, won\'t it will just recurse\u003cbr\\/\u003e\\n&gt; &gt; forever?  So actually I don\'t see how your CMP (using the current\u003cbr\\/\u003e\\n&gt; &gt; API) can in general safely \\\"wrap\\\" around a merge policy w\\/o\u003cbr\\/\u003e\\n&gt; &gt; breaking things?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think it\'s safe, just not concurrent. The recursion would generate\u003cbr\\/\u003e\\n&gt; the same set of segments to merge and CMP would make the second call\u003cbr\\/\u003e\\n&gt; block (abstractly, anyway: it actually throws an exception that\u003cbr\\/\u003e\\n&gt; unwinds the stack and causes the call to start again from the top\u003cbr\\/\u003e\\n&gt; when the conflicting merge finishes).\u003c\\/p\u003e\\n\\n\u003cp\u003eOh I see...  that\'s kind of sneaky (planning on using exceptions to\u003cbr\\/\u003e\\nabort a merge requested by the policy).  I think the stateless\u003cbr\\/\u003e\\napproach would be cleaner here.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; But, if you lock on IndexWriter, what about apps that use multiple\u003cbr\\/\u003e\\n&gt; &gt; threads to add documents and but don\'t use CMP?  When one thread\u003cbr\\/\u003e\\n&gt; &gt; gets tied up merging, you\'ll then block on the other synchronized\u003cbr\\/\u003e\\n&gt; &gt; methods?  And you also can\'t flush from other threads either?  I\u003cbr\\/\u003e\\n&gt; &gt; think flushing a new segment should be allowed to run concurrently\u003cbr\\/\u003e\\n&gt; &gt; with the merge?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I\'m not sure I\'m following this. That\'s what happens now, right? Are\u003cbr\\/\u003e\\n&gt; you trying to get more concurrency then there is now w\\/o using CMP?\u003cbr\\/\u003e\\n&gt; I certainly haven\'t been trying to do that.\u003c\\/p\u003e\\n\\n\u003cp\u003eTrue, this is something new.  But since you\'re already doing the work\u003cbr\\/\u003e\\nto allow a merge to run in the BG without blocking adding of docs,\u003cbr\\/\u003e\\nflushing, etc, wouldn\'t this come nearly for free?  Actually I think\u003cbr\\/\u003e\\nall that\'s necessary, regardless of sync\'ing on IndexWriter or\u003cbr\\/\u003e\\nSegmentInfos is to move the \\\"if (triggerMerge)\\\" out of the\u003cbr\\/\u003e\\nsynchronized method\\/block.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; I guess I don\'t see the reason to synchronize on IndexWriter\u003cbr\\/\u003e\\n&gt; &gt; instead of segmentInfos.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I looked at trying to make IW work when a synchronization of IW\u003cbr\\/\u003e\\n&gt; didn\'t imply a synchronization of segmentInfos. It\'s a very, very\u003cbr\\/\u003e\\n&gt; heavily used little data structure. I found it very hard to convince\u003cbr\\/\u003e\\n&gt; myself I could catch all the places locks would be required. And at\u003cbr\\/\u003e\\n&gt; the same time, I seemed to be able to do everything I needed with IW\u003cbr\\/\u003e\\n&gt; locking.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, eg flush() now synchronizes on IndexWriter: we don\'t want 2\u003cbr\\/\u003e\\nthreads doing this at once.  But, the touching of segmentInfos inside\u003cbr\\/\u003e\\nflush (to add the new SegmentInfo) is a tiny fleeting event (like\u003cbr\\/\u003e\\nreplace) and so you would want segmentInfos to be free to change while\u003cbr\\/\u003e\\nthe flushing was running (eg by a BG merge that has finished).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Hmmm ... I guess our approaches are pretty different. If you want to\u003cbr\\/\u003e\\n&gt; take a stab at this ...\u003c\\/p\u003e\\n\\n\u003cp\u003eOK I will try to take a rough stab a the stateless approach....\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12520874_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520874_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'18\\/Aug\\/07 18:01\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-18T18:01:10+0000\'\u003e18\\/Aug\\/07 18:01\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; &gt; I don\'t think so: I think if someone changes the merge policy to \\n&gt; &gt; something else, it\'s fine to require that they then do settings \\n&gt; &gt; directly through that merge policy. \\n&gt; \\n&gt; You\'re going to want to change the default merge policy, right?  So \\n&gt; you\'re going to change the hard cast in IW to that policy? So it\'ll \\n&gt; fail for anyone that wants to just getMergePolicy back to the old \\n&gt; policy? \\n\\n I don\'t really follow... my feeling is we should not deprecate \\nsetUseCompoundFile, setMergeFactor, setMaxMergeDocs. \\n\\n &gt; &gt; I think we shouldn\'t allow any mergePolicy to leave the index \\n&gt; &gt; inconsistent (failing to copy over segments from other \\n&gt; &gt; directories). \\n&gt; \\n&gt; That makes sense to me. CMP could enforce this, even in the case of \\n&gt; concurrent merges. \\n\\n I think IndexWriter should enforce it?  Ie no merge policy should be \\nallowed to leave segments in other dirs (= at inconsistent index) at \\npoint of commit. \\n\\n &gt; Perhaps this is sufficient, but not necessary? I see it as simpler \\n&gt; just to have the merge policy (abstractly) generate a set of \\n&gt; non-conflicting merges and let someone else worry about scheduling \\n&gt; them. \\n\\n I like that idea    It fits well w\\/ the stateless API.  Ie, merge \\npolicy returns all possible merges and \\\"someone above\\\" takes care of \\nscheduling them. \\n\\n &gt; &gt; But, providing just a single concurrent merge already gains us \\n&gt; &gt; concurrency of merging with adding of docs. \\n&gt; \\n&gt; I\'m worried about when you start the leftmost merge, that, say, is \\n&gt; going to take a day. With a steady influx of docs, it\'s not going to \\n&gt; be long before you need another merge and if you have only one \\n&gt; thread, you\'re going to block for the rest of the day. You\'ve bought \\n&gt; a little concurrency, but it\'s the almost day-long block I really \\n&gt; want to avoid. \\n\\n Ahh ... very good point.  I agree. \\n\\n &gt; With a log-like policy, I think it\'s feasible to have logN \\n&gt; threads. You might not want them all doing disk i\\/o at the same \\n&gt; time: you\'d want to prioritize threads on the small merges and\\/or \\n&gt; suspend large merge threads.  The speed with which the larger merge \\n&gt; threads can vary when other merges are taking place, you just have \\n&gt; to not stop them and start over. \\n\\n Agreed: CMP should do this. \\n\\n &gt; &gt; Right, the   LUCENE-845   merge policy doesn\'t look @ the return \\n&gt; &gt; result of \\\"merge\\\".  It just looks at the newly created \\n&gt; &gt; SegmentInfos. \\n&gt; \\n&gt; Yeah. My thinking was this would be tweaked. If merger.merge returns \\n&gt; a valid number of docs, it could recurse as it does. If merger.merge \\n&gt; returned -1 (which CMP does), it would not recurse but simply \\n&gt; continue the loop. \\n\\n Hmm.  This means each merge policy must know whether it\'s talking to \\nCMP or IndexWriter underneith?  With the stateless approach this \\nwouldn\'t happen. \\n\\n &gt; &gt; Hmmmm, in fact, I think your CMP wrapper would not work with the \\n&gt; &gt; merge policy in   LUCENE-845  , right?  Ie, won\'t it will just recurse \\n&gt; &gt; forever?  So actually I don\'t see how your CMP (using the current \\n&gt; &gt; API) can in general safely \\\"wrap\\\" around a merge policy w\\/o \\n&gt; &gt; breaking things? \\n&gt; \\n&gt; I think it\'s safe, just not concurrent. The recursion would generate \\n&gt; the same set of segments to merge and CMP would make the second call \\n&gt; block (abstractly, anyway: it actually throws an exception that \\n&gt; unwinds the stack and causes the call to start again from the top \\n&gt; when the conflicting merge finishes). \\n\\n Oh I see...  that\'s kind of sneaky (planning on using exceptions to \\nabort a merge requested by the policy).  I think the stateless \\napproach would be cleaner here. \\n\\n &gt; &gt; But, if you lock on IndexWriter, what about apps that use multiple \\n&gt; &gt; threads to add documents and but don\'t use CMP?  When one thread \\n&gt; &gt; gets tied up merging, you\'ll then block on the other synchronized \\n&gt; &gt; methods?  And you also can\'t flush from other threads either?  I \\n&gt; &gt; think flushing a new segment should be allowed to run concurrently \\n&gt; &gt; with the merge? \\n&gt; \\n&gt; I\'m not sure I\'m following this. That\'s what happens now, right? Are \\n&gt; you trying to get more concurrency then there is now w\\/o using CMP? \\n&gt; I certainly haven\'t been trying to do that. \\n\\n True, this is something new.  But since you\'re already doing the work \\nto allow a merge to run in the BG without blocking adding of docs, \\nflushing, etc, wouldn\'t this come nearly for free?  Actually I think \\nall that\'s necessary, regardless of sync\'ing on IndexWriter or \\nSegmentInfos is to move the \\\"if (triggerMerge)\\\" out of the \\nsynchronized method\\/block. \\n\\n &gt; &gt; I guess I don\'t see the reason to synchronize on IndexWriter \\n&gt; &gt; instead of segmentInfos. \\n&gt; \\n&gt; I looked at trying to make IW work when a synchronization of IW \\n&gt; didn\'t imply a synchronization of segmentInfos. It\'s a very, very \\n&gt; heavily used little data structure. I found it very hard to convince \\n&gt; myself I could catch all the places locks would be required. And at \\n&gt; the same time, I seemed to be able to do everything I needed with IW \\n&gt; locking. \\n\\n Well, eg flush() now synchronizes on IndexWriter: we don\'t want 2 \\nthreads doing this at once.  But, the touching of segmentInfos inside \\nflush (to add the new SegmentInfo) is a tiny fleeting event (like \\nreplace) and so you would want segmentInfos to be free to change while \\nthe flushing was running (eg by a BG merge that has finished). \\n\\n &gt; Hmmm ... I guess our approaches are pretty different. If you want to \\n&gt; take a stab at this ... \\n\\n OK I will try to take a rough stab a the stateless approach....              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12520881\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12520881&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12520881\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520881_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520881_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'18\\/Aug\\/07 18:29\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-18T18:29:29+0000\'\u003e18\\/Aug\\/07 18:29\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e\\tmy feeling is we should not deprecate\u003cbr\\/\u003e\\n\\tsetUseCompoundFile, setMergeFactor, setMaxMergeDocs\u003c\\/p\u003e\\n\\n\u003cp\u003eI understood that you didn\'t want to deprecate them in IndexWriter. I wasn\'t sure that you meant that they should be added to the MergePolicy interface? If you do, everything makes sense. Otherwise, it sounds like there\'s still a cast in there and I\'m not sure about that.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI think IndexWriter should enforce it?  Ie no merge policy should be\u003cbr\\/\u003e\\n\\tallowed to leave segments in other dirs (= at inconsistent index) at\u003cbr\\/\u003e\\n\\tpoint of commit.\u003c\\/p\u003e\\n\\n\u003cp\u003eI think it\'s just about code location: since a merge policy might want to factor into it\'s algorithm the directories used, it needs the info and it will presumably sometimes do it. Presumably you could provide code in MergePolicyBase so the merges could decide when but wouldn\'t have to write the copy loop. If you put the code in IndexWriter too, it sounds duplicated, again presuming sometimes a policy might want to do it itself. \u003c\\/p\u003e\\n\\n\u003cp\u003e\\tI like that idea \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  It fits well w\\/ the stateless API.  Ie, merge\u003cbr\\/\u003e\\n\\tpolicy returns all possible merges and \\\"someone above\\\" takes care of\u003cbr\\/\u003e\\n\\tscheduling them.\u003c\\/p\u003e\\n\\n\u003cp\u003eSo it returns a vector of specs?\u003c\\/p\u003e\\n\\n\u003cp\u003eThat\'s essentially what the CMP as an above\\/below wrapper does. I can see that above\\/below is strange enough to be less clever (I wasn\'t trying to be so much clever as backwards compatible) and more insane.\u003c\\/p\u003e\\n\\n\u003cp\u003eSane is good.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tHmm.  This means each merge policy must know whether it\'s talking to\u003cbr\\/\u003e\\n\\tCMP or IndexWriter underneith?  With the stateless approach this\u003cbr\\/\u003e\\n\\twouldn\'t happen.\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, I wouldn\'t so much say it has to know. All it cares is what merge returns. Doesn\'t have to know who returned it or why.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe only real difference between this and the \\\"generate a vector of merges\\\" is that in the merge policy can take advantage immediately of merge results in the serial case where if you\'re generating a vector of merges, it can\'t know.\u003c\\/p\u003e\\n\\n\u003cp\u003eOf course, I guess in that case, if IndexWriter gets a vector of merges, it can always take the lowest and ignore the rest, calling the merge policy again incase it wants to request a different set. Then you only have the excess computation for merges you never really considered.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tOh I see...  that\'s kind of sneaky (planning on using exceptions to\u003cbr\\/\u003e\\n\\tabort a merge requested by the policy).\u003c\\/p\u003e\\n\\n\u003cp\u003eThere\'s always going to be the chance of an exception to a merge. I\'m pretty sure of that. But you\'re right, if the merge policy isn\'t in the control path, it would never see them. They\'ll be there, but it\'s out of the path.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tBut since you\'re already doing the work\u003cbr\\/\u003e\\n\\tto allow a merge to run in the BG without blocking adding of docs,\u003cbr\\/\u003e\\n\\tflushing, etc, wouldn\'t this come nearly for free?\u003c\\/p\u003e\\n\\n\u003cp\u003eI haven\'t looked at this.\u003c\\/p\u003e\\n\\n\u003cp\u003e\\tWell, eg flush() now synchronizes on IndexWriter\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah, and making it not is less than straightforward. I\'ve looked at his code a fair amount, experimented with different ideas, but hadn\'t gotten all the way to a working model.\u003c\\/p\u003e\\n\\n\u003cp\u003eYou can look at locking segmentInfos but there are many places that segmentInfos is iterated over that would require locks if the lock on IW wasn\'t sufficient to guarantee that the iteration was safe.\u003c\\/p\u003e\\n\\n\u003cp\u003eI did look at that early on, so maybe my understanding was still too lacking and it\'s more feasible than I was thinking ...\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"steven_parkes\\\" id=\\\"commentauthor_12520881_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=steven_parkes\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"steven_parkes\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Steven Parkes\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12520881_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'18\\/Aug\\/07 18:29\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-18T18:29:29+0000\'\u003e18\\/Aug\\/07 18:29\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    \\tmy feeling is we should not deprecate \\n\\tsetUseCompoundFile, setMergeFactor, setMaxMergeDocs \\n\\n I understood that you didn\'t want to deprecate them in IndexWriter. I wasn\'t sure that you meant that they should be added to the MergePolicy interface? If you do, everything makes sense. Otherwise, it sounds like there\'s still a cast in there and I\'m not sure about that. \\n\\n \\tI think IndexWriter should enforce it?  Ie no merge policy should be \\n\\tallowed to leave segments in other dirs (= at inconsistent index) at \\n\\tpoint of commit. \\n\\n I think it\'s just about code location: since a merge policy might want to factor into it\'s algorithm the directories used, it needs the info and it will presumably sometimes do it. Presumably you could provide code in MergePolicyBase so the merges could decide when but wouldn\'t have to write the copy loop. If you put the code in IndexWriter too, it sounds duplicated, again presuming sometimes a policy might want to do it itself.  \\n\\n \\tI like that idea    It fits well w\\/ the stateless API.  Ie, merge \\n\\tpolicy returns all possible merges and \\\"someone above\\\" takes care of \\n\\tscheduling them. \\n\\n So it returns a vector of specs? \\n\\n That\'s essentially what the CMP as an above\\/below wrapper does. I can see that above\\/below is strange enough to be less clever (I wasn\'t trying to be so much clever as backwards compatible) and more insane. \\n\\n Sane is good. \\n\\n \\tHmm.  This means each merge policy must know whether it\'s talking to \\n\\tCMP or IndexWriter underneith?  With the stateless approach this \\n\\twouldn\'t happen. \\n\\n Well, I wouldn\'t so much say it has to know. All it cares is what merge returns. Doesn\'t have to know who returned it or why. \\n\\n The only real difference between this and the \\\"generate a vector of merges\\\" is that in the merge policy can take advantage immediately of merge results in the serial case where if you\'re generating a vector of merges, it can\'t know. \\n\\n Of course, I guess in that case, if IndexWriter gets a vector of merges, it can always take the lowest and ignore the rest, calling the merge policy again incase it wants to request a different set. Then you only have the excess computation for merges you never really considered. \\n\\n \\tOh I see...  that\'s kind of sneaky (planning on using exceptions to \\n\\tabort a merge requested by the policy). \\n\\n There\'s always going to be the chance of an exception to a merge. I\'m pretty sure of that. But you\'re right, if the merge policy isn\'t in the control path, it would never see them. They\'ll be there, but it\'s out of the path. \\n\\n \\tBut since you\'re already doing the work \\n\\tto allow a merge to run in the BG without blocking adding of docs, \\n\\tflushing, etc, wouldn\'t this come nearly for free? \\n\\n I haven\'t looked at this. \\n\\n \\tWell, eg flush() now synchronizes on IndexWriter \\n\\n Yeah, and making it not is less than straightforward. I\'ve looked at his code a fair amount, experimented with different ideas, but hadn\'t gotten all the way to a working model. \\n\\n You can look at locking segmentInfos but there are many places that segmentInfos is iterated over that would require locks if the lock on IW wasn\'t sufficient to guarantee that the iteration was safe. \\n\\n I did look at that early on, so maybe my understanding was still too lacking and it\'s more feasible than I was thinking ...              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12522575\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12522575&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12522575\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12522575_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12522575_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'24\\/Aug\\/07 16:38\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-24T16:38:21+0000\'\u003e24\\/Aug\\/07 16:38\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOK I started from the original patch and made the changes described\u003cbr\\/\u003e\\nbelow.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is still a work in progress, but I think I think the new\u003cbr\\/\u003e\\nstateless approach works very well.\u003c\\/p\u003e\\n\\n\u003cp\u003eAll unit tests pass (one assert had to be changed in\u003cbr\\/\u003e\\nTestAddIndexesNoOptimize).\u003c\\/p\u003e\\n\\n\u003cp\u003eI created a ConcurrentMergePolicyWrapper along with this (I\'ll post\u003cbr\\/\u003e\\npatch to \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-870\\\" title=\\\"add concurrent merge policy\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-870\\\"\u003e\u003cdel\u003eLUCENE-870\u003c\\/del\u003e\u003c\\/a\u003e).\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'ve also included the two merge policies from \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e (still\u003cbr\\/\u003e\\ndefaulting to LogDocMergePolicy).\u003c\\/p\u003e\\n\\n\u003cp\u003eHere are the changes:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eRenamed merge -&gt; maybeMerge\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eChanged the API to be \\\"stateless\\\" meaning the merge policy is no\u003cbr\\/\u003e\\n    longer responsible for running the merges itself.  Instead, it\u003cbr\\/\u003e\\n    quickly returns the specification, which describes which merges\u003cbr\\/\u003e\\n    are needed, back to the writer and the writer then runs them.  I\u003cbr\\/\u003e\\n    also changed MergeSpecification to contain a list of OneMerge\u003cbr\\/\u003e\\n    instances.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eRemoved IndexMerger interface (just use IndexWriter instead)\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003ePut isOptimized() logic into LogMergePolicy: on thinking about\u003cbr\\/\u003e\\n    this more (and seeing response to a thread on java-dev), I now\u003cbr\\/\u003e\\n    agree with Steve that this logically belongs in LogMergePolicy\u003cbr\\/\u003e\\n    because each MergePolicy is free to define just what it considers\u003cbr\\/\u003e\\n    \\\"optimized\\\" to mean.  Then I removed the MergePolicyBase.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eUn-deprecated \\n{get\\/set}\\n{UseCompoundFile,MergeFactor,MaxMergeDocs}\\n\u003cp\u003e.\u003cbr\\/\u003e\\n    But I did leave the static constants deprecated.\u003c\\/p\u003e\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIndexWriter keeps track of which segments are involved in running\u003cbr\\/\u003e\\n    merges and throws a MergeException if it\'s asked to initiate a\u003cbr\\/\u003e\\n    merge that involves a segment that\'s already being merged.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eFixed LogMergePolicy to return all possible merges (exposes\u003cbr\\/\u003e\\n    concurrency).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eImplemented the \\\"merge deletes when commiting the merge\\\" algorithm\u003cbr\\/\u003e\\n    that Ning suggested (this is in commitMerge).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eAssert that the merge request is in fact contiguous (at start &amp;\u003cbr\\/\u003e\\n    finish of merge) &amp; throw MergeException if not.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eFixed a number of sneaky concurrency issues so that CMPW would\u003cbr\\/\u003e\\n    work.  Broke \\\"merge\\\" into mergeInit, mergeMiddle and mergeFinish.\u003cbr\\/\u003e\\n    The first &amp; last are carefully sychronized.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eI put copyDirFiles in IW and call this in addIndexesNoOptimize\u003cbr\\/\u003e\\n    before committing new segments file: we can\'t let mergePolicy\u003cbr\\/\u003e\\n    leave the index inconsistent.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eI reverted the changes to addIndexes(IndexReader[]): I think the\u003cbr\\/\u003e\\n    change here wasn\'t valid: you can\'t assume that you can re-create\u003cbr\\/\u003e\\n    any IndexReader instance by loading from its directory; I put the\u003cbr\\/\u003e\\n    original back for this method.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003ethe changes to addIndexes I\'m not sure are good.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eFixed LogMergePolicy to return more than 1 merge\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eMade CMPW\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eRenamed replace -&gt; commitMerge; made it private.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12522575_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12522575_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'24\\/Aug\\/07 16:38\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-24T16:38:21+0000\'\u003e24\\/Aug\\/07 16:38\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    OK I started from the original patch and made the changes described \\nbelow. \\n\\n This is still a work in progress, but I think I think the new \\nstateless approach works very well. \\n\\n All unit tests pass (one assert had to be changed in \\nTestAddIndexesNoOptimize). \\n\\n I created a ConcurrentMergePolicyWrapper along with this (I\'ll post \\npatch to   LUCENE-870  ). \\n\\n I\'ve also included the two merge policies from   LUCENE-845   (still \\ndefaulting to LogDocMergePolicy). \\n\\n Here are the changes: \\n\\n \\n\\t Renamed merge -&gt; maybeMerge \\n \\n\\n\\n \\n\\t Changed the API to be \\\"stateless\\\" meaning the merge policy is no \\n    longer responsible for running the merges itself.  Instead, it \\n    quickly returns the specification, which describes which merges \\n    are needed, back to the writer and the writer then runs them.  I \\n    also changed MergeSpecification to contain a list of OneMerge \\n    instances. \\n \\n\\n\\n \\n\\t Removed IndexMerger interface (just use IndexWriter instead) \\n \\n\\n\\n \\n\\t Put isOptimized() logic into LogMergePolicy: on thinking about \\n    this more (and seeing response to a thread on java-dev), I now \\n    agree with Steve that this logically belongs in LogMergePolicy \\n    because each MergePolicy is free to define just what it considers \\n    \\\"optimized\\\" to mean.  Then I removed the MergePolicyBase. \\n \\n\\n\\n \\n\\t Un-deprecated \\n{get\\/set}\\n{UseCompoundFile,MergeFactor,MaxMergeDocs}\\n . \\n    But I did leave the static constants deprecated.  \\n \\n\\n\\n \\n\\t IndexWriter keeps track of which segments are involved in running \\n    merges and throws a MergeException if it\'s asked to initiate a \\n    merge that involves a segment that\'s already being merged. \\n \\n\\n\\n \\n\\t Fixed LogMergePolicy to return all possible merges (exposes \\n    concurrency). \\n \\n\\n\\n \\n\\t Implemented the \\\"merge deletes when commiting the merge\\\" algorithm \\n    that Ning suggested (this is in commitMerge). \\n \\n\\n\\n \\n\\t Assert that the merge request is in fact contiguous (at start &amp; \\n    finish of merge) &amp; throw MergeException if not. \\n \\n\\n\\n \\n\\t Fixed a number of sneaky concurrency issues so that CMPW would \\n    work.  Broke \\\"merge\\\" into mergeInit, mergeMiddle and mergeFinish. \\n    The first &amp; last are carefully sychronized. \\n \\n\\n\\n \\n\\t I put copyDirFiles in IW and call this in addIndexesNoOptimize \\n    before committing new segments file: we can\'t let mergePolicy \\n    leave the index inconsistent. \\n \\n\\n\\n \\n\\t I reverted the changes to addIndexes(IndexReader[]): I think the \\n    change here wasn\'t valid: you can\'t assume that you can re-create \\n    any IndexReader instance by loading from its directory; I put the \\n    original back for this method. \\n \\n\\n\\n \\n\\t the changes to addIndexes I\'m not sure are good. \\n \\n\\n\\n \\n\\t Fixed LogMergePolicy to return more than 1 merge \\n \\n\\n\\n \\n\\t Made CMPW \\n \\n\\n\\n \\n\\t Renamed replace -&gt; commitMerge; made it private. \\n \\n\\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12523104\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12523104&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12523104\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12523104_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523104_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'27\\/Aug\\/07 21:05\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-27T21:05:35+0000\'\u003e27\\/Aug\\/07 21:05\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOK new patch:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eAdded the missing MergePolicy.java from last time that Ning caught\u003cbr\\/\u003e\\n    (thanks!)\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eFixed some javadocs\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eRelaxed synchronization of merging so that merges can run\u003cbr\\/\u003e\\n    concurrently with flushing if you are using multiple thread to do\u003cbr\\/\u003e\\n    indexing.  This gains concurrency of merging even if you are not\u003cbr\\/\u003e\\n    using CMPW.  But I left flushing as synchronized; I think we can\u003cbr\\/\u003e\\n    relax this at some point in the future.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eFixed some concurrency issues\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eAdded \\\"minMergeDocs\\\" to LogDocMergePolicy and \\\"minMergeMB\\\" to\u003cbr\\/\u003e\\n    LogByteSizeMergePolicy; set their defaults as described in\u003cbr\\/\u003e\\n    \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eStill a few small things to do.  I think it\'s getting close.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12523104_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523104_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'27\\/Aug\\/07 21:05\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-27T21:05:35+0000\'\u003e27\\/Aug\\/07 21:05\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    OK new patch: \\n\\n \\n\\t Added the missing MergePolicy.java from last time that Ning caught \\n    (thanks!) \\n \\n\\n\\n \\n\\t Fixed some javadocs \\n \\n\\n\\n \\n\\t Relaxed synchronization of merging so that merges can run \\n    concurrently with flushing if you are using multiple thread to do \\n    indexing.  This gains concurrency of merging even if you are not \\n    using CMPW.  But I left flushing as synchronized; I think we can \\n    relax this at some point in the future. \\n \\n\\n\\n \\n\\t Fixed some concurrency issues \\n \\n\\n\\n \\n\\t Added \\\"minMergeDocs\\\" to LogDocMergePolicy and \\\"minMergeMB\\\" to \\n    LogByteSizeMergePolicy; set their defaults as described in \\n      LUCENE-845  . \\n \\n\\n\\n Still a few small things to do.  I think it\'s getting close.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12523621\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12523621&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12523621\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12523621_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523621_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'29\\/Aug\\/07 16:22\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-29T16:22:04+0000\'\u003e29\\/Aug\\/07 16:22\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eI include comments for both \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e and \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-870\\\" title=\\\"add concurrent merge policy\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-870\\\"\u003e\u003cdel\u003eLUCENE-870\u003c\\/del\u003e\u003c\\/a\u003e here since they are closely related.\u003c\\/p\u003e\\n\\n\u003cp\u003eI like the stateless approach used for refactoring merge policy. But modeling concurrent merge (ConcurrentMergePolicyWrapper) as a MergePolicy seems to be inconsistent with the MergePolicy interface:\u003cbr\\/\u003e\\n  1 As you pointed out, \\\"the merge policy is no longer responsible for running the merges itself\\\". MergePolicy.maybeMerge simply returns a merge specification. But ConcurrentMergePolicyWrapper.maybeMerge actually starts concurrent merge threads thus doing the merges.\u003cbr\\/\u003e\\n  2 Related to 1, cascading is done in IndexWriter in non-concurrent case. But in concurrent case, cascading is also done in merge threads which are started by ConcurrentMergePolicyWrapper.maybeMerge.\u003c\\/p\u003e\\n\\n\u003cp\u003eMergePolicy.maybeMerge should continue to simply return a merge specification. (BTW, should we rename this maybeMerge to, say, findCandidateMerges?) Can we carve the merge process out of IndexWriter into a Merger? IndexWriter still provides the building blocks - merge(OneMerge), mergeInit(OneMerge), etc. Merger uses these building blocks. A ConcurrentMerger extends Merger but starts concurrent merge threads as ConcurrentMergePolicyWrapper does.\u003c\\/p\u003e\\n\\n\\n\u003cp\u003eOther comments:\u003cbr\\/\u003e\\n1 UpdateDocument\'s and deleteDocument\'s bufferDeleteTerm are synchronized on different variables in this patch. However, the semantics of updateDocument changed since \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e. Before \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e, updateDocument, which is a delete and an insert, guaranteed the delete and the insert are committed together (thus an update). Now it\'s possible that they are committed in different transactions. If we consider DocumentsWriter as the RAM staging area for IndexWriter, then deletes are also buffered in RAM staging area and we can restore our previous semantics, right?\u003c\\/p\u003e\\n\\n\u003cp\u003e2 OneMerge.segments seems to rely on its segment infos\' reference to segment infos of IndexWriter.segmentInfos. The use in commitMerge, which calls ensureContiguousMerge, is an example. However, segmentInfos can be a cloned copy because of exceptions, thus the reference broken.\u003c\\/p\u003e\\n\\n\u003cp\u003e3 Calling optimize of an IndexWriter with the current ConcurrentMergePolicyWrapper may cause deadlock: the one merge spec returned by MergePolicy.optimize may be in conflict with a concurrent merge (the same merge spec will be returned without changes to segmentInfos), but a concurrent merge cannot finish because optimize is holding the lock.\u003c\\/p\u003e\\n\\n\u003cp\u003e4 Finally, a couple of minor things:\u003cbr\\/\u003e\\n  1 LogMergePolicy.useCompoundFile(SegmentInfos infos, SegmentInfo info) and useCompoundDocStore(SegmentInfos infos): why the parameters?\u003cbr\\/\u003e\\n  2 Do we need doMergeClose in IndexWriter? Can we simply close a MergePolicy if not null?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12523621_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523621_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'29\\/Aug\\/07 16:22\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-29T16:22:04+0000\'\u003e29\\/Aug\\/07 16:22\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    I include comments for both   LUCENE-847   and   LUCENE-870   here since they are closely related. \\n\\n I like the stateless approach used for refactoring merge policy. But modeling concurrent merge (ConcurrentMergePolicyWrapper) as a MergePolicy seems to be inconsistent with the MergePolicy interface: \\n  1 As you pointed out, \\\"the merge policy is no longer responsible for running the merges itself\\\". MergePolicy.maybeMerge simply returns a merge specification. But ConcurrentMergePolicyWrapper.maybeMerge actually starts concurrent merge threads thus doing the merges. \\n  2 Related to 1, cascading is done in IndexWriter in non-concurrent case. But in concurrent case, cascading is also done in merge threads which are started by ConcurrentMergePolicyWrapper.maybeMerge. \\n\\n MergePolicy.maybeMerge should continue to simply return a merge specification. (BTW, should we rename this maybeMerge to, say, findCandidateMerges?) Can we carve the merge process out of IndexWriter into a Merger? IndexWriter still provides the building blocks - merge(OneMerge), mergeInit(OneMerge), etc. Merger uses these building blocks. A ConcurrentMerger extends Merger but starts concurrent merge threads as ConcurrentMergePolicyWrapper does. \\n\\n\\n Other comments: \\n1 UpdateDocument\'s and deleteDocument\'s bufferDeleteTerm are synchronized on different variables in this patch. However, the semantics of updateDocument changed since   LUCENE-843  . Before   LUCENE-843  , updateDocument, which is a delete and an insert, guaranteed the delete and the insert are committed together (thus an update). Now it\'s possible that they are committed in different transactions. If we consider DocumentsWriter as the RAM staging area for IndexWriter, then deletes are also buffered in RAM staging area and we can restore our previous semantics, right? \\n\\n 2 OneMerge.segments seems to rely on its segment infos\' reference to segment infos of IndexWriter.segmentInfos. The use in commitMerge, which calls ensureContiguousMerge, is an example. However, segmentInfos can be a cloned copy because of exceptions, thus the reference broken. \\n\\n 3 Calling optimize of an IndexWriter with the current ConcurrentMergePolicyWrapper may cause deadlock: the one merge spec returned by MergePolicy.optimize may be in conflict with a concurrent merge (the same merge spec will be returned without changes to segmentInfos), but a concurrent merge cannot finish because optimize is holding the lock. \\n\\n 4 Finally, a couple of minor things: \\n  1 LogMergePolicy.useCompoundFile(SegmentInfos infos, SegmentInfo info) and useCompoundDocStore(SegmentInfos infos): why the parameters? \\n  2 Do we need doMergeClose in IndexWriter? Can we simply close a MergePolicy if not null?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12523798\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12523798&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12523798\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12523798_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523798_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'30\\/Aug\\/07 09:09\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-30T09:09:44+0000\'\u003e30\\/Aug\\/07 09:09\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eThanks for the detailed review Ning!\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 1 As you pointed out, \\\"the merge policy is no longer responsible for\u003cbr\\/\u003e\\n&gt; running the merges itself\\\". MergePolicy.maybeMerge simply returns a\u003cbr\\/\u003e\\n&gt; merge specification. But ConcurrentMergePolicyWrapper.maybeMerge\u003cbr\\/\u003e\\n&gt; actually starts concurrent merge threads thus doing the merges.\u003c\\/p\u003e\\n\\n\u003cp\u003eTrue, but I was thinking CMPW could be an exception to this rule.  I\u003cbr\\/\u003e\\nguess I would change the rule to \\\"simple merge policies don\'t have to\u003cbr\\/\u003e\\nrun their own merges\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003eHowever I do agree, CMPW is clearly a different beast from a typical\u003cbr\\/\u003e\\nmerge policy because it entails scheduling, not selection, of merges.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 2 Related to 1, cascading is done in IndexWriter in non-concurrent\u003cbr\\/\u003e\\n&gt; case. But in concurrent case, cascading is also done in merge\u003cbr\\/\u003e\\n&gt; threads which are started by\u003cbr\\/\u003e\\n&gt; ConcurrentMergePolicyWrapper.maybeMerge.\u003c\\/p\u003e\\n\\n\u003cp\u003eGood point...  I think I could refactor this so that cascading logic\u003cbr\\/\u003e\\nlives entirely in one place IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; MergePolicy.maybeMerge should continue to simply return a merge\u003cbr\\/\u003e\\n&gt; specification. (BTW, should we rename this maybeMerge to, say,\u003cbr\\/\u003e\\n&gt; findCandidateMerges?)\u003c\\/p\u003e\\n\\n\u003cp\u003eGood!  I like findCandidateMerges better; I\'ll change it.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Can we carve the merge process out of IndexWriter into a Merger?\u003cbr\\/\u003e\\n&gt; IndexWriter still provides the building blocks - merge(OneMerge),\u003cbr\\/\u003e\\n&gt; mergeInit(OneMerge), etc. Merger uses these building blocks. A\u003cbr\\/\u003e\\n&gt; ConcurrentMerger extends Merger but starts concurrent merge threads\u003cbr\\/\u003e\\n&gt; as ConcurrentMergePolicyWrapper does.\u003c\\/p\u003e\\n\\n\u003cp\u003eHow would this be used?  Ie, how would one make an IndexWriter that\u003cbr\\/\u003e\\nuses the ConcurrentMerger?  Would we add expert methods\u003cbr\\/\u003e\\nIndexWriter.set\\/getIndexMerger(...)?  (And presumably the mergePolicy\u003cbr\\/\u003e\\nis now owned by IndexMerger so it would have the\u003cbr\\/\u003e\\nset\\/getMergePolicy(...)?)\u003c\\/p\u003e\\n\\n\u003cp\u003eAlso, how would you separate what remains in IW vs what would be in\u003cbr\\/\u003e\\nIndexMerger?\u003c\\/p\u003e\\n\\n\u003cp\u003eI like this approach in principle; I\'m just trying to hash out the\u003cbr\\/\u003e\\ndetails...\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 1 UpdateDocument\'s and deleteDocument\'s bufferDeleteTerm are\u003cbr\\/\u003e\\n&gt; synchronized on different variables in this patch.\u003c\\/p\u003e\\n\\n\u003cp\u003eWoops, good catch!  I\'ll fix.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; However, the semantics of updateDocument changed since\u003cbr\\/\u003e\\n&gt; \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e. Before \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-843\\\" title=\\\"improve how IndexWriter uses RAM to buffer added documents\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-843\\\"\u003e\u003cdel\u003eLUCENE-843\u003c\\/del\u003e\u003c\\/a\u003e, updateDocument, which is a delete and\u003cbr\\/\u003e\\n&gt; an insert, guaranteed the delete and the insert are committed\u003cbr\\/\u003e\\n&gt; together (thus an update). Now it\'s possible that they are committed\u003cbr\\/\u003e\\n&gt; in different transactions. If we consider DocumentsWriter as the RAM\u003cbr\\/\u003e\\n&gt; staging area for IndexWriter, then deletes are also buffered in RAM\u003cbr\\/\u003e\\n&gt; staging area and we can restore our previous semantics, right?\u003c\\/p\u003e\\n\\n\u003cp\u003eHmm ... you\'re right.  This is a separate issue from merge policy,\u003cbr\\/\u003e\\nright?  Are you proposing buffering deletes in DocumentsWriter\u003cbr\\/\u003e\\ninstead?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 2 OneMerge.segments seems to rely on its segment infos\' reference to\u003cbr\\/\u003e\\n&gt; segment infos of IndexWriter.segmentInfos. The use in commitMerge,\u003cbr\\/\u003e\\n&gt; which calls ensureContiguousMerge, is an example. However,\u003cbr\\/\u003e\\n&gt; segmentInfos can be a cloned copy because of exceptions, thus the\u003cbr\\/\u003e\\n&gt; reference broken.\u003c\\/p\u003e\\n\\n\u003cp\u003eGood catch!  How to fix?  One thing we could do is always use\u003cbr\\/\u003e\\nSegmentInfo.reset(...) and never swap in clones at the SegmentInfo\u003cbr\\/\u003e\\nlevel.  This way using the default \'equals\' (same instance) would\u003cbr\\/\u003e\\nwork.  Or we could establish identity (equals) of a SegmentInfo as\u003cbr\\/\u003e\\nchecking if the directory plus segment name are equal?  I think I\'d\u003cbr\\/\u003e\\nlean to the 2nd option....\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 3 Calling optimize of an IndexWriter with the current\u003cbr\\/\u003e\\n&gt; ConcurrentMergePolicyWrapper may cause deadlock: the one merge spec\u003cbr\\/\u003e\\n&gt; returned by MergePolicy.optimize may be in conflict with a\u003cbr\\/\u003e\\n&gt; concurrent merge (the same merge spec will be returned without\u003cbr\\/\u003e\\n&gt; changes to segmentInfos), but a concurrent merge cannot finish\u003cbr\\/\u003e\\n&gt; because optimize is holding the lock.\u003c\\/p\u003e\\n\\n\u003cp\u003eHmmm yes.  In fact I think we can remove synchronized from optimize\u003cbr\\/\u003e\\naltogether since within it we are synchronizing(this) at the right\u003cbr\\/\u003e\\nplaces?  If more than one thread calls optimize at once, externally,\u003cbr\\/\u003e\\nit is actually OK: they will each pick a merge that\'s viable\u003cbr\\/\u003e\\n(concurrently) and will run the merge, else return once there is no\u003cbr\\/\u003e\\nmore concurrency left.  I\'ll add a unit test that confirms this.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 4 Finally, a couple of minor things:\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt;   1 LogMergePolicy.useCompoundFile(SegmentInfos infos, SegmentInfo\u003cbr\\/\u003e\\n&gt;     info) and useCompoundDocStore(SegmentInfos infos): why the\u003cbr\\/\u003e\\n&gt;     parameters?\u003c\\/p\u003e\\n\\n\u003cp\u003eWell, useCompoundFile(...) is given a single newly flushed segment and\u003cbr\\/\u003e\\nshould decide whether it should be CFS.  Whereas\u003cbr\\/\u003e\\nuseCompoundDocStore(...) is called when doc stores are flushed.  When\u003cbr\\/\u003e\\nautoCommit=false, segments can share a single set of doc stores, so\u003cbr\\/\u003e\\nthere\'s no single SegmentInfo to pass down.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; 2 Do we need doMergeClose in IndexWriter? Can we simply close a\u003cbr\\/\u003e\\n&gt;   MergePolicy if not null?\u003c\\/p\u003e\\n\\n\u003cp\u003eGood point.  I think this is reasonable &#8211; I\'ll fix.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12523798_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523798_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'30\\/Aug\\/07 09:09\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-30T09:09:44+0000\'\u003e30\\/Aug\\/07 09:09\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Thanks for the detailed review Ning! \\n\\n &gt; 1 As you pointed out, \\\"the merge policy is no longer responsible for \\n&gt; running the merges itself\\\". MergePolicy.maybeMerge simply returns a \\n&gt; merge specification. But ConcurrentMergePolicyWrapper.maybeMerge \\n&gt; actually starts concurrent merge threads thus doing the merges. \\n\\n True, but I was thinking CMPW could be an exception to this rule.  I \\nguess I would change the rule to \\\"simple merge policies don\'t have to \\nrun their own merges\\\"? \\n\\n However I do agree, CMPW is clearly a different beast from a typical \\nmerge policy because it entails scheduling, not selection, of merges. \\n\\n &gt; 2 Related to 1, cascading is done in IndexWriter in non-concurrent \\n&gt; case. But in concurrent case, cascading is also done in merge \\n&gt; threads which are started by \\n&gt; ConcurrentMergePolicyWrapper.maybeMerge. \\n\\n Good point...  I think I could refactor this so that cascading logic \\nlives entirely in one place IndexWriter. \\n\\n &gt; MergePolicy.maybeMerge should continue to simply return a merge \\n&gt; specification. (BTW, should we rename this maybeMerge to, say, \\n&gt; findCandidateMerges?) \\n\\n Good!  I like findCandidateMerges better; I\'ll change it. \\n\\n &gt; Can we carve the merge process out of IndexWriter into a Merger? \\n&gt; IndexWriter still provides the building blocks - merge(OneMerge), \\n&gt; mergeInit(OneMerge), etc. Merger uses these building blocks. A \\n&gt; ConcurrentMerger extends Merger but starts concurrent merge threads \\n&gt; as ConcurrentMergePolicyWrapper does. \\n\\n How would this be used?  Ie, how would one make an IndexWriter that \\nuses the ConcurrentMerger?  Would we add expert methods \\nIndexWriter.set\\/getIndexMerger(...)?  (And presumably the mergePolicy \\nis now owned by IndexMerger so it would have the \\nset\\/getMergePolicy(...)?) \\n\\n Also, how would you separate what remains in IW vs what would be in \\nIndexMerger? \\n\\n I like this approach in principle; I\'m just trying to hash out the \\ndetails... \\n\\n &gt; 1 UpdateDocument\'s and deleteDocument\'s bufferDeleteTerm are \\n&gt; synchronized on different variables in this patch. \\n\\n Woops, good catch!  I\'ll fix. \\n\\n &gt; However, the semantics of updateDocument changed since \\n&gt;   LUCENE-843  . Before   LUCENE-843  , updateDocument, which is a delete and \\n&gt; an insert, guaranteed the delete and the insert are committed \\n&gt; together (thus an update). Now it\'s possible that they are committed \\n&gt; in different transactions. If we consider DocumentsWriter as the RAM \\n&gt; staging area for IndexWriter, then deletes are also buffered in RAM \\n&gt; staging area and we can restore our previous semantics, right? \\n\\n Hmm ... you\'re right.  This is a separate issue from merge policy, \\nright?  Are you proposing buffering deletes in DocumentsWriter \\ninstead? \\n\\n &gt; 2 OneMerge.segments seems to rely on its segment infos\' reference to \\n&gt; segment infos of IndexWriter.segmentInfos. The use in commitMerge, \\n&gt; which calls ensureContiguousMerge, is an example. However, \\n&gt; segmentInfos can be a cloned copy because of exceptions, thus the \\n&gt; reference broken. \\n\\n Good catch!  How to fix?  One thing we could do is always use \\nSegmentInfo.reset(...) and never swap in clones at the SegmentInfo \\nlevel.  This way using the default \'equals\' (same instance) would \\nwork.  Or we could establish identity (equals) of a SegmentInfo as \\nchecking if the directory plus segment name are equal?  I think I\'d \\nlean to the 2nd option.... \\n\\n &gt; 3 Calling optimize of an IndexWriter with the current \\n&gt; ConcurrentMergePolicyWrapper may cause deadlock: the one merge spec \\n&gt; returned by MergePolicy.optimize may be in conflict with a \\n&gt; concurrent merge (the same merge spec will be returned without \\n&gt; changes to segmentInfos), but a concurrent merge cannot finish \\n&gt; because optimize is holding the lock. \\n\\n Hmmm yes.  In fact I think we can remove synchronized from optimize \\naltogether since within it we are synchronizing(this) at the right \\nplaces?  If more than one thread calls optimize at once, externally, \\nit is actually OK: they will each pick a merge that\'s viable \\n(concurrently) and will run the merge, else return once there is no \\nmore concurrency left.  I\'ll add a unit test that confirms this. \\n\\n &gt; 4 Finally, a couple of minor things: \\n&gt; \\n&gt;   1 LogMergePolicy.useCompoundFile(SegmentInfos infos, SegmentInfo \\n&gt;     info) and useCompoundDocStore(SegmentInfos infos): why the \\n&gt;     parameters? \\n\\n Well, useCompoundFile(...) is given a single newly flushed segment and \\nshould decide whether it should be CFS.  Whereas \\nuseCompoundDocStore(...) is called when doc stores are flushed.  When \\nautoCommit=false, segments can share a single set of doc stores, so \\nthere\'s no single SegmentInfo to pass down. \\n\\n &gt; 2 Do we need doMergeClose in IndexWriter? Can we simply close a \\n&gt;   MergePolicy if not null? \\n\\n Good point.  I think this is reasonable &#8211; I\'ll fix.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12523957\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12523957&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12523957\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12523957_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523957_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'30\\/Aug\\/07 22:33\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-30T22:33:30+0000\'\u003e30\\/Aug\\/07 22:33\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; True, but I was thinking CMPW could be an exception to this rule.  I\u003cbr\\/\u003e\\n&gt; guess I would change the rule to \\\"simple merge policies don\'t have to\u003cbr\\/\u003e\\n&gt; run their own merges\\\"?\u003c\\/p\u003e\\n\\n\u003cp\u003e\u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e Let\'s see if we have to make that exception.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Good point...  I think I could refactor this so that cascading logic\u003cbr\\/\u003e\\n&gt; lives entirely in one place IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eAnother problem of the current cascading in CMPW.MergeThread is, if multiple candidate merges are found, all of them are added to IndexWriter.mergingSegments. But all but the first should be removed because only the first merge is carried out (thus removed from mergeSegments after the merge is done).\u003c\\/p\u003e\\n\\n\u003cp\u003eHow do you make cascading live entirely in IndexWriter? Just removing cascading from CMPW.MergeThread has one drawback. For example, segment sizes of an index are: 40, 20, 10, buffer size is 10 and merge factor is 2. A buffer full flush of 10 will trigger merge of 10 &amp; 10, then cascade to 20 &amp; 20, then cascade to 40 &amp; 40. CMPW without cascading will stop after 10 &amp; 10 since IndexWriter.maybeMerge has already returned. Then we have to wait for the next flush to merge 20 &amp; 20.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; How would this be used?  Ie, how would one make an IndexWriter that\u003cbr\\/\u003e\\n&gt; uses the ConcurrentMerger?  Would we add expert methods\u003cbr\\/\u003e\\n&gt; IndexWriter.set\\/getIndexMerger(...)?  (And presumably the mergePolicy\u003cbr\\/\u003e\\n&gt; is now owned by IndexMerger so it would have the\u003cbr\\/\u003e\\n&gt; set\\/getMergePolicy(...)?)\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Also, how would you separate what remains in IW vs what would be in\u003cbr\\/\u003e\\n&gt; IndexMerger?\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe Merger does and only does merge (so IndexWriter still owns MergePolicy)? Say, base class Merger.merge simply calls IndexWriter.merge. ConcurrentMerger.merge creates a merge thread if possible. Otherwise it calls super.merge, which does non-concurrent merge. IndexWriter simply calls its merger\'s merge instead of its own merge. Everything else remains in IndexWriter.\u003c\\/p\u003e\\n\\n\\n\u003cp\u003e1\u003cbr\\/\u003e\\n&gt; Hmm ... you\'re right.  This is a separate issue from merge policy,\u003cbr\\/\u003e\\n&gt; right?  Are you proposing buffering deletes in DocumentsWriter\u003cbr\\/\u003e\\n&gt; instead?\u003c\\/p\u003e\\n\\n\u003cp\u003eYes, this is a separate issue. And yes if we consider DocumentsWriter as staging area.\u003c\\/p\u003e\\n\\n\u003cp\u003e2\u003cbr\\/\u003e\\n&gt; Good catch!  How to fix?  One thing we could do is always use\u003cbr\\/\u003e\\n&gt; SegmentInfo.reset(...) and never swap in clones at the SegmentInfo\u003cbr\\/\u003e\\n&gt; level.  This way using the default \'equals\' (same instance) would\u003cbr\\/\u003e\\n&gt; work.  Or we could establish identity (equals) of a SegmentInfo as\u003cbr\\/\u003e\\n&gt; checking if the directory plus segment name are equal?  I think I\'d\u003cbr\\/\u003e\\n&gt; lean to the 2nd option....\u003c\\/p\u003e\\n\\n\u003cp\u003eI think the 2nd option is better.\u003c\\/p\u003e\\n\\n\u003cp\u003e3\u003cbr\\/\u003e\\n&gt; Hmmm yes.  In fact I think we can remove synchronized from optimize\u003cbr\\/\u003e\\n&gt; altogether since within it we are synchronizing(this) at the right\u003cbr\\/\u003e\\n&gt; places?  If more than one thread calls optimize at once, externally,\u003cbr\\/\u003e\\n&gt; it is actually OK: they will each pick a merge that\'s viable\u003cbr\\/\u003e\\n&gt; (concurrently) and will run the merge, else return once there is no\u003cbr\\/\u003e\\n&gt; more concurrency left.  I\'ll add a unit test that confirms this.\u003c\\/p\u003e\\n\\n\u003cp\u003eThat seems to be the case. The fact that \\\"the same merge spec will be returned without changes to segmentInfos\\\" reminds me: MergePolicy.findCandidateMerges finds merges which may not be eligible; but CMPW checks for eligibility when looking for candidate merges. Maybe we should unify the behaviour? BTW, MergePolicy.optimize (a rename?) doesn\'t check for eligibility either.\u003c\\/p\u003e\\n\\n\u003cp\u003e4\u003cbr\\/\u003e\\n&gt; Well, useCompoundFile(...) is given a single newly flushed segment and\u003cbr\\/\u003e\\n&gt; should decide whether it should be CFS.  Whereas\u003cbr\\/\u003e\\n&gt; useCompoundDocStore(...) is called when doc stores are flushed.  When\u003cbr\\/\u003e\\n&gt; autoCommit=false, segments can share a single set of doc stores, so\u003cbr\\/\u003e\\n&gt; there\'s no single SegmentInfo to pass down.\u003c\\/p\u003e\\n\\n\u003cp\u003eThe reason I asked is because none of them are used right now. So they might be used in the future?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12523957_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12523957_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'30\\/Aug\\/07 22:33\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-30T22:33:30+0000\'\u003e30\\/Aug\\/07 22:33\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; True, but I was thinking CMPW could be an exception to this rule.  I \\n&gt; guess I would change the rule to \\\"simple merge policies don\'t have to \\n&gt; run their own merges\\\"? \\n\\n   Let\'s see if we have to make that exception. \\n\\n &gt; Good point...  I think I could refactor this so that cascading logic \\n&gt; lives entirely in one place IndexWriter. \\n\\n Another problem of the current cascading in CMPW.MergeThread is, if multiple candidate merges are found, all of them are added to IndexWriter.mergingSegments. But all but the first should be removed because only the first merge is carried out (thus removed from mergeSegments after the merge is done). \\n\\n How do you make cascading live entirely in IndexWriter? Just removing cascading from CMPW.MergeThread has one drawback. For example, segment sizes of an index are: 40, 20, 10, buffer size is 10 and merge factor is 2. A buffer full flush of 10 will trigger merge of 10 &amp; 10, then cascade to 20 &amp; 20, then cascade to 40 &amp; 40. CMPW without cascading will stop after 10 &amp; 10 since IndexWriter.maybeMerge has already returned. Then we have to wait for the next flush to merge 20 &amp; 20. \\n\\n &gt; How would this be used?  Ie, how would one make an IndexWriter that \\n&gt; uses the ConcurrentMerger?  Would we add expert methods \\n&gt; IndexWriter.set\\/getIndexMerger(...)?  (And presumably the mergePolicy \\n&gt; is now owned by IndexMerger so it would have the \\n&gt; set\\/getMergePolicy(...)?) \\n&gt;  \\n&gt; Also, how would you separate what remains in IW vs what would be in \\n&gt; IndexMerger? \\n\\n Maybe Merger does and only does merge (so IndexWriter still owns MergePolicy)? Say, base class Merger.merge simply calls IndexWriter.merge. ConcurrentMerger.merge creates a merge thread if possible. Otherwise it calls super.merge, which does non-concurrent merge. IndexWriter simply calls its merger\'s merge instead of its own merge. Everything else remains in IndexWriter. \\n\\n\\n 1 \\n&gt; Hmm ... you\'re right.  This is a separate issue from merge policy, \\n&gt; right?  Are you proposing buffering deletes in DocumentsWriter \\n&gt; instead? \\n\\n Yes, this is a separate issue. And yes if we consider DocumentsWriter as staging area. \\n\\n 2 \\n&gt; Good catch!  How to fix?  One thing we could do is always use \\n&gt; SegmentInfo.reset(...) and never swap in clones at the SegmentInfo \\n&gt; level.  This way using the default \'equals\' (same instance) would \\n&gt; work.  Or we could establish identity (equals) of a SegmentInfo as \\n&gt; checking if the directory plus segment name are equal?  I think I\'d \\n&gt; lean to the 2nd option.... \\n\\n I think the 2nd option is better. \\n\\n 3 \\n&gt; Hmmm yes.  In fact I think we can remove synchronized from optimize \\n&gt; altogether since within it we are synchronizing(this) at the right \\n&gt; places?  If more than one thread calls optimize at once, externally, \\n&gt; it is actually OK: they will each pick a merge that\'s viable \\n&gt; (concurrently) and will run the merge, else return once there is no \\n&gt; more concurrency left.  I\'ll add a unit test that confirms this. \\n\\n That seems to be the case. The fact that \\\"the same merge spec will be returned without changes to segmentInfos\\\" reminds me: MergePolicy.findCandidateMerges finds merges which may not be eligible; but CMPW checks for eligibility when looking for candidate merges. Maybe we should unify the behaviour? BTW, MergePolicy.optimize (a rename?) doesn\'t check for eligibility either. \\n\\n 4 \\n&gt; Well, useCompoundFile(...) is given a single newly flushed segment and \\n&gt; should decide whether it should be CFS.  Whereas \\n&gt; useCompoundDocStore(...) is called when doc stores are flushed.  When \\n&gt; autoCommit=false, segments can share a single set of doc stores, so \\n&gt; there\'s no single SegmentInfo to pass down. \\n\\n The reason I asked is because none of them are used right now. So they might be used in the future?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12524039\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12524039&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12524039\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12524039_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524039_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 08:31\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T08:31:22+0000\'\u003e31\\/Aug\\/07 08:31\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003e&gt; &gt; Good point...  I think I could refactor this so that cascading logic\u003cbr\\/\u003e\\n&gt; &gt; lives entirely in one place IndexWriter.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Another problem of the current cascading in CMPW.MergeThread is, if\u003cbr\\/\u003e\\n&gt; multiple candidate merges are found, all of them are added to\u003cbr\\/\u003e\\n&gt; IndexWriter.mergingSegments. But all but the first should be removed\u003cbr\\/\u003e\\n&gt; because only the first merge is carried out (thus removed from\u003cbr\\/\u003e\\n&gt; mergeSegments after the merge is done).\u003c\\/p\u003e\\n\\n\u003cp\u003eYou\'re right &#8211; I\'m only doing the first non-conflicting merge in\u003cbr\\/\u003e\\nCMPW (but then not releasing the rest of them).  I think this would be\u003cbr\\/\u003e\\nfixed by having cascading logic only in IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; How do you make cascading live entirely in IndexWriter? Just\u003cbr\\/\u003e\\n&gt; removing cascading from CMPW.MergeThread has one drawback.  For\u003cbr\\/\u003e\\n&gt; example, segment sizes of an index are: 40, 20, 10, buffer size is\u003cbr\\/\u003e\\n&gt; 10 and merge factor is 2. A buffer full flush of 10 will trigger\u003cbr\\/\u003e\\n&gt; merge of 10 &amp; 10, then cascade to 20 &amp; 20, then cascade to 40 &amp;\u003cbr\\/\u003e\\n&gt; 40. CMPW without cascading will stop after 10 &amp; 10 since\u003cbr\\/\u003e\\n&gt; IndexWriter.maybeMerge has already returned. Then we have to wait\u003cbr\\/\u003e\\n&gt; for the next flush to merge 20 &amp; 20.\u003c\\/p\u003e\\n\\n\u003cp\u003eOh, I would remove from CMPW and add then add it into IndexWriter (so\u003cbr\\/\u003e\\nthe scenario above would cascade normally).  Meaning, IndexWriter,\u003cbr\\/\u003e\\nupon completing a merge, would always consult the policy for whether\u003cbr\\/\u003e\\nthe completed merge has now enabled any new merges.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is somewhat messy though (with CMPW as a MergePolicy) because\u003cbr\\/\u003e\\nthen findCandidateMerges would need to know if it was being called\u003cbr\\/\u003e\\n(due to cascading) under one of its own threads and if so act\u003cbr\\/\u003e\\ndifferently.  Another good reason to make it a separate Merger\u003cbr\\/\u003e\\nsubclass.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; How would this be used?  Ie, how would one make an IndexWriter\u003cbr\\/\u003e\\n&gt; &gt; that uses the ConcurrentMerger?  Would we add expert methods\u003cbr\\/\u003e\\n&gt; &gt; IndexWriter.set\\/getIndexMerger(...)?  (And presumably the\u003cbr\\/\u003e\\n&gt; &gt; mergePolicy is now owned by IndexMerger so it would have the\u003cbr\\/\u003e\\n&gt; &gt; set\\/getMergePolicy(...)?)\u003cbr\\/\u003e\\n&gt; &gt; \u003cbr\\/\u003e\\n&gt; &gt; Also, how would you separate what remains in IW vs what would be\u003cbr\\/\u003e\\n&gt; &gt; in IndexMerger?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Maybe Merger does and only does merge (so IndexWriter still owns\u003cbr\\/\u003e\\n&gt; MergePolicy)? Say, base class Merger.merge simply calls\u003cbr\\/\u003e\\n&gt; IndexWriter.merge. ConcurrentMerger.merge creates a merge thread if\u003cbr\\/\u003e\\n&gt; possible. Otherwise it calls super.merge, which does non-concurrent\u003cbr\\/\u003e\\n&gt; merge. IndexWriter simply calls its merger\'s merge instead of its\u003cbr\\/\u003e\\n&gt; own merge. Everything else remains in IndexWriter.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK I will test out this approach.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Hmm ... you\'re right.  This is a separate issue from merge policy,\u003cbr\\/\u003e\\n&gt; &gt; right?  Are you proposing buffering deletes in DocumentsWriter\u003cbr\\/\u003e\\n&gt; &gt; instead?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Yes, this is a separate issue. And yes if we consider\u003cbr\\/\u003e\\n&gt;  DocumentsWriter as staging area.\u003c\\/p\u003e\\n\\n\u003cp\u003eI will open new issue.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Good catch!  How to fix?  One thing we could do is always use\u003cbr\\/\u003e\\n&gt; &gt; SegmentInfo.reset(...) and never swap in clones at the SegmentInfo\u003cbr\\/\u003e\\n&gt; &gt; level.  This way using the default \'equals\' (same instance) would\u003cbr\\/\u003e\\n&gt; &gt; work.  Or we could establish identity (equals) of a SegmentInfo as\u003cbr\\/\u003e\\n&gt; &gt; checking if the directory plus segment name are equal?  I think\u003cbr\\/\u003e\\n&gt; &gt; I\'d lean to the 2nd option....\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I think the 2nd option is better.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'ll take this approach.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Hmmm yes.  In fact I think we can remove synchronized from\u003cbr\\/\u003e\\n&gt; &gt; optimize altogether since within it we are synchronizing(this) at\u003cbr\\/\u003e\\n&gt; &gt; the right places?  If more than one thread calls optimize at once,\u003cbr\\/\u003e\\n&gt; &gt; externally, it is actually OK: they will each pick a merge that\'s\u003cbr\\/\u003e\\n&gt; &gt; viable (concurrently) and will run the merge, else return once\u003cbr\\/\u003e\\n&gt; &gt; there is no more concurrency left.  I\'ll add a unit test that\u003cbr\\/\u003e\\n&gt; &gt; confirms this.\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; That seems to be the case.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'ll add unit test to confirm.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; The fact that \\\"the same merge spec will be returned without changes\u003cbr\\/\u003e\\n&gt; to segmentInfos\\\" reminds me: MergePolicy.findCandidateMerges finds\u003cbr\\/\u003e\\n&gt; merges which may not be eligible; but CMPW checks for eligibility\u003cbr\\/\u003e\\n&gt; when looking for candidate merges. Maybe we should unify the\u003cbr\\/\u003e\\n&gt; behaviour?\u003c\\/p\u003e\\n\\n\u003cp\u003eNot quite following you here... not being eligible because the merge\u003cbr\\/\u003e\\nis in-progress in a thread is something I think any given MergePolicy\u003cbr\\/\u003e\\nshould not have to track?  Once I factor out CMPW as its own Merger\u003cbr\\/\u003e\\nsubclass I think the eligibility check happens only in IndexWriter?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; BTW, MergePolicy.optimize (a rename?) doesn\'t check for eligibility\u003cbr\\/\u003e\\n&gt; either.\u003c\\/p\u003e\\n\\n\u003cp\u003eRename to\\/from what?  (It is currently called MergePolicy.optimize).\u003cbr\\/\u003e\\nIndexWriter steps through the merges and only runs the ones that do\u003cbr\\/\u003e\\nnot conflict (are eligible)?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Well, useCompoundFile(...) is given a single newly flushed segment\u003cbr\\/\u003e\\n&gt; &gt; and should decide whether it should be CFS.  Whereas\u003cbr\\/\u003e\\n&gt; &gt; useCompoundDocStore(...) is called when doc stores are flushed.\u003cbr\\/\u003e\\n&gt; &gt; When autoCommit=false, segments can share a single set of doc\u003cbr\\/\u003e\\n&gt; &gt; stores, so there\'s no single SegmentInfo to pass down.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; The reason I asked is because none of them are used right now. So\u003cbr\\/\u003e\\n&gt; they might be used in the future?\u003c\\/p\u003e\\n\\n\u003cp\u003eBoth of these methods are now called by IndexWriter (in the patch),\u003cbr\\/\u003e\\nupon flushing a new segment.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12524039_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524039_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 08:31\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T08:31:22+0000\'\u003e31\\/Aug\\/07 08:31\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n &gt; &gt; Good point...  I think I could refactor this so that cascading logic \\n&gt; &gt; lives entirely in one place IndexWriter. \\n&gt; \\n&gt; Another problem of the current cascading in CMPW.MergeThread is, if \\n&gt; multiple candidate merges are found, all of them are added to \\n&gt; IndexWriter.mergingSegments. But all but the first should be removed \\n&gt; because only the first merge is carried out (thus removed from \\n&gt; mergeSegments after the merge is done). \\n\\n You\'re right &#8211; I\'m only doing the first non-conflicting merge in \\nCMPW (but then not releasing the rest of them).  I think this would be \\nfixed by having cascading logic only in IndexWriter. \\n\\n &gt; How do you make cascading live entirely in IndexWriter? Just \\n&gt; removing cascading from CMPW.MergeThread has one drawback.  For \\n&gt; example, segment sizes of an index are: 40, 20, 10, buffer size is \\n&gt; 10 and merge factor is 2. A buffer full flush of 10 will trigger \\n&gt; merge of 10 &amp; 10, then cascade to 20 &amp; 20, then cascade to 40 &amp; \\n&gt; 40. CMPW without cascading will stop after 10 &amp; 10 since \\n&gt; IndexWriter.maybeMerge has already returned. Then we have to wait \\n&gt; for the next flush to merge 20 &amp; 20. \\n\\n Oh, I would remove from CMPW and add then add it into IndexWriter (so \\nthe scenario above would cascade normally).  Meaning, IndexWriter, \\nupon completing a merge, would always consult the policy for whether \\nthe completed merge has now enabled any new merges. \\n\\n This is somewhat messy though (with CMPW as a MergePolicy) because \\nthen findCandidateMerges would need to know if it was being called \\n(due to cascading) under one of its own threads and if so act \\ndifferently.  Another good reason to make it a separate Merger \\nsubclass. \\n\\n &gt; &gt; How would this be used?  Ie, how would one make an IndexWriter \\n&gt; &gt; that uses the ConcurrentMerger?  Would we add expert methods \\n&gt; &gt; IndexWriter.set\\/getIndexMerger(...)?  (And presumably the \\n&gt; &gt; mergePolicy is now owned by IndexMerger so it would have the \\n&gt; &gt; set\\/getMergePolicy(...)?) \\n&gt; &gt;  \\n&gt; &gt; Also, how would you separate what remains in IW vs what would be \\n&gt; &gt; in IndexMerger? \\n&gt; \\n&gt; Maybe Merger does and only does merge (so IndexWriter still owns \\n&gt; MergePolicy)? Say, base class Merger.merge simply calls \\n&gt; IndexWriter.merge. ConcurrentMerger.merge creates a merge thread if \\n&gt; possible. Otherwise it calls super.merge, which does non-concurrent \\n&gt; merge. IndexWriter simply calls its merger\'s merge instead of its \\n&gt; own merge. Everything else remains in IndexWriter. \\n\\n OK I will test out this approach. \\n\\n &gt; &gt; Hmm ... you\'re right.  This is a separate issue from merge policy, \\n&gt; &gt; right?  Are you proposing buffering deletes in DocumentsWriter \\n&gt; &gt; instead? \\n&gt; \\n&gt; Yes, this is a separate issue. And yes if we consider \\n&gt;  DocumentsWriter as staging area. \\n\\n I will open new issue. \\n\\n &gt; &gt; Good catch!  How to fix?  One thing we could do is always use \\n&gt; &gt; SegmentInfo.reset(...) and never swap in clones at the SegmentInfo \\n&gt; &gt; level.  This way using the default \'equals\' (same instance) would \\n&gt; &gt; work.  Or we could establish identity (equals) of a SegmentInfo as \\n&gt; &gt; checking if the directory plus segment name are equal?  I think \\n&gt; &gt; I\'d lean to the 2nd option.... \\n&gt; \\n&gt; I think the 2nd option is better. \\n\\n I\'ll take this approach. \\n\\n &gt; &gt; Hmmm yes.  In fact I think we can remove synchronized from \\n&gt; &gt; optimize altogether since within it we are synchronizing(this) at \\n&gt; &gt; the right places?  If more than one thread calls optimize at once, \\n&gt; &gt; externally, it is actually OK: they will each pick a merge that\'s \\n&gt; &gt; viable (concurrently) and will run the merge, else return once \\n&gt; &gt; there is no more concurrency left.  I\'ll add a unit test that \\n&gt; &gt; confirms this. \\n&gt; \\n&gt; That seems to be the case. \\n\\n I\'ll add unit test to confirm. \\n\\n &gt; The fact that \\\"the same merge spec will be returned without changes \\n&gt; to segmentInfos\\\" reminds me: MergePolicy.findCandidateMerges finds \\n&gt; merges which may not be eligible; but CMPW checks for eligibility \\n&gt; when looking for candidate merges. Maybe we should unify the \\n&gt; behaviour? \\n\\n Not quite following you here... not being eligible because the merge \\nis in-progress in a thread is something I think any given MergePolicy \\nshould not have to track?  Once I factor out CMPW as its own Merger \\nsubclass I think the eligibility check happens only in IndexWriter? \\n\\n &gt; BTW, MergePolicy.optimize (a rename?) doesn\'t check for eligibility \\n&gt; either. \\n\\n Rename to\\/from what?  (It is currently called MergePolicy.optimize). \\nIndexWriter steps through the merges and only runs the ones that do \\nnot conflict (are eligible)? \\n\\n &gt; &gt; Well, useCompoundFile(...) is given a single newly flushed segment \\n&gt; &gt; and should decide whether it should be CFS.  Whereas \\n&gt; &gt; useCompoundDocStore(...) is called when doc stores are flushed. \\n&gt; &gt; When autoCommit=false, segments can share a single set of doc \\n&gt; &gt; stores, so there\'s no single SegmentInfo to pass down. \\n&gt;  \\n&gt; The reason I asked is because none of them are used right now. So \\n&gt; they might be used in the future? \\n\\n Both of these methods are now called by IndexWriter (in the patch), \\nupon flushing a new segment.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12524084\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12524084&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12524084\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12524084_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524084_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 13:39\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T13:39:44+0000\'\u003e31\\/Aug\\/07 13:39\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Not quite following you here... not being eligible because the merge\u003cbr\\/\u003e\\n&gt; is in-progress in a thread is something I think any given MergePolicy\u003cbr\\/\u003e\\n&gt; should not have to track?  Once I factor out CMPW as its own Merger\u003cbr\\/\u003e\\n&gt; subclass I think the eligibility check happens only in IndexWriter?\u003c\\/p\u003e\\n\\n\u003cp\u003eI was referring to the current patch: LogMergePolicy does not check for eligibility, but CMPW, a subclass of MergePolicy, checks for eligibility. Yes, the eligibility check only happens in IndexWriter after we do Merger class.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Rename to\\/from what?  (It is currently called MergePolicy.optimize).\u003cbr\\/\u003e\\n&gt; IndexWriter steps through the merges and only runs the ones that do\u003cbr\\/\u003e\\n&gt; not conflict (are eligible)?\u003c\\/p\u003e\\n\\n\u003cp\u003eMaybe rename to MergePolicy.findMergesToOptimize?\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; The reason I asked is because none of them are used right now. So\u003cbr\\/\u003e\\n&gt; &gt; they might be used in the future?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Both of these methods are now called by IndexWriter (in the patch),\u003cbr\\/\u003e\\n&gt; upon flushing a new segment.\u003c\\/p\u003e\\n\\n\u003cp\u003eI was referring to the parameters. The parameters are not used.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12524084_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524084_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 13:39\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T13:39:44+0000\'\u003e31\\/Aug\\/07 13:39\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Not quite following you here... not being eligible because the merge \\n&gt; is in-progress in a thread is something I think any given MergePolicy \\n&gt; should not have to track?  Once I factor out CMPW as its own Merger \\n&gt; subclass I think the eligibility check happens only in IndexWriter? \\n\\n I was referring to the current patch: LogMergePolicy does not check for eligibility, but CMPW, a subclass of MergePolicy, checks for eligibility. Yes, the eligibility check only happens in IndexWriter after we do Merger class. \\n\\n &gt; Rename to\\/from what?  (It is currently called MergePolicy.optimize). \\n&gt; IndexWriter steps through the merges and only runs the ones that do \\n&gt; not conflict (are eligible)? \\n\\n Maybe rename to MergePolicy.findMergesToOptimize? \\n\\n &gt; &gt; The reason I asked is because none of them are used right now. So \\n&gt; &gt; they might be used in the future? \\n&gt;  \\n&gt; Both of these methods are now called by IndexWriter (in the patch), \\n&gt; upon flushing a new segment. \\n\\n I was referring to the parameters. The parameters are not used.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12524138\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12524138&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12524138\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12524138_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524138_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 17:01\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T17:01:51+0000\'\u003e31\\/Aug\\/07 17:01\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003e&gt; &gt; Not quite following you here... not being eligible because the\u003cbr\\/\u003e\\n&gt; &gt; merge is in-progress in a thread is something I think any given\u003cbr\\/\u003e\\n&gt; &gt; MergePolicy should not have to track?  Once I factor out CMPW as\u003cbr\\/\u003e\\n&gt; &gt; its own Merger subclass I think the eligibility check happens only\u003cbr\\/\u003e\\n&gt; &gt; in IndexWriter?\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; I was referring to the current patch: LogMergePolicy does not check\u003cbr\\/\u003e\\n&gt; for eligibility, but CMPW, a subclass of MergePolicy, checks for\u003cbr\\/\u003e\\n&gt; eligibility. Yes, the eligibility check only happens in IndexWriter\u003cbr\\/\u003e\\n&gt; after we do Merger class.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, let\'s leave eligibility check in IW.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; Rename to\\/from what?  (It is currently called\u003cbr\\/\u003e\\n&gt; &gt; MergePolicy.optimize).  IndexWriter steps through the merges and\u003cbr\\/\u003e\\n&gt; &gt; only runs the ones that do not conflict (are eligible)?\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; Maybe rename to MergePolicy.findMergesToOptimize?\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, that\'s good.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; &gt; &gt; The reason I asked is because none of them are used right\u003cbr\\/\u003e\\n&gt; &gt; &gt; now. So they might be used in the future?\u003cbr\\/\u003e\\n&gt; &gt; \u003cbr\\/\u003e\\n&gt; &gt; Both of these methods are now called by IndexWriter (in the\u003cbr\\/\u003e\\n&gt; &gt; patch), upon flushing a new segment.\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt; I was referring to the parameters. The parameters are not used.\u003c\\/p\u003e\\n\\n\u003cp\u003eAhh, got it.  Yes the thinking is merge policies in the future may\u003cbr\\/\u003e\\nwant to look @ segmentinfos to decide.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12524138_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12524138_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'31\\/Aug\\/07 17:01\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-08-31T17:01:51+0000\'\u003e31\\/Aug\\/07 17:01\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n &gt; &gt; Not quite following you here... not being eligible because the \\n&gt; &gt; merge is in-progress in a thread is something I think any given \\n&gt; &gt; MergePolicy should not have to track?  Once I factor out CMPW as \\n&gt; &gt; its own Merger subclass I think the eligibility check happens only \\n&gt; &gt; in IndexWriter? \\n&gt; \\n&gt; I was referring to the current patch: LogMergePolicy does not check \\n&gt; for eligibility, but CMPW, a subclass of MergePolicy, checks for \\n&gt; eligibility. Yes, the eligibility check only happens in IndexWriter \\n&gt; after we do Merger class. \\n\\n OK, let\'s leave eligibility check in IW. \\n\\n &gt; &gt; Rename to\\/from what?  (It is currently called \\n&gt; &gt; MergePolicy.optimize).  IndexWriter steps through the merges and \\n&gt; &gt; only runs the ones that do not conflict (are eligible)? \\n&gt;  \\n&gt; Maybe rename to MergePolicy.findMergesToOptimize? \\n\\n OK, that\'s good. \\n\\n &gt; &gt; &gt; The reason I asked is because none of them are used right \\n&gt; &gt; &gt; now. So they might be used in the future? \\n&gt; &gt;  \\n&gt; &gt; Both of these methods are now called by IndexWriter (in the \\n&gt; &gt; patch), upon flushing a new segment. \\n&gt;  \\n&gt; I was referring to the parameters. The parameters are not used. \\n\\n Ahh, got it.  Yes the thinking is merge policies in the future may \\nwant to look @ segmentinfos to decide.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12525783\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12525783&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12525783\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525783_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525783_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 17:17\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T17:17:01+0000\'\u003e07\\/Sep\\/07 17:17\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003eAttached new patch (take5) incorporating Ning\'s feedback.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis patch includes \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e (a new merge default merge policy plus\u003cbr\\/\u003e\\na \\\"merge by size in bytes of segment\\\" merge policy), \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-847\\\" title=\\\"Factor merge policy out of IndexWriter\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-847\\\"\u003e\u003cdel\u003eLUCENE-847\u003c\\/del\u003e\u003c\\/a\u003e\u003cbr\\/\u003e\\n(factor merge policy\\/scheduling out of IndexWriter) and \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-870\\\" title=\\\"add concurrent merge policy\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-870\\\"\u003e\u003cdel\u003eLUCENE-870\u003c\\/del\u003e\u003c\\/a\u003e\u003cbr\\/\u003e\\n(ConcurrentMergeScheduler).\u003c\\/p\u003e\\n\\n\u003cp\u003eThe one thing remaining after these are done, that I\'ll open a\u003cbr\\/\u003e\\nseparate issue for and commit separately, is to switch IndexWriter to\u003cbr\\/\u003e\\nflush by RAM usage by default (instead of by docCount == 10) as well\u003cbr\\/\u003e\\nas merge by size-in-bytes by default.\u003c\\/p\u003e\\n\\n\u003cp\u003eI broke out a separate MergeScheduler interface.  SerialMergeScheduler\u003cbr\\/\u003e\\nis the default (matches how merges are executed today: sequentially,\u003cbr\\/\u003e\\nusing the calling thread).  ConcurrentMergeScheduler runs the merges\u003cbr\\/\u003e\\nas separate threads (up to a max number at which point the extras are\u003cbr\\/\u003e\\ndone sequentially).\u003c\\/p\u003e\\n\\n\u003cp\u003eOther changes:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eAllow multiple threads to call optimize().  I added a unit test\u003cbr\\/\u003e\\n    for this.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eTightnened calls to deleter.refresh(), which remove partially\u003cbr\\/\u003e\\n    created files on an exception, to remove only those files that the\u003cbr\\/\u003e\\n    given piece of code would create.  This is very important because\u003cbr\\/\u003e\\n    otherwise refresh() could remove the files being created by a\u003cbr\\/\u003e\\n    background merge.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eAdded some unit tests\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525783_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525783_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 17:17\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T17:17:01+0000\'\u003e07\\/Sep\\/07 17:17\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n Attached new patch (take5) incorporating Ning\'s feedback. \\n\\n This patch includes   LUCENE-845   (a new merge default merge policy plus \\na \\\"merge by size in bytes of segment\\\" merge policy),   LUCENE-847   \\n(factor merge policy\\/scheduling out of IndexWriter) and   LUCENE-870   \\n(ConcurrentMergeScheduler). \\n\\n The one thing remaining after these are done, that I\'ll open a \\nseparate issue for and commit separately, is to switch IndexWriter to \\nflush by RAM usage by default (instead of by docCount == 10) as well \\nas merge by size-in-bytes by default. \\n\\n I broke out a separate MergeScheduler interface.  SerialMergeScheduler \\nis the default (matches how merges are executed today: sequentially, \\nusing the calling thread).  ConcurrentMergeScheduler runs the merges \\nas separate threads (up to a max number at which point the extras are \\ndone sequentially). \\n\\n Other changes: \\n\\n \\n\\t Allow multiple threads to call optimize().  I added a unit test \\n    for this. \\n \\n\\n\\n \\n\\t Tightnened calls to deleter.refresh(), which remove partially \\n    created files on an exception, to remove only those files that the \\n    given piece of code would create.  This is very important because \\n    otherwise refresh() could remove the files being created by a \\n    background merge. \\n \\n\\n\\n \\n\\t Added some unit tests \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12525797\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12525797&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12525797\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"cutting\\\" id=\\\"commentauthor_12525797_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=cutting\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"cutting\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Doug Cutting\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525797_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 18:19\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T18:19:36+0000\'\u003e07\\/Sep\\/07 18:19\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eIs there any reason not to make ConcurrentMergeScheduler the default too after this is committed?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"cutting\\\" id=\\\"commentauthor_12525797_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=cutting\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"cutting\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Doug Cutting\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525797_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 18:19\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T18:19:36+0000\'\u003e07\\/Sep\\/07 18:19\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Is there any reason not to make ConcurrentMergeScheduler the default too after this is committed?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12525802\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12525802&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12525802\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525802_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525802_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 18:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T18:47:07+0000\'\u003e07\\/Sep\\/07 18:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Is there any reason not to make ConcurrentMergeScheduler the default too after this is committed?\u003c\\/p\u003e\\n\\n\u003cp\u003eGood question.  The only downsides I can think of are:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eIt\'s all fresh code so until we let it \\\"age\\\" some, it\'s a higher\u003cbr\\/\u003e\\n    risk that something broke.  That said there is decent unit test\u003cbr\\/\u003e\\n    coverage for it and these unit tests did find some sneaky issues\u003cbr\\/\u003e\\n    (which I fixed!).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eIt only actually helps on machines that have some concurrency.\u003cbr\\/\u003e\\n    But in this case we are largely talking about IO concurrent w\\/ CPU\u003cbr\\/\u003e\\n    which nearly all machines have I think.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eI think the benefits are sizable:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eGood performance gains (25% speedup of net indexing time for all\u003cbr\\/\u003e\\n    of Wikipedia content &#8211; details in \u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-870\\\" title=\\\"add concurrent merge policy\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-870\\\"\u003e\u003cdel\u003eLUCENE-870\u003c\\/del\u003e\u003c\\/a\u003e)\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eTrivial way to leverage concurrency (ie you don\'t need to manage\u003cbr\\/\u003e\\n    your own threads).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eNo more unexpected long pauses on certain addDocument calls.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cp\u003eSo I think it would make sense to make it the default.  I\'ll include\u003cbr\\/\u003e\\nthat in the new issue for changing defaults in IndexWriter.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525802_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525802_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'07\\/Sep\\/07 18:47\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-07T18:47:07+0000\'\u003e07\\/Sep\\/07 18:47\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Is there any reason not to make ConcurrentMergeScheduler the default too after this is committed? \\n\\n Good question.  The only downsides I can think of are: \\n\\n \\n\\t It\'s all fresh code so until we let it \\\"age\\\" some, it\'s a higher \\n    risk that something broke.  That said there is decent unit test \\n    coverage for it and these unit tests did find some sneaky issues \\n    (which I fixed!). \\n \\n\\n\\n \\n\\t It only actually helps on machines that have some concurrency. \\n    But in this case we are largely talking about IO concurrent w\\/ CPU \\n    which nearly all machines have I think. \\n \\n\\n\\n I think the benefits are sizable: \\n\\n \\n\\t Good performance gains (25% speedup of net indexing time for all \\n    of Wikipedia content &#8211; details in   LUCENE-870  ) \\n \\n\\n\\n \\n\\t Trivial way to leverage concurrency (ie you don\'t need to manage \\n    your own threads). \\n \\n\\n\\n \\n\\t No more unexpected long pauses on certain addDocument calls. \\n \\n\\n\\n So I think it would make sense to make it the default.  I\'ll include \\nthat in the new issue for changing defaults in IndexWriter.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12525903\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12525903&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12525903\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525903_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525903_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Sep\\/07 10:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-08T10:11:24+0000\'\u003e08\\/Sep\\/07 10:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOK, as a better test of ConcurrentMergeScheduler, and towards making it\u003cbr\\/\u003e\\nthe default merge scheduler, I tried making it the default in\u003cbr\\/\u003e\\nIndexWriter and then ran all unit tests, and uncovered problems with\u003cbr\\/\u003e\\nthe current patch (notably how optimize works!).  So I\'m working on an\u003cbr\\/\u003e\\nnew patch now....\u003c\\/p\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12525903_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12525903_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'08\\/Sep\\/07 10:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-08T10:11:24+0000\'\u003e08\\/Sep\\/07 10:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    OK, as a better test of ConcurrentMergeScheduler, and towards making it \\nthe default merge scheduler, I tried making it the default in \\nIndexWriter and then ran all unit tests, and uncovered problems with \\nthe current patch (notably how optimize works!).  So I\'m working on an \\nnew patch now.... \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526029\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526029&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526029\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12526029_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526029_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'09\\/Sep\\/07 21:28\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-09T21:28:23+0000\'\u003e09\\/Sep\\/07 21:28\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eComments on optimize():\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIn the while loop of optimize(), LogMergePolicy.findMergesForOptimize returns a merge spec with one merge. If ConcurrentMergeScheduler is used, the one merge will be started in MergeScheduler.merge() and findMergesForOptimize will be called again. Before the one merge finishes, findMergesForOptimize will return the same spec but the one merge is already started. So only one concurrent merge is possible and the main thread will spin on calling findMergesForOptimize and attempting to merge.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eOne possible solution is to make LogMergePolicy.findMergesForOptimize return multiple merge candidates. It allows higher level of concurrency. It also alleviates a bit the problem of main thread spinning. To solve this problem, maybe we can check if a merge is actually started, then sleep briefly if not (which means all merges candidates are in conflict)?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\\n\u003cp\u003eA comment on concurrent merge threads:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eOne difference between the current approach on concurrent merge and the patch I posted a while back is that, in the current approach, a MergeThread object is created and started for every concurrent merge. In my old patch, maxThreadCount of threads are created and started at the beginning and are used throughout. Both have pros and cons.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12526029_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526029_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'09\\/Sep\\/07 21:28\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-09T21:28:23+0000\'\u003e09\\/Sep\\/07 21:28\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Comments on optimize(): \\n\\n \\n\\t In the while loop of optimize(), LogMergePolicy.findMergesForOptimize returns a merge spec with one merge. If ConcurrentMergeScheduler is used, the one merge will be started in MergeScheduler.merge() and findMergesForOptimize will be called again. Before the one merge finishes, findMergesForOptimize will return the same spec but the one merge is already started. So only one concurrent merge is possible and the main thread will spin on calling findMergesForOptimize and attempting to merge. \\n \\n\\n\\n \\n\\t One possible solution is to make LogMergePolicy.findMergesForOptimize return multiple merge candidates. It allows higher level of concurrency. It also alleviates a bit the problem of main thread spinning. To solve this problem, maybe we can check if a merge is actually started, then sleep briefly if not (which means all merges candidates are in conflict)? \\n \\n\\n\\n\\n A comment on concurrent merge threads: \\n\\n \\n\\t One difference between the current approach on concurrent merge and the patch I posted a while back is that, in the current approach, a MergeThread object is created and started for every concurrent merge. In my old patch, maxThreadCount of threads are created and started at the beginning and are used throughout. Both have pros and cons. \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526302\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526302&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526302\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526302_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526302_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'10\\/Sep\\/07 23:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-10T23:20:03+0000\'\u003e10\\/Sep\\/07 23:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eOK, another rev of the patch (take6).  I think it\'s close!\u003c\\/p\u003e\\n\\n\u003cp\u003eThis patch passes all unit tests with SerialMergeScheduler (left as\u003cbr\\/\u003e\\nthe default for now) and also passes all unit tests once you switch\u003cbr\\/\u003e\\nthe default to ConcurrentMergeScheduler instead.\u003c\\/p\u003e\\n\\n\u003cp\u003eI made one simplification to the approach: IndexWriter now keeps track\u003cbr\\/\u003e\\nof \\\"pendingMerges\\\" (merges that mergePolicy has declared are necessary\u003cbr\\/\u003e\\nbut have not yet been started), and \\\"runningMerges\\\" (merges currently\u003cbr\\/\u003e\\nin flight).  Then MergeScheduler just asks IndexWriter for the next\u003cbr\\/\u003e\\npending merge when it\'s ready to run it.  This also cleaned up how\u003cbr\\/\u003e\\ncascading works.\u003c\\/p\u003e\\n\\n\u003cp\u003eOther changes:\u003c\\/p\u003e\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eOptimize: optimize is now fully concurrent (it can run multiple\u003cbr\\/\u003e\\n    merges at once, new segments can be flushed during an optimize,\u003cbr\\/\u003e\\n    etc).  Optimize will optimize only those segments present when it\u003cbr\\/\u003e\\n    started (newly flushed segments may remain separate).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eNew API: optimize(boolean doWait) allows you to not wait for\u003cbr\\/\u003e\\n    optimize to complete (it runs in background).  This only works\u003cbr\\/\u003e\\n    when MergeScheduler uses threads.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eNew API: close(boolean doWait) allows you to not wait for running\u003cbr\\/\u003e\\n    merges if you want to \\\"close in a hurry\\\".  Also only works when\u003cbr\\/\u003e\\n    MergeScheduler uses threads.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eI fixed LogMergePolicy to expose merge concurrency during optimize\u003cbr\\/\u003e\\n    by first calling the \\\"normal\\\" merge policy to see if it requires\u003cbr\\/\u003e\\n    merges and returning those merges if so, and then falling back to\u003cbr\\/\u003e\\n    the normal \\\"merge the tail &lt;= mergeFactor segments until there is\u003cbr\\/\u003e\\n    only 1 left\\\".\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eBecause IndexModifier synchronizes on directory, it can\'t use\u003cbr\\/\u003e\\n    ConcurrentMergeScheduler since this quickly leads to deadlock at\u003cbr\\/\u003e\\n    least during IndexWriter.close.  So I set it back to\u003cbr\\/\u003e\\n    SerialMergeScheduler (it is deprecated anyway).\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eAdded private IndexWriter.message(...) that prints message to the\u003cbr\\/\u003e\\n    infoStream prefixed by the thread name and changed all\u003cbr\\/\u003e\\n    infoStream.print*\'s to message(...).  Also added more messages in\u003cbr\\/\u003e\\n    the exceptional cases to aid future diagnostics.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul\u003e\\n\\t\u003cli\u003eAdded more unit tests\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526302_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526302_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'10\\/Sep\\/07 23:20\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-10T23:20:03+0000\'\u003e10\\/Sep\\/07 23:20\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    OK, another rev of the patch (take6).  I think it\'s close! \\n\\n This patch passes all unit tests with SerialMergeScheduler (left as \\nthe default for now) and also passes all unit tests once you switch \\nthe default to ConcurrentMergeScheduler instead. \\n\\n I made one simplification to the approach: IndexWriter now keeps track \\nof \\\"pendingMerges\\\" (merges that mergePolicy has declared are necessary \\nbut have not yet been started), and \\\"runningMerges\\\" (merges currently \\nin flight).  Then MergeScheduler just asks IndexWriter for the next \\npending merge when it\'s ready to run it.  This also cleaned up how \\ncascading works. \\n\\n Other changes: \\n\\n \\n\\t Optimize: optimize is now fully concurrent (it can run multiple \\n    merges at once, new segments can be flushed during an optimize, \\n    etc).  Optimize will optimize only those segments present when it \\n    started (newly flushed segments may remain separate). \\n \\n\\n\\n \\n\\t New API: optimize(boolean doWait) allows you to not wait for \\n    optimize to complete (it runs in background).  This only works \\n    when MergeScheduler uses threads. \\n \\n\\n\\n \\n\\t New API: close(boolean doWait) allows you to not wait for running \\n    merges if you want to \\\"close in a hurry\\\".  Also only works when \\n    MergeScheduler uses threads. \\n \\n\\n\\n \\n\\t I fixed LogMergePolicy to expose merge concurrency during optimize \\n    by first calling the \\\"normal\\\" merge policy to see if it requires \\n    merges and returning those merges if so, and then falling back to \\n    the normal \\\"merge the tail &lt;= mergeFactor segments until there is \\n    only 1 left\\\". \\n \\n\\n\\n \\n\\t Because IndexModifier synchronizes on directory, it can\'t use \\n    ConcurrentMergeScheduler since this quickly leads to deadlock at \\n    least during IndexWriter.close.  So I set it back to \\n    SerialMergeScheduler (it is deprecated anyway). \\n \\n\\n\\n \\n\\t Added private IndexWriter.message(...) that prints message to the \\n    infoStream prefixed by the thread name and changed all \\n    infoStream.print*\'s to message(...).  Also added more messages in \\n    the exceptional cases to aid future diagnostics. \\n \\n\\n\\n \\n\\t Added more unit tests \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526305\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526305&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526305\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526305_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526305_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'10\\/Sep\\/07 23:28\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-10T23:28:26+0000\'\u003e10\\/Sep\\/07 23:28\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003e&gt; In the while loop of optimize(), LogMergePolicy.findMergesForOptimize\u003cbr\\/\u003e\\n&gt; returns a merge spec with one merge. If ConcurrentMergeScheduler is\u003cbr\\/\u003e\\n&gt; used, the one merge will be started in MergeScheduler.merge() and\u003cbr\\/\u003e\\n&gt; findMergesForOptimize will be called again. Before the one merge\u003cbr\\/\u003e\\n&gt; finishes, findMergesForOptimize will return the same spec but the\u003cbr\\/\u003e\\n&gt; one merge is already started. So only one concurrent merge is\u003cbr\\/\u003e\\n&gt; possible and the main thread will spin on calling\u003cbr\\/\u003e\\n&gt; findMergesForOptimize and attempting to merge.\u003c\\/p\u003e\\n\\n\u003cp\u003eYes.  The new patch has cleaned this up nicely, I think.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; One possible solution is to make LogMergePolicy.findMergesForOptimize\u003cbr\\/\u003e\\n&gt; return multiple merge candidates. It allows higher level of\u003cbr\\/\u003e\\n&gt; concurrency.\u003c\\/p\u003e\\n\\n\u003cp\u003eGood idea!  I took exactly this approach in patch I just attached.  I\u003cbr\\/\u003e\\nmade a simple change: LogMergePolicy.findMergesForOptimize first\u003cbr\\/\u003e\\nchecks if \\\"normal merging\\\" would want to do merges and returns them if\u003cbr\\/\u003e\\nso.  Since \\\"normal merging\\\" exposes concurrent merges, this gains us\u003cbr\\/\u003e\\nconcurrency for optimize in cases where the index has too many\u003cbr\\/\u003e\\nsegments.  I wasn\'t sure how otherwise to expose concurrency...\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; It also alleviates a bit the problem of main thread spinning. To\u003cbr\\/\u003e\\n&gt; solve this problem, maybe we can check if a merge is actually\u003cbr\\/\u003e\\n&gt; started, then sleep briefly if not (which means all merges\u003cbr\\/\u003e\\n&gt; candidates are in conflict)?\u003c\\/p\u003e\\n\\n\u003cp\u003eThis is much cleaner in new patch: there is no more spinning.  In new\u003cbr\\/\u003e\\npatch if multiple threads are merging (either spawned by\u003cbr\\/\u003e\\nConcurrentMergeaScheduler or provided by the application or both) then\u003cbr\\/\u003e\\nthey all pull from a shared queue of \\\"merges needing to run\\\" and then\u003cbr\\/\u003e\\nreturn when that queue is empty.  So no more spinning.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; One difference between the current approach on concurrent merge and\u003cbr\\/\u003e\\n&gt; the patch I posted a while back is that, in the current approach, a\u003cbr\\/\u003e\\n&gt; MergeThread object is created and started for every concurrent\u003cbr\\/\u003e\\n&gt; merge. In my old patch, maxThreadCount of threads are created and\u003cbr\\/\u003e\\n&gt; started at the beginning and are used throughout. Both have pros and\u003cbr\\/\u003e\\n&gt; cons.\u003c\\/p\u003e\\n\\n\u003cp\u003eYeah I thought I would keep it simple (launch thread when needed then\u003cbr\\/\u003e\\nlet it finish when it\'s done) rather than use a pool.  This way\u003cbr\\/\u003e\\nthreads are only created (and are only alive) while concurrency is\u003cbr\\/\u003e\\nactually needed (ie &gt; N merges necessary at once).  But yes there are\u003cbr\\/\u003e\\npros\\/cons either way.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526305_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526305_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'10\\/Sep\\/07 23:28\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-10T23:28:26+0000\'\u003e10\\/Sep\\/07 23:28\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n &gt; In the while loop of optimize(), LogMergePolicy.findMergesForOptimize \\n&gt; returns a merge spec with one merge. If ConcurrentMergeScheduler is \\n&gt; used, the one merge will be started in MergeScheduler.merge() and \\n&gt; findMergesForOptimize will be called again. Before the one merge \\n&gt; finishes, findMergesForOptimize will return the same spec but the \\n&gt; one merge is already started. So only one concurrent merge is \\n&gt; possible and the main thread will spin on calling \\n&gt; findMergesForOptimize and attempting to merge. \\n\\n Yes.  The new patch has cleaned this up nicely, I think. \\n\\n &gt; One possible solution is to make LogMergePolicy.findMergesForOptimize \\n&gt; return multiple merge candidates. It allows higher level of \\n&gt; concurrency. \\n\\n Good idea!  I took exactly this approach in patch I just attached.  I \\nmade a simple change: LogMergePolicy.findMergesForOptimize first \\nchecks if \\\"normal merging\\\" would want to do merges and returns them if \\nso.  Since \\\"normal merging\\\" exposes concurrent merges, this gains us \\nconcurrency for optimize in cases where the index has too many \\nsegments.  I wasn\'t sure how otherwise to expose concurrency... \\n\\n &gt; It also alleviates a bit the problem of main thread spinning. To \\n&gt; solve this problem, maybe we can check if a merge is actually \\n&gt; started, then sleep briefly if not (which means all merges \\n&gt; candidates are in conflict)? \\n\\n This is much cleaner in new patch: there is no more spinning.  In new \\npatch if multiple threads are merging (either spawned by \\nConcurrentMergeaScheduler or provided by the application or both) then \\nthey all pull from a shared queue of \\\"merges needing to run\\\" and then \\nreturn when that queue is empty.  So no more spinning. \\n\\n &gt; One difference between the current approach on concurrent merge and \\n&gt; the patch I posted a while back is that, in the current approach, a \\n&gt; MergeThread object is created and started for every concurrent \\n&gt; merge. In my old patch, maxThreadCount of threads are created and \\n&gt; started at the beginning and are used throughout. Both have pros and \\n&gt; cons. \\n\\n Yeah I thought I would keep it simple (launch thread when needed then \\nlet it finish when it\'s done) rather than use a pool.  This way \\nthreads are only created (and are only alive) while concurrency is \\nactually needed (ie &gt; N merges necessary at once).  But yes there are \\npros\\/cons either way.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526628\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526628&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526628\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12526628_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526628_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'11\\/Sep\\/07 22:59\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-11T22:59:52+0000\'\u003e11\\/Sep\\/07 22:59\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; OK, another rev of the patch (take6).  I think it\'s close!\u003c\\/p\u003e\\n\\n\u003cp\u003eYes, it\'s close! \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; I made one simplification to the approach: IndexWriter now keeps track\u003cbr\\/\u003e\\n&gt; of \\\"pendingMerges\\\" (merges that mergePolicy has declared are necessary\u003cbr\\/\u003e\\n&gt; but have not yet been started), and \\\"runningMerges\\\" (merges currently\u003cbr\\/\u003e\\n&gt; in flight).  Then MergeScheduler just asks IndexWriter for the next\u003cbr\\/\u003e\\n&gt; pending merge when it\'s ready to run it.  This also cleaned up how\u003cbr\\/\u003e\\n&gt; cascading works.\u003c\\/p\u003e\\n\\n\u003cp\u003eI like this simplification.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt;   * Optimize: optimize is now fully concurrent (it can run multiple\u003cbr\\/\u003e\\n&gt;     merges at once, new segments can be flushed during an optimize,\u003cbr\\/\u003e\\n&gt;     etc).  Optimize will optimize only those segments present when it\u003cbr\\/\u003e\\n&gt;     started (newly flushed segments may remain separate).\u003c\\/p\u003e\\n\\n\u003cp\u003eThis semantics does add a bit complexity - segmentsToOptimize, OneMerge.optimize.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Good idea!  I took exactly this approach in patch I just attached.  I\u003cbr\\/\u003e\\n&gt; made a simple change: LogMergePolicy.findMergesForOptimize first\u003cbr\\/\u003e\\n&gt; checks if \\\"normal merging\\\" would want to do merges and returns them if\u003cbr\\/\u003e\\n&gt; so.  Since \\\"normal merging\\\" exposes concurrent merges, this gains us\u003cbr\\/\u003e\\n&gt; concurrency for optimize in cases where the index has too many\u003cbr\\/\u003e\\n&gt; segments.  I wasn\'t sure how otherwise to expose concurrency...\u003c\\/p\u003e\\n\\n\u003cp\u003eAnother option is to schedule merges for the newest N segments and the next newest N segments and the next next... N is the merge factor.\u003c\\/p\u003e\\n\\n\\n\u003cp\u003eA couple of other things:\u003c\\/p\u003e\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIt seems you intended sync() to be part of the MergeScheduler interface?\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n\\n\\n\u003cul class=\\\"alternate\\\" type=\\\"square\\\"\u003e\\n\\t\u003cli\u003eIndexWriter.close(\u003cspan class=\\\"error\\\"\u003e&#91;true&#93;\u003c\\/span\u003e), abort(): The behaviour should be the same whether the calling thread is the one that actually gets to do the closing. Right now, only the thread that actually does the closing waits for the closing. The others do not wait for the closing.\u003c\\/li\u003e\\n\u003c\\/ul\u003e\\n \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12526628_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526628_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'11\\/Sep\\/07 22:59\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-11T22:59:52+0000\'\u003e11\\/Sep\\/07 22:59\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; OK, another rev of the patch (take6).  I think it\'s close! \\n\\n Yes, it\'s close!   \\n\\n &gt; I made one simplification to the approach: IndexWriter now keeps track \\n&gt; of \\\"pendingMerges\\\" (merges that mergePolicy has declared are necessary \\n&gt; but have not yet been started), and \\\"runningMerges\\\" (merges currently \\n&gt; in flight).  Then MergeScheduler just asks IndexWriter for the next \\n&gt; pending merge when it\'s ready to run it.  This also cleaned up how \\n&gt; cascading works. \\n\\n I like this simplification. \\n\\n &gt;   * Optimize: optimize is now fully concurrent (it can run multiple \\n&gt;     merges at once, new segments can be flushed during an optimize, \\n&gt;     etc).  Optimize will optimize only those segments present when it \\n&gt;     started (newly flushed segments may remain separate). \\n\\n This semantics does add a bit complexity - segmentsToOptimize, OneMerge.optimize. \\n\\n &gt; Good idea!  I took exactly this approach in patch I just attached.  I \\n&gt; made a simple change: LogMergePolicy.findMergesForOptimize first \\n&gt; checks if \\\"normal merging\\\" would want to do merges and returns them if \\n&gt; so.  Since \\\"normal merging\\\" exposes concurrent merges, this gains us \\n&gt; concurrency for optimize in cases where the index has too many \\n&gt; segments.  I wasn\'t sure how otherwise to expose concurrency... \\n\\n Another option is to schedule merges for the newest N segments and the next newest N segments and the next next... N is the merge factor. \\n\\n\\n A couple of other things: \\n\\n \\n\\t It seems you intended sync() to be part of the MergeScheduler interface? \\n \\n\\n\\n \\n\\t IndexWriter.close( &#91;true&#93; ), abort(): The behaviour should be the same whether the calling thread is the one that actually gets to do the closing. Right now, only the thread that actually does the closing waits for the closing. The others do not wait for the closing. \\n \\n             \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526712\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526712&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526712\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526712_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526712_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'12\\/Sep\\/07 08:56\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-12T08:56:16+0000\'\u003e12\\/Sep\\/07 08:56\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; &gt; Good idea! I took exactly this approach in patch I just attached. I\u003cbr\\/\u003e\\n&gt; &gt; made a simple change: LogMergePolicy.findMergesForOptimize first\u003cbr\\/\u003e\\n&gt; &gt; checks if \\\"normal merging\\\" would want to do merges and returns them if\u003cbr\\/\u003e\\n&gt; &gt; so. Since \\\"normal merging\\\" exposes concurrent merges, this gains us\u003cbr\\/\u003e\\n&gt; &gt; concurrency for optimize in cases where the index has too many\u003cbr\\/\u003e\\n&gt; &gt; segments. I wasn\'t sure how otherwise to expose concurrency...\u003cbr\\/\u003e\\n&gt;\u003cbr\\/\u003e\\n&gt; Another option is to schedule merges for the newest N segments and\u003cbr\\/\u003e\\n&gt; the next newest N segments and the next next... N is the merge\u003cbr\\/\u003e\\n&gt; factor.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, that is simpler.  I\'ll take that approach (and not call the\u003cbr\\/\u003e\\n\\\"normal\\\" merge policy first).\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; A couple of other things:\u003cbr\\/\u003e\\n&gt; \u003cbr\\/\u003e\\n&gt;   - It seems you intended sync() to be part of the MergeScheduler\u003cbr\\/\u003e\\n&gt;     interface?\u003c\\/p\u003e\\n\\n\u003cp\u003eI had started down this route but then backed away from it: I think\u003cbr\\/\u003e\\nIndexWriter should handle this rather than making every MergeScheduler\u003cbr\\/\u003e\\nhave duplicated code for doing so.  Oh I see, I had left empty sync()\u003cbr\\/\u003e\\nin SerialMergeScheduler; I\'ll remove that.\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt;  - IndexWriter.close(\u003cspan class=\\\"error\\\"\u003e&#91;true&#93;\u003c\\/span\u003e), abort(): The behaviour should be the\u003cbr\\/\u003e\\n&gt;    same whether the calling thread is the one that actually gets to do\u003cbr\\/\u003e\\n&gt;    the closing. Right now, only the thread that actually does the\u003cbr\\/\u003e\\n&gt;    closing waits for the closing. The others do not wait for the\u003cbr\\/\u003e\\n&gt;    closing.\u003c\\/p\u003e\\n\\n\u003cp\u003eAhh good point.  OK, I\'ll have other threads wait() until the\u003cbr\\/\u003e\\nclose\\/abort is complete.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526712_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526712_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'12\\/Sep\\/07 08:56\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-12T08:56:16+0000\'\u003e12\\/Sep\\/07 08:56\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; &gt; Good idea! I took exactly this approach in patch I just attached. I \\n&gt; &gt; made a simple change: LogMergePolicy.findMergesForOptimize first \\n&gt; &gt; checks if \\\"normal merging\\\" would want to do merges and returns them if \\n&gt; &gt; so. Since \\\"normal merging\\\" exposes concurrent merges, this gains us \\n&gt; &gt; concurrency for optimize in cases where the index has too many \\n&gt; &gt; segments. I wasn\'t sure how otherwise to expose concurrency... \\n&gt; \\n&gt; Another option is to schedule merges for the newest N segments and \\n&gt; the next newest N segments and the next next... N is the merge \\n&gt; factor. \\n\\n OK, that is simpler.  I\'ll take that approach (and not call the \\n\\\"normal\\\" merge policy first). \\n\\n &gt; A couple of other things: \\n&gt;  \\n&gt;   - It seems you intended sync() to be part of the MergeScheduler \\n&gt;     interface? \\n\\n I had started down this route but then backed away from it: I think \\nIndexWriter should handle this rather than making every MergeScheduler \\nhave duplicated code for doing so.  Oh I see, I had left empty sync() \\nin SerialMergeScheduler; I\'ll remove that. \\n\\n &gt;  - IndexWriter.close( &#91;true&#93; ), abort(): The behaviour should be the \\n&gt;    same whether the calling thread is the one that actually gets to do \\n&gt;    the closing. Right now, only the thread that actually does the \\n&gt;    closing waits for the closing. The others do not wait for the \\n&gt;    closing. \\n\\n Ahh good point.  OK, I\'ll have other threads wait() until the \\nclose\\/abort is complete.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12526864\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12526864&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12526864\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526864_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526864_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'12\\/Sep\\/07 17:42\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-12T17:42:33+0000\'\u003e12\\/Sep\\/07 17:42\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eNew patch (take 7).\u003c\\/p\u003e\\n\\n\u003cp\u003eI folded in Ning\'s comments (above) and Yonik\'s comments from\u003cbr\\/\u003e\\n\u003ca href=\\\"https:\\/\\/issues.apache.org\\/jira\\/browse\\/LUCENE-845\\\" title=\\\"If you &quot;flush by RAM usage&quot; then IndexWriter may over-merge\\\" class=\\\"issue-link\\\" data-issue-key=\\\"LUCENE-845\\\"\u003e\u003cdel\u003eLUCENE-845\u003c\\/del\u003e\u003c\\/a\u003e, added javadocs &amp; fixed Javadoc warnings and fixed two\u003cbr\\/\u003e\\nother small issues.  All tests pass on Linux, OS X, win32, with either\u003cbr\\/\u003e\\nSerialMergeScheduler or ConcurrentMergeScheduler as the default.\u003c\\/p\u003e\\n\\n\u003cp\u003eI plan to commit in a few days time...\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12526864_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12526864_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'12\\/Sep\\/07 17:42\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-12T17:42:33+0000\'\u003e12\\/Sep\\/07 17:42\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    New patch (take 7). \\n\\n I folded in Ning\'s comments (above) and Yonik\'s comments from \\n  LUCENE-845  , added javadocs &amp; fixed Javadoc warnings and fixed two \\nother small issues.  All tests pass on Linux, OS X, win32, with either \\nSerialMergeScheduler or ConcurrentMergeScheduler as the default. \\n\\n I plan to commit in a few days time...              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527224\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527224&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527224\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527224_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527224_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 19:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T19:11:06+0000\'\u003e13\\/Sep\\/07 19:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eAccess of mergeThreads in ConcurrentMergeScheduler.merge() should be synchronized.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527224_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527224_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 19:11\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T19:11:06+0000\'\u003e13\\/Sep\\/07 19:11\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Access of mergeThreads in ConcurrentMergeScheduler.merge() should be synchronized.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527227\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527227&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527227\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527227_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527227_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 19:14\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T19:14:50+0000\'\u003e13\\/Sep\\/07 19:14\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eAhh, good catch.  Will fix!\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527227_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527227_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 19:14\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T19:14:50+0000\'\u003e13\\/Sep\\/07 19:14\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Ahh, good catch.  Will fix!              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527239\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527239&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527239\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527239_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527239_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 20:22\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T20:22:06+0000\'\u003e13\\/Sep\\/07 20:22\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eHmm, it\'s actually possible to have concurrent merges with SerialMergeScheduler.\u003c\\/p\u003e\\n\\n\u003cp\u003eMaking SerialMergeScheduler.merge synchronize on SerialMergeScheduler will serialize all merges. A merge can still be concurrent with a ram flush.\u003c\\/p\u003e\\n\\n\u003cp\u003eMaking SerialMergeScheduler.merge synchronize on IndexWriter will serialize all merges and ram flushes.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527239_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527239_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 20:22\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T20:22:06+0000\'\u003e13\\/Sep\\/07 20:22\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Hmm, it\'s actually possible to have concurrent merges with SerialMergeScheduler. \\n\\n Making SerialMergeScheduler.merge synchronize on SerialMergeScheduler will serialize all merges. A merge can still be concurrent with a ram flush. \\n\\n Making SerialMergeScheduler.merge synchronize on IndexWriter will serialize all merges and ram flushes.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527258\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527258&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527258\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527258_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527258_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:02\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:02:30+0000\'\u003e13\\/Sep\\/07 21:02\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Hmm, it\'s actually possible to have concurrent merges with\u003cbr\\/\u003e\\n&gt; SerialMergeScheduler.\u003c\\/p\u003e\\n\\n\u003cp\u003eThis was actually intentional: I thought it fine if the application is\u003cbr\\/\u003e\\nsending multiple threads into IndexWriter to allow merges to run\u003cbr\\/\u003e\\nconcurrently.  Because, the application can always back down to a\u003cbr\\/\u003e\\nsingle thread to get everything serialized if that\'s really required?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527258_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527258_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:02\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:02:30+0000\'\u003e13\\/Sep\\/07 21:02\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Hmm, it\'s actually possible to have concurrent merges with \\n&gt; SerialMergeScheduler. \\n\\n This was actually intentional: I thought it fine if the application is \\nsending multiple threads into IndexWriter to allow merges to run \\nconcurrently.  Because, the application can always back down to a \\nsingle thread to get everything serialized if that\'s really required?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527286\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527286&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527286\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527286_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527286_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:49\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:49:45+0000\'\u003e13\\/Sep\\/07 21:49\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; This was actually intentional: I thought it fine if the application is\u003cbr\\/\u003e\\n&gt; sending multiple threads into IndexWriter to allow merges to run\u003cbr\\/\u003e\\n&gt; concurrently.  Because, the application can always back down to a\u003cbr\\/\u003e\\n&gt; single thread to get everything serialized if that\'s really required?\u003c\\/p\u003e\\n\\n\u003cp\u003eToday, applications use multiple threads on IndexWriter to get some concurrency on document parsing. With this patch, applications that want concurrent merges would simply use ConcurrentMergeScheduler, no?\u003c\\/p\u003e\\n\\n\u003cp\u003eOr a rename since it doesn\'t really serialize merges?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"ningli\\\" id=\\\"commentauthor_12527286_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=ningli\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"ningli\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Ning Li\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527286_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:49\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:49:45+0000\'\u003e13\\/Sep\\/07 21:49\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; This was actually intentional: I thought it fine if the application is \\n&gt; sending multiple threads into IndexWriter to allow merges to run \\n&gt; concurrently.  Because, the application can always back down to a \\n&gt; single thread to get everything serialized if that\'s really required? \\n\\n Today, applications use multiple threads on IndexWriter to get some concurrency on document parsing. With this patch, applications that want concurrent merges would simply use ConcurrentMergeScheduler, no? \\n\\n Or a rename since it doesn\'t really serialize merges?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527289\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527289&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527289\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"markrmiller@gmail.com\\\" id=\\\"commentauthor_12527289_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=markrmiller%40gmail.com\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"markrmiller@gmail.com\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Mark Miller\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527289_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:59\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:59:55+0000\'\u003e13\\/Sep\\/07 21:59\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eI have to triple check, but on first glance, my apps performance halfed using the ConcurrentMergeScheduler on a recent core duo with 2 GB RAM (As compared to the SerialMergeSceduler). Seems unexpected?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"markrmiller@gmail.com\\\" id=\\\"commentauthor_12527289_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=markrmiller%40gmail.com\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"markrmiller@gmail.com\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Mark Miller\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527289_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 21:59\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T21:59:55+0000\'\u003e13\\/Sep\\/07 21:59\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    I have to triple check, but on first glance, my apps performance halfed using the ConcurrentMergeScheduler on a recent core duo with 2 GB RAM (As compared to the SerialMergeSceduler). Seems unexpected?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527295\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527295&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527295\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527295_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527295_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:06\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:06:38+0000\'\u003e13\\/Sep\\/07 22:06\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\\n\u003cp\u003e&gt; Today, applications use multiple threads on IndexWriter to get some\u003cbr\\/\u003e\\n&gt; concurrency on document parsing. With this patch, applications that\u003cbr\\/\u003e\\n&gt; want concurrent merges would simply use ConcurrentMergeScheduler,\u003cbr\\/\u003e\\n&gt; no?\u003c\\/p\u003e\\n\\n\u003cp\u003eTrue.  OK I will make SerialMergeScheduler.merge serialized.  This way\u003cbr\\/\u003e\\nonly one merge can happen at a time even when the application is using\u003cbr\\/\u003e\\nmultiple threads.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527295_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527295_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:06\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:06:38+0000\'\u003e13\\/Sep\\/07 22:06\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                   \\n &gt; Today, applications use multiple threads on IndexWriter to get some \\n&gt; concurrency on document parsing. With this patch, applications that \\n&gt; want concurrent merges would simply use ConcurrentMergeScheduler, \\n&gt; no? \\n\\n True.  OK I will make SerialMergeScheduler.merge serialized.  This way \\nonly one merge can happen at a time even when the application is using \\nmultiple threads.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527297\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527297&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527297\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527297_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527297_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:07\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:07:31+0000\'\u003e13\\/Sep\\/07 22:07\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; I have to triple check, but on first glance, my apps performance\u003cbr\\/\u003e\\n&gt; halfed using the ConcurrentMergeScheduler on a recent core duo with\u003cbr\\/\u003e\\n&gt; 2 GB RAM (As compared to the SerialMergeSceduler). Seems unexpected?\u003c\\/p\u003e\\n\\n\u003cp\u003eWhoa, that\'s certainly unexpected!  I\'ll go re-run my perf test.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527297_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527297_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:07\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:07:31+0000\'\u003e13\\/Sep\\/07 22:07\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; I have to triple check, but on first glance, my apps performance \\n&gt; halfed using the ConcurrentMergeScheduler on a recent core duo with \\n&gt; 2 GB RAM (As compared to the SerialMergeSceduler). Seems unexpected? \\n\\n Whoa, that\'s certainly unexpected!  I\'ll go re-run my perf test.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527300\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527300&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527300\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"markrmiller@gmail.com\\\" id=\\\"commentauthor_12527300_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=markrmiller%40gmail.com\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"markrmiller@gmail.com\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Mark Miller\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527300_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:42\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:42:15+0000\'\u003e13\\/Sep\\/07 22:42\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eLooks like some anomalous tests. Last night I checked twice, but today results are: 58 to 48 in favor of Concurrent. I am going to assume my first results where invalid. Sorry for the noise and thanks for the great patch. Has passed quite a few stress tests I run on my app without any problems so far. Do both merge policies allow for a closer to constant add time or is it just the Concurrent policy?\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"markrmiller@gmail.com\\\" id=\\\"commentauthor_12527300_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=markrmiller%40gmail.com\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"markrmiller@gmail.com\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Mark Miller\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527300_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:42\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:42:15+0000\'\u003e13\\/Sep\\/07 22:42\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Looks like some anomalous tests. Last night I checked twice, but today results are: 58 to 48 in favor of Concurrent. I am going to assume my first results where invalid. Sorry for the noise and thanks for the great patch. Has passed quite a few stress tests I run on my app without any problems so far. Do both merge policies allow for a closer to constant add time or is it just the Concurrent policy?              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527304\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527304&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527304\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527304_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527304_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:50\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:50:44+0000\'\u003e13\\/Sep\\/07 22:50\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003e&gt; Looks like some anomalous tests. Last night I checked twice, but\u003cbr\\/\u003e\\n&gt; today results are: 58 to 48 in favor of Concurrent. I am going to\u003cbr\\/\u003e\\n&gt; assume my first results where invalid. Sorry for the noise and\u003cbr\\/\u003e\\n&gt; thanks for the great patch.\u003c\\/p\u003e\\n\\n\u003cp\u003eOK, phew!\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Has passed quite a few stress tests I run on my app without any\u003cbr\\/\u003e\\n&gt; problems so far.\u003c\\/p\u003e\\n\\n\u003cp\u003eI\'m glad to hear that \u003cimg class=\\\"emoticon\\\" src=\\\"\\/jira\\/images\\/icons\\/emoticons\\/smile.png\\\" height=\\\"16\\\" width=\\\"16\\\" align=\\\"absmiddle\\\" alt=\\\"\\\" border=\\\"0\\\"\\/\u003e  Thanks for being such an early adopter!\u003c\\/p\u003e\\n\\n\u003cp\u003e&gt; Do both merge policies allow for a closer to constant add time or is\u003cbr\\/\u003e\\n&gt; it just the Concurrent policy?\u003c\\/p\u003e\\n\\n\u003cp\u003eNot sure I understand the question &#8211; you mean addDocument?  Yes it\'s\u003cbr\\/\u003e\\nonly ConcurrentMergeScheduler that should keep addDocument calls\u003cbr\\/\u003e\\nconstant time, because SerialMergeScheduler will hijack the addDocument\u003cbr\\/\u003e\\nthread to do its merges.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527304_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527304_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'13\\/Sep\\/07 22:50\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-13T22:50:44+0000\'\u003e13\\/Sep\\/07 22:50\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    &gt; Looks like some anomalous tests. Last night I checked twice, but \\n&gt; today results are: 58 to 48 in favor of Concurrent. I am going to \\n&gt; assume my first results where invalid. Sorry for the noise and \\n&gt; thanks for the great patch. \\n\\n OK, phew! \\n\\n &gt; Has passed quite a few stress tests I run on my app without any \\n&gt; problems so far. \\n\\n I\'m glad to hear that    Thanks for being such an early adopter! \\n\\n &gt; Do both merge policies allow for a closer to constant add time or is \\n&gt; it just the Concurrent policy? \\n\\n Not sure I understand the question &#8211; you mean addDocument?  Yes it\'s \\nonly ConcurrentMergeScheduler that should keep addDocument calls \\nconstant time, because SerialMergeScheduler will hijack the addDocument \\nthread to do its merges.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \\n\\n\\n\u003cdiv id=\\\"comment-12527557\\\" class=\\\"issue-data-block activity-comment twixi-block  expanded\\\"\u003e\\n    \u003cdiv class=\\\"twixi-wrap verbose actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Collapse comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-expanded\\\"\u003e\u003cspan\u003eHide\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-links\\\"\u003e\\n                \u003ca href=\\\"\\/jira\\/browse\\/LUCENE-847?focusedCommentId=12527557&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12527557\\\"\\n                   title=\\\"Right click and copy link for a permanent link to this comment.\\\" class=\\\"activitymodule-link issue-comment-action\\\"\u003e\\n                    \u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-link\\\"\u003ePermalink\u003c\\/span\u003e\u003c\\/a\u003e\\n                                            \u003c\\/div\u003e\\n            \u003cdiv class=\\\"action-details\\\"\u003e        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527557_verbose\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527557_verbose subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Sep\\/07 16:19\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-14T16:19:53+0000\'\u003e14\\/Sep\\/07 16:19\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e  \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n        \u003cdiv class=\\\"action-body flooded\\\"\u003e\u003cp\u003eAttached take8, incorporating Ning\'s feedback plus some small\u003cbr\\/\u003e\\nrefactoring and fixing one case where optimize() would do an\u003cbr\\/\u003e\\nunecessary merge.\u003c\\/p\u003e \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n    \u003cdiv class=\\\"twixi-wrap concise actionContainer\\\"\u003e\\n        \u003cdiv class=\\\"action-head\\\"\u003e\\n            \u003ca href=\\\"#\\\" title=\\\"Expand comment\\\" class=\\\"twixi\\\"\u003e\u003cspan class=\\\"icon-default aui-icon aui-icon-small aui-iconfont-collapsed\\\"\u003e\u003cspan\u003eShow\u003c\\/span\u003e\u003c\\/span\u003e\u003c\\/a\u003e\\n            \u003cdiv class=\\\"action-details flooded\\\"\u003e\\n                        \\n    \\n    \\n    \\n                \\n\\n    \u003ca class=\\\"user-hover user-avatar\\\" rel=\\\"mikemccand\\\" id=\\\"commentauthor_12527557_concise\\\" href=\\\"\\/jira\\/secure\\/ViewProfile.jspa?name=mikemccand\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-xsmall\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"https:\\/\\/issues.apache.org\\/jira\\/secure\\/useravatar?size=xsmall&amp;avatarId=10452\\\" alt=\\\"mikemccand\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e Michael McCandless\u003c\\/a\u003e\\n added a comment  - \u003cspan class=\'commentdate_12527557_concise subText\'\u003e\u003cspan class=\'date user-tz\' title=\'14\\/Sep\\/07 16:19\'\u003e\u003ctime class=\'livestamp\' datetime=\'2007-09-14T16:19:53+0000\'\u003e14\\/Sep\\/07 16:19\u003c\\/time\u003e\u003c\\/span\u003e\u003c\\/span\u003e                    Attached take8, incorporating Ning\'s feedback plus some small \\nrefactoring and fixing one case where optimize() would do an \\nunecessary merge.              \u003c\\/div\u003e\\n        \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\u003c\\/div\u003e\\n                             \u003c\\/div\u003e\\n    \u003c\\/div\u003e\\n\"";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script> 
  <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["scope-filter-data"]="{\"createScopeActions\":[],\"scopes\":[]}";
WRM._unparsedData["sidebar-collapsed-by-default"]="true";
WRM._unparsedData["com.atlassian.jira.projects.shortcuts:can-manage"]="false";
WRM._unparsedData["com.atlassian.jira.projects.shortcuts:with-icons"]="false";
WRM._unparsedData["com.atlassian.jira.projects.shortcuts:shortcuts"]="[]";
WRM._unparsedData["com.atlassian.jira.projects.shortcuts:project-id"]="12310110";
WRM._unparsedData["sidebar-id"]="\"\u003cdiv class=\\\"aui-sidebar  projects-sidebar sidebar-pending\\\" \u003e\u003cdiv class=\\\"aui-sidebar-wrapper\\\"\u003e\u003cdiv class=\\\"aui-sidebar-body\\\"\u003e\u003cheader class=\\\"aui-page-header\\\"\u003e\u003cdiv class=\\\"aui-page-header-inner\\\"\u003e\u003cdiv class=\\\"aui-page-header-image\\\"\u003e\u003ca href=\\\"\\/jira\\/projects\\/LUCENE\\/summary\\\" title=\\\"Lucene - Core\\\" class=\\\"jira-project-avatar\\\"\u003e\u003cspan class=\\\"aui-avatar aui-avatar-large aui-avatar-project\\\"\u003e\u003cspan class=\\\"aui-avatar-inner\\\"\u003e\u003cimg src=\\\"\\/jira\\/secure\\/projectavatar?pid=12310110&amp;avatarId=10061\\\" alt=\\\"Lucene - Core\\\" \\/\u003e\u003c\\/span\u003e\u003c\\/span\u003e\u003cimg src=\\\"data:image\\/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI\\/Pg0KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE4LjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDMwMCAzMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMwMCAzMDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnIGlkPSJMYXllcl8yIj4NCgk8cGF0aCBzdHlsZT0iZmlsbDojRjc5MjMyOyIgZD0iTTE1MCwwQzY2LjY2NywwLDAsNjYuNjY3LDAsMTUwczY2LjY2NywxNTAsMTUwLDE1MHMxNTAtNjYuNjY3LDE1MC0xNTBTMjMzLjMzMywwLDE1MCwweg0KCQkgTTEzNi42NjcsMTc4LjMzM0wxMjUsMTkwbC00MS42NjctNDBMOTUsMTM4LjMzM2wzMC0zMEwxMzYuNjY3LDEyMGwtMzAsMzBMMTM2LjY2NywxNzguMzMzeiBNMjA1LDE2MS42NjdsLTMwLDMwTDE2My4zMzMsMTgwDQoJCWwzMC0zMGwtMzAtMzBMMTc1LDEwOC4zMzNMMjE2LjY2NywxNTBMMjA1LDE2MS42Njd6Ii8+DQo8L2c+DQo8Zz4NCgk8cG9seWdvbiBzdHlsZT0iZmlsbDojRkZGRkZGOyIgcG9pbnRzPSIxNzUsMTkxLjY2NyAyMDUsMTYxLjY2NyAyMTYuNjY3LDE1MCAxNzUsMTA4LjMzMyAxNjMuMzMzLDEyMCAxOTMuMzMzLDE1MCAxNjMuMzMzLDE4MCAJIi8+DQoJPHBvbHlnb24gc3R5bGU9ImZpbGw6I0ZGRkZGRjsiIHBvaW50cz0iMTI1LDEwOC4zMzMgOTUsMTM4LjMzMyA4My4zMzMsMTUwIDEyNSwxOTAgMTM2LjY2NywxNzguMzMzIDEwNi42NjcsMTUwIDEzNi42NjcsMTIwIAkiLz4NCjwvZz4NCjwvc3ZnPg0K\\\" alt=\\\"Icon indicating the project type\\\" class=\\\"jira-project-avatar-icon\\\" \\/\u003e\u003c\\/a\u003e\u003c\\/div\u003e\u003c!-- .aui-page-header-image --\u003e\u003cdiv class=\\\"aui-page-header-main\\\"\u003e\u003ch1\u003e\u003cdiv class=\\\"aui-group aui-group-split\\\"\u003e\u003cdiv class=\\\"aui-item project-title\\\"\u003e\u003ca href=\\\"\\/jira\\/projects\\/LUCENE\\/summary\\\" title=\\\"Lucene - Core\\\"\u003eLucene - Core\u003c\\/a\u003e\u003c\\/div\u003e\u003c\\/div\u003e\u003c\\/h1\u003e\u003c\\/div\u003e\u003c!-- .aui-page-header-main --\u003e\u003c\\/div\u003e\u003c!-- .aui-page-header-inner --\u003e\u003c\\/header\u003e\u003c!-- .aui-page-header --\u003e\u003cnav class=\\\"aui-navgroup aui-navgroup-vertical\\\"\u003e\u003cdiv class=\\\"aui-navgroup-inner sidebar-content-container\\\"\u003e\u003cdiv class=\\\"aui-sidebar-group aui-sidebar-group-tier-one\\\" data-id=\\\"sidebar-navigation-panel\\\"\u003e\u003cul class=\\\"aui-nav\\\"\u003e\u003cli class=\\\"aui-nav-selected\\\" \u003e\u003ca class=\\\"aui-nav-item \\\" href=\\\"\\/jira\\/projects\\/LUCENE\\/issues\\\" data-link-id=\\\"com.atlassian.jira.jira-projects-issue-navigator:sidebar-issue-navigator\\\" \u003e\u003cspan class=\\\"aui-icon aui-icon-large icon-sidebar-issues\\\"\u003e\u003c\\/span\u003e\u003cspan class=\\\"aui-nav-item-label\\\" title=\\\"Issues\\\"\u003eIssues\u003c\\/span\u003e\u003c\\/a\u003e\u003c\\/li\u003e\u003cli  \u003e\u003ca class=\\\"aui-nav-item \\\" href=\\\"\\/jira\\/projects\\/LUCENE?selectedItem=com.atlassian.jira.jira-projects-plugin:report-page\\\" data-link-id=\\\"com.atlassian.jira.jira-projects-plugin:report-page\\\" \u003e\u003cspan class=\\\"aui-icon aui-icon-large agile-icon-report\\\"\u003e\u003c\\/span\u003e\u003cspan class=\\\"aui-nav-item-label\\\" title=\\\"Reports\\\"\u003eReports\u003c\\/span\u003e\u003c\\/a\u003e\u003c\\/li\u003e\u003cli  \u003e\u003ca class=\\\"aui-nav-item \\\" href=\\\"\\/jira\\/projects\\/LUCENE?selectedItem=com.atlassian.jira.jira-projects-plugin:components-page\\\" data-link-id=\\\"com.atlassian.jira.jira-projects-plugin:components-page\\\" \u003e\u003cspan class=\\\"aui-icon aui-icon-large icon-sidebar-components\\\"\u003e\u003c\\/span\u003e\u003cspan class=\\\"aui-nav-item-label\\\" title=\\\"Components\\\"\u003eComponents\u003c\\/span\u003e\u003c\\/a\u003e\u003c\\/li\u003e\u003c\\/ul\u003e\u003c\\/div\u003e\u003c\\/div\u003e\u003c\\/nav\u003e\u003c\\/div\u003e\u003cdiv class=\\\"aui-sidebar-footer\\\"\u003e\u003ca class=\\\"aui-button aui-button-subtle aui-sidebar-toggle aui-sidebar-footer-tipsy\\\" data-tooltip=\\\"Expand sidebar ( [ )\\\" href=\\\"#\\\"\u003e\u003cspan class=\\\"aui-icon aui-icon-small\\\"\u003e\u003c\\/span\u003e\u003c\\/a\u003e\u003c\\/div\u003e\u003c\\/div\u003e\u003c\\/div\u003e\"";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script> 
  <script type="text/javascript" src="/jira/s/d41d8cd98f00b204e9800998ecf8427e-CDN/-juyfor/76005/1c78b578e5c0e813799ab2baea47b6f7/1.0/_/download/batch/jira.webresources:bigpipe-init/jira.webresources:bigpipe-init.js" data-wrm-key="jira.webresources:bigpipe-init" data-wrm-batch-type="resource" data-initially-rendered></script> 
  <form id="jira_request_timing_info" class="dont-default-focus"> 
   <fieldset class="parameters hidden"> 
    <input type="hidden" title="jira.request.start.millis" value="1516202076410"> 
    <input type="hidden" title="jira.request.server.time" value="1002"> 
    <input type="hidden" title="jira.request.id" value="914x7659670x13"> 
    <input type="hidden" title="jira.session.expiry.time" value="-"> 
    <input type="hidden" title="jira.session.expiry.in.mins" value="-"> 
    <input id="jiraConcurrentRequests" type="hidden" name="jira.request.concurrent.requests" value="15"> 
    <input type="hidden" title="db.reads.time.in.ms" value="83"> 
    <input type="hidden" title="db.conns.time.in.ms" value="89"> 
   </fieldset> 
  </form> 
  <!--
	                 REQUEST ID : 914x7659670x13
	          REQUEST TIMESTAMP : [17/Jan/2018:15:14:36 +0000]
	               REQUEST TIME : 1.0020
	                 ASESSIONID : -
	        CONCURRENT REQUESTS : 15

	                      db.reads : OpSnapshot{name='db.reads', invocationCount=30, elapsedTotal=83290266, elapsedMin=461881, elapsedMax=32781193, resultSetSize=0, cpuTotal=0, cpuMin=0, cpuMax=0}
	                      db.conns : OpSnapshot{name='db.conns', invocationCount=34, elapsedTotal=89732212, elapsedMin=492462, elapsedMax=32831819, resultSetSize=0, cpuTotal=0, cpuMin=0, cpuMax=0}
-->   
 </body>
</html>